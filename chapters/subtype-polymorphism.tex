\setchapterpreamble[u]{\margintoc}
\chapter{Subtype Polymorphism}
\labch{subtype-polymorphism}

\renewcommand{\plang}{\textsf{TFAE}\xspace}
\renewcommand{\lang}{\textsf{STFAE}\xspace}

This article defines \lang by adding records and subtype polymorphism to \lang.
It defines the abstract syntax, the dynamic semantics, and the type system of
\lang.

\section{Abstract Syntax}

The following shows the abstract syntax of \lang:

\[
\begin{array}{rrcl}
\text{Label} & l & \in & \mathcal{L} \\
\text{Expression} & e & ::= & \cdots \\
&&|& \{l=e,\cdots,l=e\} \\
&&|& e.l \\
\text{Value} & v & ::= & \cdots \\
&&|& \{l=v,\cdots,l=v\} \\
\text{Type} & \tau & ::= & \cdots \\
&&|& \{l:\tau,\cdots,l:\tau\} \\
\end{array}
\]

Omitted parts are the same as \lang.

Metavariable $l$ ranges over labels. Labels are the names of fields in
records.

$\{l_1=e_1,\cdots,l_n=e_n\}$ is an expression that creates a record value. A
record has zero or more fields. $l$'s are the names of the fields. This
article assumes that every field in a single record has a distinct name. For
evaluation of the expression, every $e_i$ needs to be evaluated. The result of
$e_i$ is the value of the field $l_i$.

$\{l_1=v_1,\cdots,l_n=v_n\}$ is a record value. $l$'s are the names of the
fields. $v_i$ is the value of the field $l_i$. For example, the result of
$\{a=1+2,b=3+4\}$ is $\{a=3,b=7\}$. The record has two fields: $a$ and
$b$. The value of $a$ is $3$, and the value of $b$ is $7$. $\{\}$
also is an expression that makes a record value. Its result is $\{\}$, which
is the empty record.

$\{l_1:\tau_1,\cdots,l_n:\tau_n\}$ is a record type. $l$'s are the names of
the fields. $\tau_i$ is the type of the field $l_i$. Since both $3$ and
$7$ are integers, the type of $\{a=3,b=7\}$ is \(\{a:\textsf{num},b:\textsf{
num}\}\). The type of $\{a=1+2,b=3+4\}$ also is \(\{a:\textsf{num},b:\textsf{
num}\}\). Similarly, the type of the empty record is $\{\}$.

$e.l$ is an expression that uses a record value. It is usually called a
projection. If the result of $e$ is $\{l_1=v_1,\cdots,l_n=v_n\}$, then
$e.l$ results in $v_i$ where $l_i$ is equal to $l$. The expression
computes the value of the field $l$ of a given record value. If $e$ does not
result in a record value, $e.l$ causes a type error at run time. If $e$
results in a record value that lacks a field named $l$, $e.l$ also causes a
type error. In the view of a type system, projections use record types. If the
type of $e$ is $\{l_1:\tau_1,\cdots,l_n:\tau_n\}$, then the type of $e.l$
is $\tau_i$ where $l_i$ is equal to $l$. For example, since
$\{a=1+2,b=3+4\}$ results in $\{a=3,b=7\}$, $\{a=1+2,b=3+4\}.a$ results in
$3$. The type of $\{a=1+2,b=3+4\}$ is $\{a:\textsf{num},b:\textsf{num}\}$, and
the type of $\{a=1+2,b=3+4\}.a$ is, therefore, $\textsf{num}$. On the other hand,
$\{a=1+2,b=3+4\}.c$ causes a type error and is an ill-typed expression because
the record lacks a field named $c$.

\section{Dynamic Semantics}

It is enough to consider only the semantics of records and projections. Other
expressions have the same semantics as \lang.

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow v_1 \\ \cdots \\ \sigma\vdash e_n\Rightarrow v_n }
{ \sigma\vdash \{l_1=e_1,\cdots,l_n=e_n\}\Rightarrow\{l_1=v_1,\cdots,l_n=v_n\} }
\]

Every $e_i$ has to be evaluated for evaluation of
$\{l_1=e_1,\cdots,l_n=e_n\}$. If the value of $e_1$ is $v_1$, the value of
the field $l_i$ is $v_i$. The result is $\{l_1=v_1,\cdots,l_n=v_n\}$.

\[
\inferrule
{ \sigma\vdash e\Rightarrow\{l_1=v_1,\cdots,l=v,\cdots,l_n=v_n\} }
{ \sigma\vdash e.l\Rightarrow v }
\]

$e$ has to be evaluated first for evaluation of $e.l$. The result $e$ must
be a record that contains a field named $l$. The value of $e.l$ is the same
as the value of the field $l$.

\section{Type System}

\subsection{Typing Rules}

It is enough to consider only the semantics of records and projections. Other
typing rules are the same as those of \lang.

\[
\inferrule
{ \Gamma\vdash e_1:\tau_1 \\ \cdots \\ \Gamma\vdash e_n:\tau_n }
{ \Gamma\vdash
\{l_1=e_1,\cdots,l_n=e_n\}\Rightarrow\{l_1:\tau_1,\cdots,l_n:\tau_n\} }
\]

The value of $\{l_1=e_1,\cdots,l_n=e_n\}$ is $\{l_1=v_1,\cdots,l_n=v_n\}$.
Let the type of $v_i$ be $\tau_i$. The type of
$\{l_1=v_1,\cdots,l_n=v_n\}$ is $\{l_1:\tau_1,\cdots,l_n:\tau_n\}$, and,
therefore, the type of $\{l_1=e_1,\cdots,l_n=e_n\}$ also is
$\{l_1:\tau_1,\cdots,l_n:\tau_n\}$. Since the type of $v_i$ is $\tau_i$,
the type of $e_i$ also is $\tau_i$. Thus, it is enough to compute the type
of every $e_i$ to type-check $\{l_1=e_1,\cdots,l_n=e_n\}$.

\[
\inferrule
{ \Gamma\vdash e:\{l_1:\tau_1,\cdots,l:\tau,\cdots,l_n:\tau_n\} }
{ \Gamma\vdash e.l: \tau }
\]

$e.l$ can be evaluated without an error only if $e$ is well-typed and the
result of $e$ is a record containing a field named $l$. Therefore, the type
of $e$ has to be a record type that contains a field $l$. Then, the type of
$e.l$ is the type of $l$.

\subsection{Subtype Polymorphism}

The current type system is sound but not expressive enough. It rejects many
expressions that do not cause an error at run time. Consider the following
expression:

\[
(\lambda x:\{a:\textsf{num}\}.x.a)\ \{a=1,b=2\}
\]

The expression evaluates $\{a=1,b=2\}.a$, which yields $1$ without any
error. However, the type system rejects the expression. The type of
$\{a=1,b=2\}$ is $\{a:\textsf{num},b:\textsf{num}\}$, while the parameter type of
the function $\lambda x:\{a:\textsf{num}\}.x.a$ is $\{a:\textsf{num}\}$. Since the
types of the argument and the parameter differ from each other, it is ill-typed.

The type $\{a:\textsf{num}\}$ is the type of a record that has an integer-value
field $a$. Even though the record has fields other than $a$, it still has
the field $a$. Therefore, it would be correct to say that $\{a=1,b=2\}$ is a
value of the type $\{a:\textsf{num}\}$. However, under the current type system,
the only type of $\{a=1,b=2\}$ is $\{a:\textsf{num},b:\textsf{num}\}$. \(\{a:\textsf{
num}\}\) is not a type of $\{a=1,b=2\}$.

The type system should be able to consider $\{a=1,b=2\}$ to be a value of not
only $\{a:\textsf{num},b:\textsf{num}\}$ but also $\{a:\textsf{num}\}$. A language
feature that allows a single entity to be used as multiple types is called
polymorphism. The last article dealt with parametric polymorphism. However,
parametric polymorphism cannot resolve the current issue. A new sort of
polymorphism is required. It is time to consider subtype polymorphism.

Subtype polymorphism uses a notion of subtyping. Subtyping is a relation between
two types. $\tau_1<:\tau_2$ denotes that $\tau_1$ is a subtype of
$\tau_2$. If $\tau_1$ is a subtype of $\tau_2$, then $\tau_2$ is a
supertype of $\tau_1$, and a value of $\tau_1$ can be used where a value of
$\tau_2$ is expected. Subtype polymorphism is a concept based on
substitutability. The previous examples shows that a value of \(\{a:\textsf{
num},b:\textsf{num}\}\) can appear where a value of $\{a:\textsf{num}\}$ is
expected. Therefore, $\{a:\textsf{num},b:\textsf{num}\}$ is a subtype of \(\{a:\textsf{
num}\}\), and $\{a:\textsf{num}\}$ is a supertype of \(\{a:\textsf{num},b:\textsf{
num}\}\).

The type system needs a new typing rule to support subtype polymorphism. The
subtype relation of the type system will be shown soon. Just assume that the
relation has been defined already for a while. The following typing rule allows
a single expression to have multiple types by using the subtype relation:

\[
\inferrule
{ \Gamma\vdash e:\tau' \\ \tau'<:\tau }
{ \Gamma\vdash e:\tau }
\]

The rule is usually called a subsumption rule. The rule implies that if
$\tau'$ is a type of $e$ and $\tau'$ is a subtype of $\tau$, then
$\tau$ also is a type of $e$. Due to the subtype polymorphism, a single
expression can have multiple types. It is a big difference between \lang and the
hitherto languages.

\subsection{Subtyping Rules}

It is time to define subtyping rules of the language. As typing rules define the
types of expressions, subtyping rules define the subtype relation.

\subsubsection{Reflexivity}

The subtype relation is reflexive. A value of $\tau$ can be used where a value
of $\tau$ is expected. It is trivial. Thus, every type is a subtype of itself.
The following rule formalizes this fact:

\[\tau<:\tau\]

By the rule, $\{a:\textsf{num}\}<:\{a:\textsf{num}\}$ is true.

\subsubsection{Transitivity}

The subtype relation is transitive as well. Let $\tau_1$ be a subtype of
$\tau_2$ and $\tau_2$ be a subtype of $\tau_3$. A value of $\tau_2$ can
appear where a value of $\tau_3$ is expected. Also, a value of $\tau_1$ can
appear where a value of $\tau_2$ is expected. Therefore, a value of $\tau_1$
can replace a value of $\tau_3$ without causing an error. In conclusion,
$\tau_1$ is a subtype of $\tau_3$. The following rule formalizes the
transitivity:

\[
\inferrule
{ \tau_1<:\tau_2 \\ \tau_2<:\tau_3 }
{ \tau_1<:\tau_3 }
\]

The above two rules describe important properties of the subtype relation.
However, they are not enough to prove interesting facts, such as \(\{a:\textsf{
num},b:\textsf{num}\}<:\{a:\textsf{num}\}\).

\subsubsection{Width Rule}

Consider the previous example again. The type system should be able to prove
$\{a:\textsf{num},b:\textsf{num}\}<:\{a:\textsf{num}\}$. The following rule makes the
type system achieve the goal:

\[
\{l_1:\tau_1,\cdots,l_n:\tau_n,l:\tau\}<:\{l_1:\tau_1,\cdots,l_n:\tau_n\}
\]

If a field $l$ is appended to a record type
$\{l_1:\tau_1,\cdots,l_n:\tau_n\}$, the resulting type is a subtype of the
original type. It is a valid rule since even after a record value acquires one
more field, the record value will be able to do everything the original record
can do. Intuitively, the rule allows considering a record type of "a longer
width" to be a subtype of a record type of "a shorter width." For this reason,
the article calls the rule "the width rule." Other authors may not use the same
name. Now, $\{a:\textsf{num},b:\textsf{num}\}<:\{a:\textsf{num}\}$ is true.

The fact that $\{a:num\}$ is a type of $\{a=1,b=2\}$ can be provable. The
following proof tree proves the fact:

\[
\inferrule
{
  {\Large\inferrule
  { \emptyset\vdash1:\textsf{num} \\ \emptyset\vdash2:\textsf{num} }
  { \emptyset\vdash\{a=1,b=2\}:\{a:\textsf{num},b:\textsf{num}\} }} \\
  \{a:\textsf{num},b:\textsf{num}\}<:\{a:\textsf{num}\}}
{ \emptyset\vdash\{a=1,b=2\}:\{a:\textsf{num}\} }
\]

The following expression is now well-typed:

\[
(\lambda x:\{a:\textsf{num}\}.x.a)\ \{a=1,b=2\}
\]

Other interesting subtypes can be also found by the transitivity and the width
rule. For example, the following proof tree proves that \(\{a:\textsf{num},b:\textsf{
num},c:\textsf{num}\}<:\{a:\textsf{num}\}\).

\[
\inferrule
{
\{a:\textsf{num},b:\textsf{num},c:\textsf{num}\}<:\{a:\textsf{num},b:\textsf{num}\} \\
  \{a:\textsf{num},b:\textsf{num}\}<:\{a:\textsf{num}\}
}
{ \{a:\textsf{num},b:\textsf{num},c:\textsf{num}\}<:\{a:\textsf{num}\} }
\]

By the same principle, $\{\}$, which is the empty record type, is a supertype
of every record type. In other words, every record type is a subtype of
$\{\}$.

\subsubsection{Permutation Rule}

The type system is still restrictive. The following expression is ill-typed but
does not cause a run-time error:

\[
(\lambda x:\{a:\textsf{num},b:\textsf{num}\}.x.a)\ \{b=2,a=1\}
\]

The above expression evaluates $\{b=2,a=1\}.a$, which results in $1$.
However, it is ill-typed. The type of $\{b=2,a=1\}$ is \(\{b:\textsf{num},a:\textsf{
num}\}\), while the parameter type of the function \(\lambda x:\{a:\textsf{
num},b:\textsf{num}\}.x.a\) is $\{a:\textsf{num},b:\textsf{num}\}$.

In fact, the order among the fields of a record does not matter at all. If two
records have the same fields and each field has the same value in both records,
their behaviors as records are the same even if the orders are different. On the
contrary, the orders matter during type checking under the current type system.
It is sure that a value of $\{a:\textsf{num},b:\textsf{num}\}$ can replace a value
of $\{b:\textsf{num},a:\textsf{num}\}$ without causing a type error and vice versa.
Therefore, $\{a:\textsf{num},b:\textsf{num}\}$ should be a subtype of \(\{b:\textsf{
num},a:\textsf{num}\}\) and vice versa. The following rule solves the problem:

\[
\inferrule
{ \{(l_1,\tau_1),\cdots,(l_n,\tau_n)\}=\{(l'_1,\tau'_1),\cdots,(l'_n,\tau'_n)\} }
{ \{l_1:\tau_1,\cdots,l_n:\tau_n\}<:\{l'_1:\tau'_1,\cdots,l'_n:\tau'_n\} }
\]

Equality of sets is determined solely by elements in sets. Orders do not matter.
The rule implies that altering the order among the fields of a record type makes
a subtype of the record type. The article calls it "the permutation rule." Other
authors may not use the same term. The following proof trees prove that
$\{a:\textsf{num},b:\textsf{num}\}<:\{b:\textsf{num},a:\textsf{num}\}$ and \(\{b:\textsf{
num},a:\textsf{num}\}<:\{a:\textsf{num},b:\textsf{num}\}\).

\[
\inferrule
{ \{(a,\textsf{num}),(b,\textsf{num})\}=\{(b,\textsf{num}),(a,\textsf{num})\} }
{ \{a:\textsf{num},b:\textsf{num}\}<:\{b:\textsf{num},a:\textsf{num}\} }
\]

\[
\inferrule
{ \{(b,\textsf{num}),(a,\textsf{num})\}=\{(a,\textsf{num}),(b,\textsf{num})\} }
{ \{b:\textsf{num},a:\textsf{num}\}<:\{a:\textsf{num},b:\textsf{num}\} }
\]

The following expression is now well-typed:

\[
(\lambda x:\{a:\textsf{num},b:\textsf{num}\}.x.a)\ \{b=2,a=1\}
\]

Other interesting subtypes can be also found by the width and permutation rules.
The following proof tree proves that \(\{b:\textsf{num},a:\textsf{num}\}<:\{a:\textsf{
num}\}\).

\[
\inferrule
{{\Large
  \inferrule
  { \{(a,\textsf{num}),(b,\textsf{num})\}=\{(b,\textsf{num}),(a,\textsf{num})\} }
  { \{a:\textsf{num},b:\textsf{num}\}<:\{b:\textsf{num},a:\textsf{num}\} }} \\
  \{b:\textsf{num},a:\textsf{num}\}<:\{b:\textsf{num}\}
}
{ \{a:\textsf{num},b:\textsf{num}\}<:\{b:\textsf{num}\} }
\]

\subsubsection{Depth Rule}

The type system still can be improved more. Consider the following expression:

\[
(\lambda x:\{a:\{a:\textsf{num},b:\textsf{num}\}\}.(\lambda
x:\{a:\{a:\textsf{num}\}\}.x.a.a)\ x)\ \{a=\{a=1,b=2\}\}
\]

The above expression evaluates $\{a=\{a=1,b=2\}\}.a.a$. Since
$\{a=\{a=1,b=2\}\}.a$ results in $\{a=1,b=2\}$ and $\{a=1,b=2\}.a$ results
in $1$, the expression results in $1$ without any error. However, the
expression is well-typed. The type of $x$ is \(\{a:\{a:\textsf{num},b:\textsf{
num}\}\}\), while the parameter type of the function \(\lambda x:\{a:\{a:\textsf{
num}\}\}.x.a.a\) is $\{a:\{a:\textsf{num}\}\}$.

The current type system is too strict to the type of a field in a record. For
example, consider $\{a:\{a:\textsf{num}\}\}$. Any other type of the form
$\{a:\tau\}$ cannot be a subtype of $\{a:\{a:\textsf{num}\}\}$. However, it
would be beneficial to allow some other types to be subtypes. Let the type of
$e$ be $\{a:\{a:\textsf{num}\}\}$. Then, the result of $e.a$ can be used
where a value of $\{a:\textsf{num}\}$ is expected. Now, let the type of $e'$ be
$\{a:\{a:\textsf{num},b:\textsf{num}\}\}$. The result of $e.a$ is a value of
$\{a:\textsf{num},b:\textsf{num}\}$. It is known that \(\{a:\textsf{num},b:\textsf{
num}\}\) is a subtype of $\{a:\textsf{num}\}$. Therefore, $e'.a$ can replace
$e.a$ without causing a type error. It implies that $e'$ can be used instead
of $e$. In other words, $\{a:\{a:\textsf{num},b:\textsf{num}\}\}$ is a subtype of
$\{a:\{a:\textsf{num}\}\}$. More generally, if $\tau<:\{a:\textsf{num}\}$, then
$\{a:\tau\}<:\{a:\{a:\textsf{num}\}\}$.

The same logic can be applied to any records regardless of the names and the
number of fields. It leads to the following rule:

\[
\inferrule
{ \tau_1<:\tau'_1 \\ \cdots \\ \tau_n<:\tau'_n }
{ \{l_1:\tau_1,\cdots,l_n:\tau_n\}<:\{l_1:\tau'_1,\cdots,l_n:\tau'_n\} }
\]

It makes the subtype relation to consider the types of fields in record types.
The article calls it "the depth rule" since the rule inspects record types more
"deeply." Other authors may not use the same term. The following proof tree
proves that $\{a:\{a:\textsf{num},b:\textsf{num}\}\}<:\{a:\{a:\textsf{num}\}\}$:

\[
\inferrule
{ \{a:\textsf{num},b:\textsf{num}\}<:\{a:\textsf{num}\} }
{ \{a:\{a:\textsf{num},b:\textsf{num}\}\}<:\{a:\{a:\textsf{num}\}\} }
\]

The following expression is now well-typed:

\[
(\lambda x:\{a:\{a:\textsf{num},b:\textsf{num}\}\}.(\lambda
x:\{a:\{a:\textsf{num}\}\}.x.a.a)\ x)\ \{a=\{a=1,b=2\}\}
\]

Finally, the subtype relation is precise enough for record types.

\subsubsection{Subtyping Rule for Function Types}

It is time to consider a subtyping rule for function types. A function type
consists of the parameter type and the return type. The article explains about
the return type first and then the parameter type.

Consider two function types: $\tau_1\rightarrow\tau_2$ and
$\tau_1\rightarrow\tau_2'$. Assume that $\tau_2$ is a subtype of
$\tau_2'$.

Can $\tau_1\rightarrow\tau_2$ be a subtype of $\tau_1\rightarrow\tau_2'$? If
so, then a value of $\tau_1\rightarrow\tau_2$ can be used where a value of
$\tau_1\rightarrow\tau_2'$ is expected. Let the type of $e_1'$ be
$\tau_1\rightarrow\tau_2'$. Then, $e_1'$ can be appear at the function
position of a function application. Let $e_2$ be an expression of $\tau_1$.
$e_1'\ e_2$ is well-typed, and its type is $\tau_2'$. The result of the
function application can be used anywhere a value of $\tau_2'$ is expected.
Now, we are going to check whether $e_1$, whose type is
$\tau_1\rightarrow\tau_2$, can replace $e_1'$. Consider $e_1\ e_2$. Since
the parameter type of $e_1$ is $\tau_1$, it is well-formed. The result is a
value of $\tau_2$, which is a subtype of $\tau_2'$. Therefore, the result of
the function application can be used where a value of $\tau_2'$ is expected.
It implies that $e_1\ e_2$ can replace $e_1'\ e_2$ without causing a type
error. Function applications are only use of functions. Thus, $e_1$ can
replace $e_1'$, and $\tau_1\rightarrow\tau_2$ is a subtype of
$\tau_1\rightarrow\tau_2'$. The following rule formalizes this fact:

\[
\inferrule
{ \tau_2<:\tau_2' }
{ \tau_1\rightarrow\tau_2<:\tau_1\rightarrow\tau_2' }
\]

Function types preserves the subtype relation between their return types.
Suppose that there are two function types. If their parameter types are the same
and the return type of the former is a subtype of that of the latter, then the
former is a subtype of the latter. For example, \(\textsf{num}\rightarrow\{a:\textsf{
num},b:\textsf{num}\}\) is a subtype of , $\textsf{num}\rightarrow\{a:\textsf{num}\}$.

Consider two function types: $\tau_1\rightarrow\tau_2$ and
$\tau_1'\rightarrow\tau_2$. Assume that $\tau_1'$ is a subtype of
$\tau_1$.

Can $\tau_1\rightarrow\tau_2$ be a subtype of $\tau_1'\rightarrow\tau_2$?
Let the type of $e_1$ be $\tau_1\rightarrow\tau_2$ and the type of $e_1'$
be $\tau_1'\rightarrow\tau_2$. Since their return type are the same, their
return values can be used at the same place. It is enough to focus on their
arguments. Let the type of $e_2$ be $\tau_1'$. Then, $e_1'\ e_2$ is
well-typed since the parameter type of $e_1'$ is equal to the type of $e_2$.
On the other hand, $e_1$ can take a value of $\tau_1$ as an argument. Every
expression whose type is $\tau_1$ can be an argument. The type of $e_2$ is
$\tau_1'$. By the assumption that $\tau_1'$ is a subtype of $\tau_1$,
$e_2$ can be used where a value of $\tau_1$ is expected. Thus, $e_2$ can
be an argument for $e_1$. $e_1\ e_2$ is a well-typed expression. In
conclusion, $e_1$ can replace $e_2$ without causing a type error, and
$\tau_1\rightarrow\tau_2$ is a subtype of $\tau_1'\rightarrow\tau_2$. The
following rule formalizes this fact:

\[
\inferrule
{ \tau_1'<:\tau_1 }
{ \tau_1\rightarrow\tau_2<:\tau_1'\rightarrow\tau_2 }
\]

Function types reverses the subtype relation between their parameter types.
Suppose that there are two function types. If their return types are the same
and the parameter type of the former is a supertype of that of the latter, then
the former is a subtype of the latter. For example, , \(\{a:\textsf{
num}\}\rightarrow\textsf{num}\) is a subtype of \(\{a:\textsf{num},b:\textsf{
num}\}\rightarrow\textsf{num}\).

The above rules can combine to form one rule:

\[
\inferrule
{ \tau_1'<:\tau_1 \\ \tau_2<:\tau_2' }
{ \tau_1\rightarrow\tau_2<:\tau_1'\rightarrow\tau_2' }
\]

The above rule is the final version of a subtyping rule for function types.

Below shows all the subtyping rules of \lang:

\[\tau<:\tau\]

\[
\inferrule
{ \tau_1<:\tau_2 \\ \tau_2<:\tau_3 }
{ \tau_1<:\tau_3 }
\]

\[
\{l_1:\tau_1,\cdots,l_n:\tau_n,l:\tau\}<:\{l_1:\tau_1,\cdots,l_n:\tau_n\}
\]

\[
\inferrule
{ \{(l_1,\tau_1),\cdots,(l_n,\tau_n)\}=\{(l'_1,\tau'_1),\cdots,(l'_n,\tau'_n)\} }
{ \{l_1:\tau_1,\cdots,l_n:\tau_n\}<:\{l'_1:\tau'_1,\cdots,l'_n:\tau'_n\} }
\]

\[
\inferrule
{ \tau_1<:\tau'_1 \\ \cdots \\ \tau_n<:\tau'_n }
{ \{l_1:\tau_1,\cdots,l_n:\tau_n\}<:\{l_1:\tau'_1,\cdots,l_n:\tau'_n\} }
\]

\[
\inferrule
{ \tau_1'<:\tau_1 \\ \tau_2<:\tau_2' }
{ \tau_1\rightarrow\tau_2<:\tau_1'\rightarrow\tau_2' }
\]

\section{Extending \lang}

\lang can be easily extended with a few types.

\subsection{Top Type}

\[
\begin{array}{rrcl}
\text{Type} & \tau & ::= & \cdots \\
&&|& \top \\
\end{array}
\]

$\top$ is the top type. The top type is a supertype of every type, and every
type is a subtype of the top type. Every value is a value of the top type. The
following is a subtyping rule for the top type:

\[\tau<:\top\]

The top type can be used to give a single type to two or more completely
irrelevant expressions. Suppose that the language has conditional expressions.
Then, the type of the following expression is $\{a:\textsf{num}\}$:

\[\textsf{if}\ \textsf{true}\ \{a=1\}\ \{a=1,b=2\}\]

However, the following expression is ill-formed in \lang even though it does not
cause a type error:

\[\textsf{if}\ \textsf{true}\ \{a=1\}\ 1\]

By extending \lang with the top type, the type of the above expression can be
$\top$.

\subsection{Bottom Type}

\[
\begin{array}{rrcl}
\text{Type} & \tau & ::= & \cdots \\
&&|& \bot \\
\end{array}
\]

$\bot$ is the bottom type. The bottom type is a subtype of every type, and
every type is a supertype of the bottom type. The following is a subtyping rule
for the bottom type:

\[\bot<:\tau\]

Types like $\textsf{num}$ and $\textsf{num}\rightarrow\textsf{num}$ do not have any
common elements. Therefore, if a type is a subtype of every type, no value can
be a value of the type. The bottom type does not have any elements. Despite
the fact, the bottom type is useful. The bottom type can be the types of
expressions throwing exceptions or calling first-class continuations. Those
expressions do not result in any values. They only change the flow of
programs. Thus, it is quite natural to say that the type of such an expression
is the bottom type.

\section{Exercises}

\begin{enumerate}
\item Write whether each expression is well-typed in \lang.
If so, draw the type derivation. Otherwise, explain why.
\begin{enumerate}
\item
  $\textsf{if0}\ {1}\ {\{ \}}\ {2}$
\item
  $\textsf{if0}\ {1}\ {\{ \}}\ {\{\code{a}=2\}}$
\end{enumerate}

\item Consider \plang with lists in Exercise~1 of \refch{type-systems}.
  \begin{enumerate}
    \item When can $\textsf{list}\ \tau_1$ be a subtype of $\textsf{list}\
      \tau_2$? Write a new subtyping rule for list types.
    \item Suppose that we extend the language with an expression that mutates an element of
      a list (e.g. mutating a list containing $1$ and $2$ to contain
      $\textsf{true}$ and $2$).
      When can $\textsf{list}\ \tau_1$ be a subtype of $\textsf{list}\
      \tau_2$? Write a new subtyping rule for list types.
  \end{enumerate}

\item If we change Rule~\textsc{Sub-ArrowT} like below, the language is not type
  sound.
  \[
    \inferrule
    { \tau_1<:\tau_1' \\ \tau_2<:\tau_2' }
    { \tau_1\rightarrow\tau_2<:\tau_1'\rightarrow\tau_2' }
  \]
Write an expression that is accepted by the new type system but
causes a run-time error.

\item Consider \plang with boxes in Exercise~2 of \refch{type-systems}.
  When can $\textsf{box}\ \tau_1$ be a subtype of $\textsf{box}\ \tau_2$?
  Write a new subtyping rule for box types.

\item This exercise extends \lang with first-class continuations.

    \vspace{0.5em}
    $e\ ::=\ \cdots\ |\ (\textsf{vcc}\ x\ \textsf{in}\ e){:}\tau$
    \vspace{0.5em}

    The type of
    $(\textsf{vcc}\ x\ \textsf{in}\ e){:}\tau$ is $\tau$ when it is well-typed.

\begin{enumerate}
  \item
    Write the typing rule of $(\textsf{vcc}\ x\ \textsf{in}\ e){:}\tau$
    of the form \fbox{$\Gamma\vdash{e}:{\tau}$}.
  \item Draw the type derivation tree of
    $(\textsf{vcc}\ {\code{x}}\ \textsf{in}\ {\eapp{(\eapp{\code{x}}{1})}{42}}){:}\textsf{num}$.
\end{enumerate}

\item This exercse extends \textsf{TVFAE} to allow types with any numbers (including zero) of variants.

\vspace{0.5em}
$
    \small
  \begin{array}{@{}l}
    e ::=\ \cdots\ |\ {\textsf{type}}\ t=x@\tau+\ldots+x@\tau;\ e\ |\
           e\ {\textsf{match}}\ x(x)\rightarrow e,\ldots,x(x)\rightarrow e \\
  \end{array}
$

For example, you can write the following code in the extended language:

\vspace{0.5em}
$
  \begin{array}{@{}l}
    {\textsf{type}}\ \code{fruit}=\code{apple}@\tnum+\code{banana}@\tnum+\code{cherry}@\tnum;\\
    \ldots
  \end{array}
$
\vspace{0.5em}

Suppose that the operational semantics and the typing rules are the same as
those of \code{TVFAE} except that some rules are revised to handle zero or more
variants properly.

Some expressions are rejected by the type system even though
they do not cause run-time errors. The following expression is such an example:

\vspace{0.5em}
$
  \begin{array}{@{}l}
    \textsf{type}\ \code{abc}=\code{apple}@\tnum+\code{banana}@\tnum+\code{cherry}@\tnum;\\
    \textsf{val}\ \code{f}=\efun{\code{x}{:}\code{abc}}{(}\\
    \ \ \ \ \code{x}\ \textsf{match} \\
    \ \ \ \ \ \ \ \ \code{apple}(\code{a})\rightarrow\code{a} \\
    \ \ \ \ \ \ \ \ \code{banana}(\code{b})\rightarrow\code{b} \\
    \ \ \ \ \ \ \ \ \code{cherry}(\code{c})\rightarrow\code{c} \\
    );\\
    \textsf{type}\ \code{ab}=\code{apple}@\tnum+\code{banana}@\tnum;\\
    \eapp{\code{f}}{(\eapp{\code{apple}}{42})}
  \end{array}
$
\vspace{0.5em}

We want to add subtyping to the language to allow more expressions including
the above one. Add subtyping rule(s) of the form \fbox{$\Gamma\vdash\subt{\tau}{\tau}$}
to the language. Assume that the following rules already exist:

\[
  \inferrule{}{\Gamma\vdash\subt{\tau}{\tau}}
  \qquad
  \inferrule
  {\Gamma\vdash\subt{\tau_1}{\tau_2} \\ \Gamma\vdash\subt{\tau_2}{\tau_3}}
  {\Gamma\vdash\subt{\tau_1}{\tau_3}}
\]
\[
  \inferrule
  { \Gamma\vdash\subt{\tau_1'}{\tau_1} \\ \Gamma\vdash\subt{\tau_2}{\tau_2'} }
  { \Gamma\vdash\subt{{\tau_1}\rightarrow{\tau_2}}{{\tau_1'}\rightarrow{\tau_2'}} }
  \qquad
  \inferrule
  { \typeofd{e}{\tau'} \\ \Gamma\vdash\subt{\tau'}{\tau} }
  { \typeofd{e}{\tau} }
\]

% \item Consider the following language:\\

% \begin{tabular}{rr@{~}c@{~}ll}
% \mbox{class declaration} &
% $d$ &$::=$& class $C$ extends $C$ \verb+{+ $g^*\ k\ m^*$ \verb+}+\\
% \mbox{field declaration} &
% $g$ &$::=$&$x$:$C$;\\
% \mbox{constructor declaration} &
% $k$ &$::=$& $C$($(x\mtt{:} C)^*$) \verb+{+ super($x^*$); $(\mtt{this.}x \mtt{ = } x\mtt{;})^*$ \verb+}+\\
% \mbox{method declaration} &
% $m$ &$::=$& $f$($(x\mtt{:} C)^*$):$C$ \verb+{+ return $e$; \verb+}+\\
% \mbox{expression} &
% $e$ &$::=$& $x~\mid~e$.$x~\mid~e$.$f$($e^*$)$~\mid~$new $C$($e^*$)
% \end{tabular}

% where metavariables $C$, $D$, and $E$ range over class names,
% $x$ ranges over field names, and
% $f$ ranges over method names.
% We assume that the set of variables includes the special variable \mtt{this},
% which cannot be used as the name of an argument to a method.
% Instead, it is implicitly bound in every method declaration.
% The evaluation rule for method invocation will substitute an appropriate object
% for \mtt{this}, in addition to substituting the argument values for the parameters.

% With the following subtyping rules:

% \[
% \begin{array}{ccc}
% C~<:~C
% &\qquad
% \newinfrule{
% C~<:~D \qquad D~<:~E
% }
% {C~<:~E}
% &\qquad
% \newinfrule{
% \mtt{class}\ C\ \mtt{extends}\ D\ \{ \cdots \}
% }
% {C~<:~D}
% \end{array}
% \]
% and the following helper functions:

% \begin{tabular}{ll}
% $\embox{fields}(C) = x_1:C_1 \cdots x_n:C_n$
% & the fields of class $C$ are $x_1$ to $x_n$ of types $C_1$ to $C_n$, respectively
% \\[.5em]
% $\embox{mtype}(C, f) = C_1 \cdots C_n \rightarrow C_{n+1}$
% & the type of method $f$ defined in class $C$ is $C_1 \cdots C_n \rightarrow C_{n+1}$
% \\[.5em]
% $\embox{ctype}(C) = C_1 \cdots C_n \rightarrow C$
% & the type of the constructor of class $C$ is $C_1 \cdots C_n \rightarrow C$
% \end{tabular}

% \begin{itemize}
%   \item[a)] Write the typing rules of the form \fbox{$\Gamma\vdash e : C$} for the expressions.
% The typing rules for constructors and method invocations check that
% each actual argument has a type that is a subtype of the corresponding formal parameter type.
% The casting ``($C$)$e$'' is well typed only when the type of $e$ is a subtype of $C$.

%   \item[b)] The following judgment states that:

% \begin{center}
% \code{$C\ \vdash\ f$($x_1\mtt{:} C_1,\ \cdots\ x_n\mtt{:} C_n$):$C_{n+1}$ \{ return $e$; \}}
% \end{center}

% the method declaration defined in $C$ is well typed.
% Write its typing rule which checks the following:
% \begin{itemize}
% \item The type of $f$'s body expression $e$ should be a subtype of the annotated return type $C_{n+1}$.
% \item When class $C$ explicitly extends $D$
% (\verb!class! $C$ \verb!extends! $D$ \verb+{+ $\cdots$ \verb+}+),
% if $D$ defines any method of name $f$,
% the type of $f$ in $D$ should be the same with the type of $f$ in $C$.
% \end{itemize}
% \end{itemize}

% \item When a programming language provides overloading,
% multiple function declarations may have the same name.  Consider the following example:
% \begin{verbatim}
% 1 toString(x: Int): String = "line 1"
% 2 toString(x: Bool): String = "line 2"
% 3 toString(false)
% \end{verbatim}
% Even though two function declarations on lines 1 and 2 have the same name,
% it is clear that the one on line 2 is called on line 3 because of the different parameter types of the functions.

% When multiple function declarations may be called for a given function call like the following example:
% \begin{verbatim}
% 4 toString(x: Int): String = "line 4"
% 5 toString(x: Number): String = "line 5"
% 6 toString(42)
% \end{verbatim}
% the function declaration that is \emph{more specific than} all the other function declarations
% that may be called for the given function call is called.
% We say that a function declaration $f(x_1:A_1, \cdots, x_n:A_n)$ is more specific than $f(x_1:B_1, \cdots, x_n:B_n)$,
% if $A_i$ is a subtype of $B_i$ ($A_i <: B_i$) for $1 \le i \le n$.
% We assume that \verb!Int! is a subtype of \verb!Number!.
% When no single function declaration is more specific than all the other function declarations
% that may be called for a given function call,
% the function call shows an \emph{ambiguous call error}.

% \begin{itemize}
% \item[(a)] Explain why the following example shows an ambiguous call error:
% \begin{verbatim}
% 7 toString(x: Int, y: Number): String = "line 7"
% 8 toString(x: Number, y: Int): String = "line 8"
% 9 toString(42, 8)
% \end{verbatim}
% where both \verb!42! and \verb!8! have type \verb!Int!.

% Add one function declaration to remove the ambiguous call error.

% \item[(b)] For simplicity, we assume the following:
% \begin{itemize}
% \item Every function has exactly two parameters.
% \item The subtype relation is a parital order:

% \begin{tabular}{ll}
% reflexive &($T<:T$),\\
% antisymmetric &($T<:S$ and $S<:T$ implies $T=S$), and\\
% transitive &($T<:S$ and $S<:R$ implies $T<:R$).
% \end{tabular}
% \item If a type has two types as its supertypes, then the two supertypes also are in the subtype relation: if $T<:S$ and $T<:R$, then $S<:R$ or $R<:S$.
% \end{itemize}

% Now, we will create rules for a set of all the function declarations with the same name in a given program,
% which can ensure that there is no ambiguous function call if the rules are satisfied.
% Precisely, we want to make the following statement hold:
% \begin{quote}
% If a set of all the function declarations with the same name in a given program satisfies the rules,
% $\{m(x_{11}:T_{11},x_{12}:T_{12}): S_1=e_1,\ \cdots\ ,m(x_{n1}:T_{n1},x_{n2}:T_{n2}): S_n=e_n\}~\textsf{safe}$,\\
% then evaluation of the following program does not result in an ambiguous call error:
% \[
% \begin{array}{l}
% m(x_{11}:T_{11},x_{12}:T_{12}): S_1=e_1 \\
% \cdots \\
% m(x_{n1}:T_{n1},x_{n2}:T_{n2}): S_n=e_n \\
% m(e, e')
% \end{array}
% \]
% \end{quote}

% We formalize the \textsf{safe} rule as follows:\\[-2em]

% \[
% \inferrule
% {
%   \forall (i,j)\in\{(i,j):1\le i<j\le n\}.\ T_{i1}\neq T_{j1}\lor T_{i2}\neq T_{j2} \\
%   \forall (i,j)\in\{(i,j):1\le i<j\le n\}.\ (T_{i1},T_{i2})~\textsf{meet}~(T_{j1},T_{j2})~\textsf{wrt}~\{(T_{11},T_{12}),\ \cdots\ ,(T_{n1},T_{n2})\}
% }
% { \{m(x_{11}:T_{11},x_{12}:T_{12}): S_1=e_1,\ \cdots\ ,m(x_{n1}:T_{n1},x_{n2}:T_{n2}): S_n=e_n\}~\textsf{safe} }
% \]

% The first premise prevents functions with the same parameter types.
% The second premise prevents ambiguous call errors for functions with different parameter types,
% and it has three subcases:

% \[
% \begin{array}{ll}
% (1) &
% \inferrule
% { T_{i1}<:T_{j1} \quad T_{i2}<:T_{j2} }
% { (T_{i1},T_{i2})~\textsf{meet}~(T_{j1},T_{j2})~\textsf{wrt}~\{(T_{11},T_{12}),...,(T_{n1},T_{n2})\} }
% \\
% (2) &
% \inferrule
% { T_{j1}<:T_{i1} \quad T_{j2}<:T_{i2} }
% { (T_{i1},T_{i2})~\textsf{meet}~(T_{j1},T_{j2})~\textsf{wrt}~\{(T_{11},T_{12}),...,(T_{n1},T_{n2})\} }
% \end{array}
% \]

% \textbf{Write the 3rd subcase} possibly using the following paritial function:

% \[\textsf{glb}(T,S)=\begin{cases}T&\text{if}~T<:S\\S&\text{if}~S<:T\end{cases}\]

% (\textit{Hint: consider the functions and your answer of (a).})

% \end{itemize}

\end{enumerate}
