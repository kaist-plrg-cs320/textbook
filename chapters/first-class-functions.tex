\setchapterpreamble[u]{\margintoc}
\chapter{First-Class Functions}
\labch{first-class-functions}

The article defines FAE by adding \term{first-class functions} to AE. First-class
functions are values: arguments for function calls and the return values of
functions. Functions taking functions as arguments or returning functions are not
first-order; they are \term{higher-order}. In most contexts, the terms
'first-class functions' and 'higher-order functions' are interchangeable.

\section{Syntax}

The following is the abstract syntax of FAE:

\[
\begin{array}{lrcl}
\text{Integer} & n & \in & \mathbb{Z} \\
\text{Variable} & x & \in & \textit{Id} \\
\text{Expression} & e & ::= & n \\
&& | & e + e \\
&& | & e - e \\
&& | & x \\
&& | & \lambda x.e \\
&& | & e\ e \\
\text{Value} & v & ::= & n \\
&& | & \langle \lambda x.e,\sigma \rangle \\
\text{Environment} & \sigma & \in & \textit{Id}\hookrightarrow\text{Value}
\end{array}
\]

An expression of FAE is an expression of AE, variable \(x\), \term{lambda
abstraction} \(\lambda x.e\), or \term{function application} \(e\ e\). A lambda
abstraction creates an anonymous function: \(\lambda x.e\) denotes a function
whose parameter and body are \(x\) and \(e\) respectively. \(x\) is a binding
occurrence. In function application \(e_1\ e_2\), \(e_1\) denotes a function, and
\(e_2\) denotes an argument. Evaluating a function application equals applying
its function to its argument.

A value of FAE is either an integer or a \term{closure}. A closure, which is a
function as a value, is the pair of a lambda abstraction and the environment of
when the lambda abstraction defines the function. Lambda abstractions may have
free identifiers, but the environments of closures store values denoted by the
free identifiers if a program is correct. Consider the following expression:

\[(\lambda x.\lambda y.x + y)\ 1\ 2\]

\(\lambda y.x+y\) contains free identifier \(x\). At run time, when the lambda
abstraction is evaluated, the environment of the moment knows that \(x\) refers
to \(1\). Hence, the environment of a closure defined by \(\lambda y.x+y\) also
knows that \(x\) refers to \(1\). The evaluation of the body of a closure happens
under the environment of the closure. \(x+y\) does not result in an error. The
next section shows the formal semantics of FAE and clarifies how lambda
abstractions and function applications operate.

An environment of FAE is a partial function from identifiers to values. Note that
values are not only integers but also closures.

\section{Semantics}

The semantics of FAE is a relation over environments, expressions, and values, as
that of VAE is.


\[\Rightarrow\subseteq\text{Environment}\times\text{Expression}\times\text{Value}\]

\(\sigma\vdash e\Rightarrow v\) implies that evaluating \(e\) under \(\sigma\)
yields \(v\).

The rules for integers, sums, differences, and variables equal those of VAE.

\[
\sigma\vdash n\Rightarrow n
\]

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow n_1 \\ \sigma\vdash e_2\Rightarrow n_2 }
{ \sigma\vdash e_1+e_2\Rightarrow n_1+n_2 }
\]

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow n_1 \\ \sigma\vdash e_2\Rightarrow n_2 }
{ \sigma\vdash e_1-e_2\Rightarrow n_1-n_2 }
\]

\[
\inferrule
{ x\in\mathit{Domain}(\sigma) }
{ \sigma\vdash x\Rightarrow \sigma(x)}
\]

A lambda abstraction creates a closure containing the current environment.

\[
\sigma\vdash \lambda x.e\Rightarrow \langle\lambda x.e,\sigma\rangle
\]

A function application evaluates its both subexpressions. Then, it evaluates the
body of the closure under an environment obtained by adding the value of the
argument to the environment of the closure.

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow\langle\lambda x.e,\sigma'\rangle \\
  \sigma\vdash e_2\Rightarrow v' \\
  \sigma'\lbrack x\mapsto v'\rbrack\vdash e\Rightarrow v }
{ \sigma\vdash e_1\ e_2\Rightarrow v }
\]

The following proof tree proves that \((\lambda x.\lambda y.x+y)\ 1\ 2\) yields
\(3\).

\[
\inferrule
{
  \inferrule
  {
    \emptyset\vdash\lambda x.\lambda y.x+y\Rightarrow\langle\lambda x.\lambda
y.x+y,\emptyset\rangle \\
    \emptyset\vdash 1\Rightarrow 1 \\
    \lbrack x\mapsto 1\rbrack\vdash \lambda y.x+y\Rightarrow\langle\lambda
y.x+y,\lbrack x\mapsto 1\rbrack\rangle
  }
  { \emptyset\vdash(\lambda x.\lambda y.x+y)\ 1\Rightarrow\langle\lambda
y.x+y,\lbrack x\mapsto 1\rbrack\rangle } \\
  \emptyset\vdash2\Rightarrow 2 \\
  \inferrule
  {
    \inferrule
    { x\in\mathit{Domain}(\lbrack x\mapsto 1,y\mapsto 2\rbrack) }
    { \lbrack x\mapsto 1,y\mapsto 2\rbrack\vdash x\Rightarrow 1 } \\
    \inferrule
    { y\in\mathit{Domain}(\lbrack x\mapsto 1,y\mapsto 2\rbrack) }
    { \lbrack x\mapsto 1,y\mapsto 2\rbrack\vdash y\Rightarrow 2 }
  }
  { \lbrack x\mapsto 1,y\mapsto 2\rbrack\vdash x+y\Rightarrow 3 }
}
{ \emptyset\vdash(\lambda x.\lambda y.x+y)\ 1\ 2\Rightarrow 3 }
\]

\section{Implementing an Interpreter}

The following Scala code implements the abstract syntax and environments of FAE:

\begin{verbatim}
sealed trait Expr
case class Num(n: Int) extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Sub(l: Expr, r: Expr) extends Expr
case class Id(x: String) extends Expr
case class Fun(x: String, b: Expr) extends Expr
case class App(f: Expr, a: Expr) extends Expr

sealed trait Value
case class NumV(n: Int) extends Value
case class CloV(p: String, b: Expr, e: Env) extends Value

type Env = Map[String, Value]
\end{verbatim}

Since a value is either an integer or a closure, \verb!Value!, instead of
\verb!Int!, denotes the type of values. The \verb!NumV! type corresponds to
integers; the \verb!CloV! type corresponds to closures. The type of environments
is a map from \verb!String! to \verb!Value!, but not \verb!Int!.

\begin{verbatim}
def lookup(x: String, env: Env): Value =
  env.getOrElse(x, throw new Exception)
\end{verbatim}

The \verb!lookup! function finds a value denoted by an identifier from an
environment.

\begin{verbatim}
def interp(e: Expr, env: Env): Value = e match {
  case Num(n) => NumV(n)
  case Add(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n + m)
  case Sub(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n - m)
  case Id(x) => lookup(x, env)
  case Fun(x, b) => CloV(x, b, env)
  case App(f, a) =>
    val CloV(x, b, fEnv) = interp(f, env)
    interp(b, fEnv + (x -> interp(a, env)))
}
\end{verbatim}

The \verb!Num! case creates a \verb!NumV! instance. Both \verb!Add! and
\verb!Sub! cases check whether values are integral, respectively calculate the
sum or the difference, and create \verb!NumV! instances. The \verb!Id! case
equals that of VAE. The \verb!Fun! case constructs a \verb!CloV! instance. The
\verb!App! case obtains a closure by evaluating the function, calculates the
argument, adds the argument to the environment of the closure, and evaluates the
body of the closure.

Passing \((\lambda x.\lambda y.x+y)\ 1\ 2\) and the empty environment to
\verb!interp! results in \verb!NumV(3)!.

\begin{verbatim}
// lambda x.lambda y.(x + y) 1 2
interp(
  App(
    App(
      Fun("x", Fun("y",
        Add(Id("x"), Id("y")))),
      Num(1)
    ),
    Num(2)
  ),
  Map.empty
)
// NumV(3)
\end{verbatim}

\section{Type Errors}

Free identifiers are the only reasons for run-time errors of VAE and F1VAE. On
the other hand, FAE expressions can result in run-time errors even though they do
not contain any free identifiers.

\[1 + \lambda x.x\]

The two premises of the inference rule for sums require both operands to denote
integers. The right operand of the above expression denotes a closure and thus
does not satisfy the premise. The expression does not yield any values;
interpreting the expressions causes a run-time error.

\[1\ 1\]

One of the premises of the inference rule for function applications enforces the
former subexpression of a function application to denote a closure. However,
\(1\) yields an integer, but not a closure. Like the previous one, the expression
does not yield any values and results in a run-time error.

Both expressions cause \term{type errors}. In the former, an expression denoting
a function occurs where an integer must come. In the latter, an expression
denoting an integer occurs where a function must come. Errors such as those from
the examples are type errors since their reasons are expressions of unexpected
types.

Syntactic methods can hardly prevent type errors. Such solutions restrict
languages too much. Consider restricting operands of sums and differences to only
integers rather than arbitrary expressions. Then, the syntax rejects many useful
or trivially correct expressions including \(1+1+1\). In the same manner,
restricting the first expressions of function applications to lambda abstractions
refuses \((\lambda x.\lambda y.x+y)\ 1\ 2\) and many others.

A \term{type system} is the most popular method to avoid type errors before
executions. Type systems prove that particular programs never cause type errors
at run time without executing them. Since they are the semantics of programs
before run time, \term{static semantics} is another name of them. To distinguish
'semantics,' whom the previous articles and the current article focus on, from
static semantics, \term{dynamic semantics} means 'semantics,' which defines the
run-time behaviors of programs. Type systems are out of the scope of the article,
and later articles discuss type systems in detail.

\section{Encoding VAE with FAE}

If one can transform every code of a language into code of another language
without changing its meaning, the latter can express everything the former
expresses. \term{Encoding} is rewriting a code written in a language with another
language.

VAE is encodable with FAE; FAE expresses everything VAE expresses; FAE is at
least as \term{expressive} as VAE. Precisely, FAE is more expressive than VAE.
The below \(\mathit{encode}\) function takes an expression of VAE as an argument
and returns an expression of FAE; it encodes VAE with FAE.

\[
\begin{array}{l}
\mathit{encode}(n)=n \\
\mathit{encode}(e_1+e_2)=\mathit{encode}(e_1)+\mathit{encode}(e_2) \\
\mathit{encode}(e_1-e_2)=\mathit{encode}(e_1)-\mathit{encode}(e_2) \\
\mathit{encode}(\textsf{val}\ x = e_1\ \textsf{in}\ e_2)=
\lambda x.\mathit{encode}(e_2)\ \mathit{encode}(e_1) \\
\mathit{encode}(x)=x
\end{array}
\]

Most cases are straightforward. The most important case is an expression
declaring a local variable. Hereafter, examples may declare local variables for
brevity even though they are written in languages without the feature. It is safe
to transform them to use lambda expressions and function applications.

Encoding complex languages with simple, but expressive languages can be
understood as desugaring code written in a language with various syntactic sugar.
Syntactic sugar provides convenience for programmers; desugaring provides
convenience for language designers: it simplifies implementations of interpreters
and compilers. Researchers often encode languages with others as well: encoding
makes proofs easier or allows borrowing already proven facts.

\term{Structural induction} proves the correctness of encodings. Such proofs are
beyond the scope of the article and the course.

\section{Exercises}

\begin{enumerate}
\item Given the following expression:

\begin{verbatim}
val x = 5
in  val f = lambda y. y + x
    in (lambda g.f (g 1)) (lambda x.x)
\end{verbatim}

Describe a trace of the evalaution in terms of arguments to an \texttt{interp}
function for every call. (There will be 16 calls.) The \texttt{interp} function
takes two arguments --- an expression and a
   deferred substitution --- so show both for each call.  For number,
   variable, and \texttt{fun} expressions, show the result value, which
   is immediate. Use the back of the exam for additional space, and
   use the following abbreviations and possibly more abbreviations
 to save time:

\begin{center}
\begin{tabular}{lcl}
$E_0$ & = & the whole expression \\
$E_1$ & = & \texttt{lambda y. y + x} \\
$E_2$ & = & \texttt{lambda g.f (g 1)} \\
$E_3$ & = & \texttt{lambda x.x} \\
$E_4$ & = & \texttt{val f = $E_1$ in $E_2$ $E_3$}
\end{tabular}
\end{center}

\item The following code is an implementation of the interpreter for AEF.
All the missing definitions are exactly the same as the ones for FAE.

\begin{verbatim}
def interp(e: Expr, env: Env): Value = e match {
  case Num(n) => NumV(n)
  case Add(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n + m)
  case Sub(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n - m)
  case Id(x) => lookup(x, env)
  case Fun(x, b) => CloV(x, b, env)
  case App(f, a) =>
    val CloV(x, b, fEnv) = interp(f, env)
    interp(b, __________ + (x -> interp(a, env)))
}
\end{verbatim}

Describe the semantics of the \texttt{App} case in AEF in prose
when we use each of the following for the blank above:
\begin{itemize}
  \item[a)] \texttt{env}
  \item[b)] \texttt{Map()}
  \item[c)] \texttt{fEnv}
\end{itemize}

\item Consider the following expression:
\[
\begin{array}{l@{~}l}
\textsf{val}\ \term{fac} = \lambda m. &
\textsf{val}\ \term{facX} = \lambda \term{facX}.
\lambda m. \textsf{if0}\ m\ 1\ (n * ((\term{facX}\ \term{facX})\ (x - 1)))\\
&\textsf{in}\ ((\term{facX}\ \term{facX})\ m)\\
\textsf{in}\ (\term{fac}\ m)
\end{array}
\]

\begin{itemize}
\item[a)] Draw arrows on the above expression from each bound variable to its binding occurrence.
\item[b)] Draw dotted arrows on the above expression from each shadowing variable to its shadowed variable.
\end{itemize}

\item Consider the following language $e$:
\[
\begin{array}{rll}
e ::= & n\\
\mid& x\\
\mid& \verb!{fun {! x\ \cdots\ x\verb+} +e\verb+}+\\
\mid& \verb!{! e\ \cdots\ e\verb+}+\\
\end{array}
\]
where $n$ denotes a number and a value of the language is either a number or a closure.
\begin{itemize}
  \item[a)] Write the operational semantics of the form \fbox{$\sigma\vdash e \Rightarrow v$} for the expressions.
  \item[b)] Write the evaluation derivation of the following expression:

\derive
{\hspace*{\textwidth}}
{\emptyset\vdash \{\{\texttt{fun}\ \{f\ m\}\ \{f\ m\}\}\
\{\texttt{fun}\ \{x\}\ x\}\ 8\} \Rightarrow~~~~~~~~}
\end{itemize}

\item Rewrite the following expressions without using \textsf{val}.
You should not ``evaluate'' them.

\begin{itemize}
\item[a)] \(\textsf{val}\ x = \lambda n. 8 + n\ \textsf{in}\ \lambda n. (x\ (10 - n))\)
\item[b)] \(\textsf{val}\ \term{fac} = (\term{mk-rec}\ (\lambda \term{fac}.\ \lambda n.\ (\textsf{if0}\ n\ 1 (n * (\term{fac}\ (n - 1))))))\ \textsf{in}\ (\term{fac}\ 10)\)
\item[c)] \(\lambda\ \term{body-proc}.\
\textsf{val}\ \term{fX} = \lambda\ \term{fX}.\
(\textsf{val}\ f = \lambda\ x.\ ((\term{fX}\ \term{fX})\ x)\
\textsf{in}\ (\term{body-proc}\ f))\
\textsf{in}\ (\term{fX}\ \term{fX}) \)
\end{itemize}

\item Write the operational semantics of the form
\fbox{$\sigma \vdash e \Rightarrow v$} for a function expression
$\lambda x. e$, when the semantics of the function expression
is as follows:
\begin{enumerate}
\item Check whether the body of the function expression $e$ contains
any free identifiers.
\item If it does not contain any free identifiers, its value is a pair
  of the function expression and the environment.
\item Otherwise, the value of the expression is a special value $\uparrow$.
\end{enumerate}
You may want to use the function \textit{fv} which takes an
expression and returns a set of free identifiers in the expression.

\item Consider the following language $e$:
\begin{equation*}
\begin{array}{llll}
e & ::= 
& x \\
& \mid & \lambda x.e \\
& \mid & e\ e \\
& \mid & \{f\ e,\ \cdots,\ f\ e\}\\
& \mid & e.f \\
& \mid & e; e \\
& \mid & (e)
\end{array}
\end{equation*}
where a value of the language is either a record $\rho$
or a closure $\langle\lambda x. e,\sigma\rangle$, and
an environment maps names to values:
\begin{equation*}
\begin{gathered}
\begin{array}{llll}
x & \in & \embox{Var}\\
f & \in & \embox{Field}\\
\sigma & \in & \embox{Env} & = \embox{Var} \finto \embox{Value}\\
\langle\lambda x.e, \sigma\rangle & \in & \embox{Closure} & = \embox{Expr} \times \embox{Env}\\
\rho & \in & \embox{Record} & = \embox{Field} \finto \embox{Value} \\
v & \in & \embox{Value} & = \embox{Closure} + \embox{Record}\\
\end{array}
\end{gathered}
\end{equation*}

The semantics of some constructs are as follows:
\begin{itemize}
  \item The value of a record $\{f_1\ e_1,\ \cdots,\ f_k\ e_k\}$
    is a finite map $\rho$,
which maps $f_i \in \{f_1\ \cdots,\ f_k\}$
to the value $v_i$ evaluated from the expression $e_i$.
  \item The value of $e.f$ is the value of the field $f$ in the record $e$.
\item The semantics of $e_1; e_2$ is to evaluate $e_1$ first and
evaluate $e_2$ next, which is the value of $e_1; e_2$.
\item The value of $(e)$ is the value of $e$.
\end{itemize}

Write the operational semantics of the form
$\boxed{\sigma \vdash e \Rightarrow v}$

\item Consider the following language $e$:
\[
\begin{array}{rll}
e ::= & n\\
\mid& \verb!{pair ! e\ e\verb+}+\\
\mid& \verb!{first ! e\verb+}+\\
\mid& \verb!{second ! e\verb+}+\\
\end{array}
\]
where $n$ denotes a number and a value of the language is either a number or a pair of two values.
\begin{itemize}
  \item[a)] Write the grammar of the value $v$ and
 the operational semantics of the form \fbox{$\vdash e \Rightarrow v$} for the expressions.
  \item[b)] Write the evaluation derivation of the following expressions:

\hspace*{-5em}
 \derive
{\hspace*{\textwidth}}
{\vdash
 \{\texttt{second}\ \{\texttt{pair}\ 8\ \{
 \texttt{first}\ \{\texttt{pair}\ 320\ 42\}\}\}\}
 \Rightarrow~~~~~~~~}
\end{itemize}

\item Consider the following language $e$:
\[
\begin{array}{rll}
e ::= & n & \texttt{Num}\\
\mid& \verb!{+ ! e\ e\verb+}+ & \texttt{Add}\\
\mid& \verb!{- ! e\ e\verb+}+ & \texttt{Sub}\\
\mid& \verb!{with {! x\ e\verb+} +e\verb+}+ & \texttt{With}\\
\mid& x & \texttt{Id}\\
\mid& \verb!{fun {! x\verb+} +e\verb+}+ & \texttt{Fun}\\
\mid& \verb!{!e\ e\verb+}+ & \texttt{App}\\
\end{array}
\]
where evaluation of $e$ results in either a number $n$ or a closure $\verb!{fun {!x\verb!} !e\verb!}!$.

Consider the following implementation of $e$:
\begin{verbatim}
trait FWAES
trait FWAESValue extends FWAES                                       // v ::= n | {fun {x} e}
case class Num(num: Int) extends FWAES with FWAESValue               // e ::= n
case class Add(left: FWAES, right: FWAES) extends FWAES              //     | {+ e e}
case class Sub(left: FWAES, right: FWAES) extends FWAES              //     | {- e e}
case class With(x: String, init: FWAES, body: FWAES) extends FWAES   //     | {with {x e} e}
case class Id(name: String) extends FWAES                            //     | x
case class Fun(x: String, body: FWAES) extends FWAES with FWAESValue //     | {fun {x} e}
case class App(fun: FWAES, arg: FWAES) extends FWAES                 //     | {e e}

// subst : (FWAES, String, FWAESValue) => FWAES
def subst(fwaes: FWAES, x: String, v: FWAESValue): FWAES = fwaes match {
  case Num(n) => fwaes
  case Add(l, r) => Add(subst(l, x, v), subst(r, x, v))
  case Sub(l, r) => Sub(subst(l, x, v), subst(r, x, v))
  case With(y, i, b) => With(y, subst(i, x, v), if (y == x) b else subst(b, x, v))
  case Id(name) => if (name == x) v else fwaes
  case Fun(y, b) => Fun(y, if (y == x) b else subst(b, x, v))
  case App(f, a) => App(subst(f, x, v), subst(a, x, v))
}

// interp : FWAES => FWAESValue
def interp(fwaes: FWAES): FWAESValue = fwaes match {
  case Num(n) => Num(n)
  case Add(l, r) => numAdd(interp(l), interp(r))
  case Sub(l, r) => numSub(interp(l), interp(r))
  case With(x, i, b) => interp(subst(b, x, interp(i)))
  case Id(x) => error(s"free identifier: $x")
  case Fun(x, b) => Fun(x, b)
  case App(f, a) => interp(f) match {
    case Fun(x, b) => interp(subst(b, x, interp(a)))
    case fv => error(s"not a closure: $fv")
  }
}
\end{verbatim}

\begin{itemize}
  \item[a)]
Write the operational semantics of the above implementation 
of the form \fbox{$\vdash e \Rightarrow v$}
where $e[x/v]$ denotes \verb!subst(e, x, v)! and a value $v$ is either a number $n$ or
a closure $\verb!{fun {!x\verb!} !e\verb!}!$.

\begin{itemize}
  \item $e \equiv n$
  \item $e \equiv \verb!{+ !e\ e\verb!}!$
  \item $e \equiv \verb!{with {! x\ e\verb+} +e\verb+}+$
  \item $e \equiv \verb!{fun {!x\verb!} !e\verb!}!$
  \item $e \equiv \verb!{!e\ e\verb!}!$
\end{itemize}

  \item[b)] Write the definition of the substitution $e[x/v]$ denoting \verb!subst(e,x,v)!
of the form \fbox{$e[x/v] \leadsto e$}:
\begin{itemize}
  \item $e \equiv n$
%{\Large $n[x/v] \leadsto n$}
  \item $e \equiv \verb!{+ ! e\ e\verb+}+$
  \item $e \equiv \verb!{with {! x\ e\verb+} +e\verb+}+$
  \item $e \equiv x$
  \item $e \equiv \verb!{fun {!x\verb!} !e\verb!}!$
  \item $e \equiv \verb!{!e\ e\verb!}!$
\end{itemize}

  \item[c)] Consider the following expression:

\begin{verbatim}
{with {z {fun {x} {- x y}}}
      {with {y 10}
            {z 32}}}
\end{verbatim}

\begin{itemize}
\item What is the result of evaluating the expression under the empty environment?
\item What is the result of evaluating the expression under the empty environment in FWAE?
\item Why are the results different?
\end{itemize}

%\verb!subst(With("y", Num(10), Id("z")), "z", Fun("x", Add(Id("x"), Id("y"))))!
%$[z/\verb!{fun {!z\verb!} {+ !x\ y\verb!}}!]\verb!{with {!y\ 10\verb!} !z\verb!}!$

\end{itemize}

\end{enumerate}
