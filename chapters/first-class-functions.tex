\setchapterpreamble[u]{\margintoc}
\chapter{First-Class Functions}
\labch{first-class-functions}

The article defines FAE by adding \term{first-class functions} to AE. First-class
functions are values: arguments for function calls and the return values of
functions. Functions taking functions as arguments or returning functions are not
first-order; they are \term{higher-order}. In most contexts, the terms
'first-class functions' and 'higher-order functions' are interchangeable.

\section{Syntax}

The following is the abstract syntax of FAE:

\[
\begin{array}{lrcl}
\text{Integer} & n & \in & \mathbb{Z} \\
\text{Variable} & x & \in & \textit{Id} \\
\text{Expression} & e & ::= & n \\
&& | & e + e \\
&& | & e - e \\
&& | & x \\
&& | & \lambda x.e \\
&& | & e\ e \\
\text{Value} & v & ::= & n \\
&& | & \langle \lambda x.e,\sigma \rangle \\
\text{Environment} & \sigma & \in & \textit{Id}\hookrightarrow\text{Value}
\end{array}
\]

An expression of FAE is an expression of AE, variable \(x\), \term{lambda
abstraction} \(\lambda x.e\), or \term{function application} \(e\ e\). A lambda
abstraction creates an anonymous function: \(\lambda x.e\) denotes a function
whose parameter and body are \(x\) and \(e\) respectively. \(x\) is a binding
occurrence. In function application \(e_1\ e_2\), \(e_1\) denotes a function, and
\(e_2\) denotes an argument. Evaluating a function application equals applying
its function to its argument.

A value of FAE is either an integer or a \term{closure}. A closure, which is a
function as a value, is the pair of a lambda abstraction and the environment of
when the lambda abstraction defines the function. Lambda abstractions may have
free identifiers, but the environments of closures store values denoted by the
free identifiers if a program is correct. Consider the following expression:

\[(\lambda x.\lambda y.x + y)\ 1\ 2\]

\(\lambda y.x+y\) contains free identifier \(x\). At run time, when the lambda
abstraction is evaluated, the environment of the moment knows that \(x\) refers
to \(1\). Hence, the environment of a closure defined by \(\lambda y.x+y\) also
knows that \(x\) refers to \(1\). The evaluation of the body of a closure happens
under the environment of the closure. \(x+y\) does not result in an error. The
next section shows the formal semantics of FAE and clarifies how lambda
abstractions and function applications operate.

An environment of FAE is a partial function from identifiers to values. Note that
values are not only integers but also closures.

\section{Semantics}

The semantics of FAE is a relation over environments, expressions, and values, as
that of VAE is.


\[\Rightarrow\subseteq\text{Environment}\times\text{Expression}\times\text{Value}\]

\(\sigma\vdash e\Rightarrow v\) implies that evaluating \(e\) under \(\sigma\)
yields \(v\).

The rules for integers, sums, differences, and variables equal those of VAE.

\[
\sigma\vdash n\Rightarrow n
\]

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow n_1 \\ \sigma\vdash e_2\Rightarrow n_2 }
{ \sigma\vdash e_1+e_2\Rightarrow n_1+n_2 }
\]

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow n_1 \\ \sigma\vdash e_2\Rightarrow n_2 }
{ \sigma\vdash e_1-e_2\Rightarrow n_1-n_2 }
\]

\[
\inferrule
{ x\in\mathit{Domain}(\sigma) }
{ \sigma\vdash x\Rightarrow \sigma(x)}
\]

A lambda abstraction creates a closure containing the current environment.

\[
\sigma\vdash \lambda x.e\Rightarrow \langle\lambda x.e,\sigma\rangle
\]

A function application evaluates its both subexpressions. Then, it evaluates the
body of the closure under an environment obtained by adding the value of the
argument to the environment of the closure.

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow\langle\lambda x.e,\sigma'\rangle \\
  \sigma\vdash e_2\Rightarrow v' \\
  \sigma'\lbrack x\mapsto v'\rbrack\vdash e\Rightarrow v }
{ \sigma\vdash e_1\ e_2\Rightarrow v }
\]

The following proof tree proves that \((\lambda x.\lambda y.x+y)\ 1\ 2\) yields
\(3\).

\[
\inferrule
{
  \inferrule
  {
    \emptyset\vdash\lambda x.\lambda y.x+y\Rightarrow\langle\lambda x.\lambda
y.x+y,\emptyset\rangle \\
    \emptyset\vdash 1\Rightarrow 1 \\
    \lbrack x\mapsto 1\rbrack\vdash \lambda y.x+y\Rightarrow\langle\lambda
y.x+y,\lbrack x\mapsto 1\rbrack\rangle
  }
  { \emptyset\vdash(\lambda x.\lambda y.x+y)\ 1\Rightarrow\langle\lambda
y.x+y,\lbrack x\mapsto 1\rbrack\rangle } \\
  \emptyset\vdash2\Rightarrow 2 \\
  \inferrule
  {
    \inferrule
    { x\in\mathit{Domain}(\lbrack x\mapsto 1,y\mapsto 2\rbrack) }
    { \lbrack x\mapsto 1,y\mapsto 2\rbrack\vdash x\Rightarrow 1 } \\
    \inferrule
    { y\in\mathit{Domain}(\lbrack x\mapsto 1,y\mapsto 2\rbrack) }
    { \lbrack x\mapsto 1,y\mapsto 2\rbrack\vdash y\Rightarrow 2 }
  }
  { \lbrack x\mapsto 1,y\mapsto 2\rbrack\vdash x+y\Rightarrow 3 }
}
{ \emptyset\vdash(\lambda x.\lambda y.x+y)\ 1\ 2\Rightarrow 3 }
\]

\section{Implementing an Interpreter}

The following Scala code implements the abstract syntax and environments of FAE:

\begin{verbatim}
sealed trait Expr
case class Num(n: Int) extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Sub(l: Expr, r: Expr) extends Expr
case class Id(x: String) extends Expr
case class Fun(x: String, b: Expr) extends Expr
case class App(f: Expr, a: Expr) extends Expr

sealed trait Value
case class NumV(n: Int) extends Value
case class CloV(p: String, b: Expr, e: Env) extends Value

type Env = Map[String, Value]
\end{verbatim}

Since a value is either an integer or a closure, \verb!Value!, instead of
\verb!Int!, denotes the type of values. The \verb!NumV! type corresponds to
integers; the \verb!CloV! type corresponds to closures. The type of environments
is a map from \verb!String! to \verb!Value!, but not \verb!Int!.

\begin{verbatim}
def lookup(x: String, env: Env): Value =
  env.getOrElse(x, throw new Exception)
\end{verbatim}

The \verb!lookup! function finds a value denoted by an identifier from an
environment.

\begin{verbatim}
def interp(e: Expr, env: Env): Value = e match {
  case Num(n) => NumV(n)
  case Add(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n + m)
  case Sub(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n - m)
  case Id(x) => lookup(x, env)
  case Fun(x, b) => CloV(x, b, env)
  case App(f, a) =>
    val CloV(x, b, fEnv) = interp(f, env)
    interp(b, fEnv + (x -> interp(a, env)))
}
\end{verbatim}

The \verb!Num! case creates a \verb!NumV! instance. Both \verb!Add! and
\verb!Sub! cases check whether values are integral, respectively calculate the
sum or the difference, and create \verb!NumV! instances. The \verb!Id! case
equals that of VAE. The \verb!Fun! case constructs a \verb!CloV! instance. The
\verb!App! case obtains a closure by evaluating the function, calculates the
argument, adds the argument to the environment of the closure, and evaluates the
body of the closure.

Passing \((\lambda x.\lambda y.x+y)\ 1\ 2\) and the empty environment to
\verb!interp! results in \verb!NumV(3)!.

\begin{verbatim}
// lambda x.lambda y.(x + y) 1 2
interp(
  App(
    App(
      Fun("x", Fun("y",
        Add(Id("x"), Id("y")))),
      Num(1)
    ),
    Num(2)
  ),
  Map.empty
)
// NumV(3)
\end{verbatim}

\section{Type Errors}

Free identifiers are the only reasons for run-time errors of VAE and F1VAE. On
the other hand, FAE expressions can result in run-time errors even though they do
not contain any free identifiers.

\[1 + \lambda x.x\]

The two premises of the inference rule for sums require both operands to denote
integers. The right operand of the above expression denotes a closure and thus
does not satisfy the premise. The expression does not yield any values;
interpreting the expressions causes a run-time error.

\[1\ 1\]

One of the premises of the inference rule for function applications enforces the
former subexpression of a function application to denote a closure. However,
\(1\) yields an integer, but not a closure. Like the previous one, the expression
does not yield any values and results in a run-time error.

Both expressions cause \term{type errors}. In the former, an expression denoting
a function occurs where an integer must come. In the latter, an expression
denoting an integer occurs where a function must come. Errors such as those from
the examples are type errors since their reasons are expressions of unexpected
types.

Syntactic methods can hardly prevent type errors. Such solutions restrict
languages too much. Consider restricting operands of sums and differences to only
integers rather than arbitrary expressions. Then, the syntax rejects many useful
or trivially correct expressions including \(1+1+1\). In the same manner,
restricting the first expressions of function applications to lambda abstractions
refuses \((\lambda x.\lambda y.x+y)\ 1\ 2\) and many others.

A \term{type system} is the most popular method to avoid type errors before
executions. Type systems prove that particular programs never cause type errors
at run time without executing them. Since they are the semantics of programs
before run time, \term{static semantics} is another name of them. To distinguish
'semantics,' whom the previous articles and the current article focus on, from
static semantics, \term{dynamic semantics} means 'semantics,' which defines the
run-time behaviors of programs. Type systems are out of the scope of the article,
and later articles discuss type systems in detail.

\section{Encoding VAE with FAE}

If one can transform every code of a language into code of another language
without changing its meaning, the latter can express everything the former
expresses. \term{Encoding} is rewriting a code written in a language with another
language.

VAE is encodable with FAE; FAE expresses everything VAE expresses; FAE is at
least as \term{expressive} as VAE. Precisely, FAE is more expressive than VAE.
The below \(\mathit{encode}\) function takes an expression of VAE as an argument
and returns an expression of FAE; it encodes VAE with FAE.

\[
\begin{array}{l}
\mathit{encode}(n)=n \\
\mathit{encode}(e_1+e_2)=\mathit{encode}(e_1)+\mathit{encode}(e_2) \\
\mathit{encode}(e_1-e_2)=\mathit{encode}(e_1)-\mathit{encode}(e_2) \\
\mathit{encode}(\textsf{val}\ x = e_1\ \textsf{in}\ e_2)=
\lambda x.\mathit{encode}(e_2)\ \mathit{encode}(e_1) \\
\mathit{encode}(x)=x
\end{array}
\]

Most cases are straightforward. The most important case is an expression
declaring a local variable. Hereafter, examples may declare local variables for
brevity even though they are written in languages without the feature. It is safe
to transform them to use lambda expressions and function applications.

Encoding complex languages with simple, but expressive languages can be
understood as desugaring code written in a language with various syntactic sugar.
Syntactic sugar provides convenience for programmers; desugaring provides
convenience for language designers: it simplifies implementations of interpreters
and compilers. Researchers often encode languages with others as well: encoding
makes proofs easier or allows borrowing already proven facts.

\term{Structural induction} proves the correctness of encodings. Such proofs are
beyond the scope of the article and the course.

\section{Exercises}

\begin{enumerate}
\item Given the following expression:

\[
\ebind{\cx}{5}{
    \ebind{\code{f}}{\efun{\cy}{\eadd{\cy}{\cx}}}{
        \eapp{(\efun{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}})}
        {(\efun{\cx}{\cx})}
    }
}
\]
Describe a trace of the evalaution in terms of arguments to an \texttt{interp}
function for every call. (There will be 16 calls.) The \texttt{interp} function
takes two arguments --- an expression and a
   deferred substitution --- so show both for each call.  For number,
   variable, and \texttt{fun} expressions, show the result value, which
   is immediate. Use the back of the exam for additional space, and
   use the following abbreviations and possibly more abbreviations
 to save time:

\begin{center}
\begin{tabular}{lcl}
$E_0$ & = & the whole expression \\
$E_1$ & = & $\efun{\cy}{\eadd{\cy}{\cx}}$ \\
$E_2$ & = & $\efun{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}}$ \\
$E_3$ & = & $\efun{\cx}{\cx}$ \\
$E_4$ & = & $\ebind{\code{f}}{E_1}{\eapp{E_2}{E_3}}$
\end{tabular}
\end{center}

\item In this exercise, we examine differences of semantics by changing scope.
The following code is an implementation of the interpreter for new language, AEF.
All the missing definitions are exactly the same as the ones for FAE.

\begin{verbatim}
def interp(e: Expr, env: Env): Value = e match {
  case Num(n) => NumV(n)
  case Add(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n + m)
  case Sub(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n - m)
  case Id(x) => lookup(x, env)
  case Fun(x, b) => CloV(x, b, env)
  case App(f, a) =>
    val CloV(x, b, fEnv) = interp(f, env)
    interp(b, __________ + (x -> interp(a, env)))
}
\end{verbatim}

Describe the semantics of the \texttt{App} case in AEF in prose
when we use each of the following for the blank above:
\begin{itemize}
  \item[a)] \texttt{env}
  \item[b)] \texttt{Map()}
  \item[c)] \texttt{fEnv}
\end{itemize}

\item In this exercise, we extend FAE to support multiple parameters. Consider the following language, MFAE:
\[
\begin{array}{lrll}
\text{Expression}& e ::= & n\\
&\mid& x\\
&\mid& \lambda x\ \cdots\ x. e\\
&\mid& e\ (e,\ \cdots ,\ e)\\
\text{Value}& v ::= & n \\
&\mid& \langle \lambda x \cdots\ x.e,\sigma \rangle \\
\end{array}
\]
where definition of $n,\ x,\ \sigma$ is same as FAE.
The semantics of some constructs are as follows:
\begin{itemize}
  \item Evaluating $\lambda x_1\ \cdots\ x_n. e$ under $\sigma$
      yields a closure $\langle \lambda x_1 \cdots\ x_n.e,\sigma \rangle$.
  \item If :
    \begin{itemize}
    \item Evaluating $e_0$ under $\sigma$ yields a closure $\langle \lambda x_1 \cdots\ x_n.e,\sigma' \rangle$
    \item Evaluating $e_i$ under $\sigma'$ yields $v_i$ for each $1 \leq i \leq n$
    \item Evaluating $e$ under $\sigma'[x_1 \mapsto v_1, \cdots, x_n \mapsto v_n]$ yields $v$
    \end{itemize}
\item[] then evaluating $e_0\ (e_1,\ \cdots ,\ e_n)$ under $\sigma$ yields $v$.
\end{itemize}

\begin{itemize}
  \item[a)] Write the operational semantics of the form \fbox{$\sigma\vdash e \Rightarrow v$} for the expressions.
  \item[b)] Write the evaluation derivation of the following expression:

\derive
{\hspace*{\textwidth}}
{\emptyset\vdash ($\lambda \code{f}\ \code{m}.\code{f}(\code{m})$)\
($\lambda \cx. \cx$,\ $8$) \Rightarrow~~~~~~~~}
\end{itemize}

\item Rewrite the following FVAE expression to FAE expression by extending ``encode`` function in section 9.5.
You should not ``evaluate'' them. (Consider $\code{if0}$ as an identifier.)

\begin{itemize}
    \item[a)] \(\textsf{val}\ \cx = \lambda \code{n}. \eadd{8}{\code{n}}\ \textsf{in}\ \lambda \code{n}. (\eapp{\cx}{(\esub{10}{\code{n}})}) \)
\item[b)] \(\textsf{val}\ \code{fac} = (\code{mk-rec}\
    (\lambda \code{fac}.\ \lambda \code{n}.\ (\code{if0}\ \code{n}\ 1 (\code{n} * (\code{fac}\ (\code{n} - 1))))))\ \textsf{in}\ (\code{fac}\ 10)\)
\item[c)] \(\lambda\ \code{body-proc}.\
\textsf{val}\ \code{fX} = \lambda\ \code{fX}.\
(\textsf{val}\ \code{f} = \lambda\ \cx.\ ((\code{fX}\ \code{fX})\ \cx)\
\textsf{in}\ (\code{body-proc}\ \code{f}))\
\textsf{in}\ (\code{fX}\ \code{fX}) \)
\end{itemize}

\item In this exercise, we extend FAE to check body expression when evaluating function expression.
Consider we extend value of FAE to include special value $\uparrow$ to represent error value at function body checking.
Write the operational semantics of the form
\fbox{$\sigma \vdash e \Rightarrow v$} for a function expression
$\lambda x. e$, when the semantics of the function expression
is changed as follows:
\begin{itemize}
\item If all free identifiers of $e$ is in $\sigma$ or is $x$, then evaluation of $\lambda x. e$ under $\sigma$ yields a closure
  contains function expression and the environment.
\item Otherwise, evaluation of $\lambda x. e$ under $\sigma$ yields a special value $\uparrow$.
\end{itemize}
You may use the function \textit{fv} which takes an
expression and returns a set of free identifiers in the expression.
For example, $fv(\lambda x. y\ x) = \{ y \}$.

\item In this exercise, we extend FAE to have record value. Consider the following language, RecFAE:
\[
\begin{array}{lrcl}
\text{Variable} & x & \in & \textit{Id} \\
\text{Field} & f & \in & \textit{Field} \\
\text{Record} & \rho & \in & \embox{Record} = \embox{Field} \finto \embox{Value} \\
\text{Expression}& e & ::= & x \\
&& \mid & \lambda x.e \\
&& \mid & e\ e \\
&& \mid & \{f\ e,\ \cdots,\ f\ e\}\\
&& \mid & e.f \\
&& \mid & e; e \\
&& \mid & (e) \\
\text{Value} & v & ::= & \rho \\
&& | & \langle \lambda x.e,\sigma \rangle \\
\end{array}
\]
where a value of the language is either a record $\rho$
or a closure $\langle\lambda x. e,\sigma\rangle$, and
an environment maps names to values:

The semantics of some constructs are as follows:
\begin{itemize}
  \item The evaluation of $\{f_1\ e_1,\ \cdots,\ f_k\ e_k\}$
    under $\sigma$ yields a finite map $\rho$,
which maps $f_i \in \{f_1\ \cdots,\ f_k\}$
to the value $v_i$ which is evaluated from the expression $e_i$ under $\sigma$.
  \item The evaluation of $e.f$ under $\sigma$ yields the value of the field $f$ in the record $\rho$,
      where evaluation $e$ under $\sigma$ yields \rho$.
  \item If evaluation of $e_1$ yields some value under $\sigma$, and evaluation of $e_2$ yields $v$ under same environment,
      then evaluation of $e_1; e_2$ yields $v$ under $\sigma$.
\item The evaluation of $(e)$ under any environment yields same value as evaluation of $e$.
\end{itemize}

Write the operational semantics of the form
$\boxed{\sigma \vdash e \Rightarrow v}$

\item In this exercise, we develop small language which only handles pair. Consider the following language Pair:
\[
\begin{array}{lrcl}
\text{Expression}& e & ::= & n \\
&&\mid& \verb!{pair ! e\ e\verb+}+\\
&&\mid& \verb!{first ! e\verb+}+\\
&&\mid& \verb!{second ! e\verb+}+\\
\text{Value} & v & ::= & \fbox{ (a) }
\end{array}
\]
where $n$ denotes a number and a value of the language is either a number or a pair of two values.
\begin{itemize}
  \item[a)] Write the grammar of the value $v$ and
 the operational semantics of the form \fbox{$\vdash e \Rightarrow v$} for the expressions.
  \item[b)] Write the evaluation derivation of the following expressions:

\hspace*{-5em}
 \derive
{\hspace*{\textwidth}}
{\vdash
 \{\texttt{second}\ \{\texttt{pair}\ 8\ \{
 \texttt{first}\ \{\texttt{pair}\ 320\ 42\}\}\}\}
 \Rightarrow~~~~~~~~}
\end{itemize}

\item In this exercise, we replace environment-baesd semantics of FVAE to subtitution-based semantics.
Consider the following language, FVAES:

\[
\begin{array}{lrcl}
\text{Expression} & e & ::= & n \\
&& | & \eadd{e}{e}\\
&& | & \esub{e}{e} \\
&& | & \ebind{x}{e}{e} \\
&& | & x \\
&& | & \efun{x}{e} \\
&& | & \eapp{e}{e} \\
\end{array}
\]

where evaluation of $e$ results in either a number $n$ or a closure $\efun{x}{e}$.

Consider the following implementation of FVAES:
\begin{verbatim}
trait FVAES
trait FVAESValue extends FVAES                                       // v ::= n | lambda x. e
case class Num(num: Int) extends FVAES with FVAESValue               // e ::= n
case class Add(left: FVAES, right: FVAES) extends FVAES              //     | e + e
case class Sub(left: FVAES, right: FVAES) extends FVAES              //     | e - e
case class Val(x: String, init: FVAES, body: FVAES) extends FVAES    //     | val x = e in e
case class Id(name: String) extends FVAES                            //     | x
case class Fun(x: String, body: FVAES) extends FVAES with FVAESValue //     | lambda x.e
case class App(fun: FVAES, arg: FVAES) extends FVAES                 //     | e e

// subst : (FVAES, String, FVAESValue) => FVAES
def subst(fvaes: FVAES, x: String, v: FVAESValue): FVAES = fvaes match {
  case Num(n) => fvaes
  case Add(l, r) => Add(subst(l, x, v), subst(r, x, v))
  case Sub(l, r) => Sub(subst(l, x, v), subst(r, x, v))
  case Val(y, i, b) => Val(y, subst(i, x, v), if (y == x) b else subst(b, x, v))
  case Id(name) => if (name == x) v else fvaes
  case Fun(y, b) => Fun(y, if (y == x) b else subst(b, x, v))
  case App(f, a) => App(subst(f, x, v), subst(a, x, v))
}

// interp : FVAES => FVAESValue
def interp(fvaes: FVAES): FVAESValue = fvaes match {
  case Num(n) => Num(n)
  case Add(l, r) => numAdd(interp(l), interp(r))
  case Sub(l, r) => numSub(interp(l), interp(r))
  case Val(x, i, b) => interp(subst(b, x, interp(i)))
  case Id(x) => error(s"free identifier: $x")
  case Fun(x, b) => Fun(x, b)
  case App(f, a) => interp(f) match {
    case Fun(x, b) => interp(subst(b, x, interp(a)))
    case fv => error(s"not a closure: $fv")
  }
}
\end{verbatim}

\begin{itemize}
  \item[a)]
Write the operational semantics of the above implementation 
of the form \fbox{$\vdash e \Rightarrow v$}
where $e[x/v]$ denotes \verb!subst(e, x, v)! and a value $v$ is either a number $n$ or
a closure $\efun{x}{e}$.

\begin{itemize}
  \item $e \equiv n$
  \item $e \equiv \eadd{e}{e}$
  \item $e \equiv \ebind{x}{e}{e}$
  \item $e \equiv \efun{x}{e}$
  \item $e \equiv \eapp{e}{e}$
\end{itemize}

  \item[b)] Write the definition of the substitution $e[x/v]$ denoting \verb!subst(e,x,v)!
of the form \fbox{$e[x/v] \leadsto e$}:
\begin{itemize}
  \item $e \equiv n$
%{\Large $n[x/v] \leadsto n$}
  \item $e \equiv \eadd{e}{e}$
  \item $e \equiv \ebind{x}{e}{e}$
  \item $e \equiv x$
  \item $e \equiv \efun{x}{e}$
  \item $e \equiv \eapp{e}{e}$
\end{itemize}

  \item[c)] Consider the following expression:

\[
\ebind{\code{z}}{\efun{\cx}{\esub{\cx}{\cy}}}{
    \ebind{\cy}{10}{
        (\eapp{\code{z}}{32})
    }
}
\]

\begin{itemize}
\item What is the result of evaluating the expression under the empty environment?
\item What is the result of evaluating the expression under the empty environment in FVAE?
\item Why are the results different?
\end{itemize}
    (Note: we can define equivalent semantics as FVAE using substitution
    by modifying \verb!subst! function)

%\verb!subst(With("y", Num(10), Id("z")), "z", Fun("x", Add(Id("x"), Id("y"))))!
%$[z/\verb!{fun {!z\verb!} {+ !x\ y\verb!}}!]\verb!{with {!y\ 10\verb!} !z\verb!}!$

\end{itemize}

\end{enumerate}
