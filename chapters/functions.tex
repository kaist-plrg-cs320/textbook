\setchapterpreamble[u]{\margintoc}
\chapter{Functions}
\labch{functions}

This section focuses on use of functions in functional programming.
In functional programming, functions are first-class. First-class functions
allow programmers to abstract complex computation easily.
This section explains what first-class functions are.
In addition, anonymous functions and closures, which are related to first-class
functions, will be introduced. To show the power of first-class functions, we
will re-implement the functions in \refch{immutability} (\code{inc1},
\code{square}, \ldots) with first-class functions.

\section{First-Class Functions}

An entity in a programming language is \textit{first-class}\index{first-class} if it satisfies the
following three conditions:

\begin{enumerate}
\item It can be an argument of a function call.
\item It can be a return value of a function.
\item A variable can refer to it.
\end{enumerate}

Anything that is first-class can be used as a value. Functions are highly important and
treated as values in functional languages.
Functions that are first-class are called \textit{first-class functions}.\index{first-class function}

Some people use the term higher-order functions. \textit{Higher-order
functions}\index{higher-order function} are
functions that are not first-order, where first-order functions neither take
functions as arguments nor return functions. Therefore, higher-order functions
can take functions as arguments and return functions. Strictly speaking, they
are different from first-class functions because first-class functions are
functions that can be passed as arguments or returned from functions.
However, any languages support first-class functions support higher-order
functions and vice versa.
The reason is obvious: to pass first-class functions as arguments, there should
be higher-order functions, and to pass functions to higher-order functions,
there should be first-class functions.
Consequently, in most contexts, people do not distinguish
first-class functions and higher-order functions, and you can consider
first-class functions and higher-order functions as exchangeable terms.

Now, let us see how we can use first-class functions in Scala with some code
examples.

\begin{verbatim}
def f(x: Int): Int = x
def g(h: Int => Int): Int = h(0)
g(f)
\end{verbatim}

The function \code{g} has one parameter \code{h}. The type of \code{h} is \code{Int => Int}.
An argument passed to \code{g} is a function that takes one integral
parameter and returns an integral value. In Scala, \code{=>} expresses the types
of functions. Functions without parameters have types of form \code{() => [return type]}.
\code{[parameter type] => [return type]} is the type of a function with a
single parameter. Round brackets express the types of functions with more than
one parameter: \code{([parameter type], … ) => [return type]}. Function \code{f}
has one integral parameter and returns an integer so can be an argument for
\code{g}. Evaluating \code{g(f)} equals evaluating \code{f(0)}, which results
in \code{0}.

\begin{verbatim}
def f(y: Int): Int => Int = {
  def g(x: Int): Int = x
  g
}
f(0)(0)
\end{verbatim}

Function \code{f} returns function \code{g}. Since \code{f} has return type
\code{Int => Int}, a return value must be a function that takes an integer as a
parameter and returns an integer. \code{g} satisfies the condition. \code{f(0)}
is same as \code{g} and therefore is a function. \code{f(0)(0)} is \code{g(0)},
which returns \code{0}.

\begin{verbatim}
val h0 = f(0)
h0(0)
\end{verbatim}

A variable can refer to \code{f(0)}. \code{h0} refers to the return value of
\code{f(0)} and has type \code{Int => Int}. Calling variables referring to
function values is possible. \code{h0(0)} is a valid expression and results in
\code{0}.

\begin{verbatim}
val h1 = f
         ^
error: missing argument list for method f

Unapplied methods are only converted to functions
when a function type is expected.

You can make this conversion explicit
by writing `f _` or `f(_)` instead of `f`.
\end{verbatim}

On the other hand, defining a variable referring to \code{f} results in a compile
error. In Scala, a function defined by \code{def} is not a value. Since \code{f}
is the name of a function but not a variable referring to a value, \code{h1}
cannot refer to the value of \code{f}. As the above error message implies,
underscores convert function names into function values.

\begin{verbatim}
val h1 = f _
h1(0)(0)
\end{verbatim}

Compiling the above code succeeds. The type of \code{h1} is \code{Int => (Int => Int)}.
\code{Int => Int => Int} denotes the same type because \code{=>} is
a right-associative type operator. \code{h1(0)(0)} is valid and yields \code{0}.

Actually, expressions except \code{val h1 = f} use function names as values
successfully. The Scala compiler transforms function names into function values if
they occur where function types are expected. Therefore, enforcing the type of
\code{h1} to be a function type corrects the code without underscores. The
following code works well:

\begin{verbatim}
val h1: Int => Int => Int = f
h1(0)(0)
\end{verbatim}

When programmers use function names as values, they usually place the names where
function types are expected. In these cases, underscores and explicit type
annotations are unnecessary. Rarely code becomes problematic and needs
modifications like the above to enforce the transformations.

How does the compiler create function values from function names? If the parameter
type of function \code{f} is \code{Int}, the corresponding function value is
\code{(x: Int) => f(x)}. The transformation is called eta expansion. \code{(x: Int) => f(x)}
is a function value without a name and does the same thing as
\code{f}. The following section covers functions without names.

\section{Anonymous Functions}

In functional programming, functions often appear only once as an argument or a
return value. Naming the functions used only once is unnecessary. The meanings of
function values are how they act. The parameters and bodies of functions decide
the meanings, but the names do not have a role. Naturally, most functional
languages provide syntax to define functions without giving them names. Such
functions are \textit{anonymous functions}.\index{anonymous function}

Anonymous functions in Scala have form \code{([parameter name]: [parameter type], …) => [expression]}.
Since curly brackets bundle multiple expressions and create
a single expression, the bodies of anonymous functions can have multiple
expressions: \code{(…) => { … }}. Like functions declared by \code{def},
anonymous functions can be arguments, return values, or values referred by
variables. Directly calling them is possible as well.

\begin{verbatim}
((x: Int) => x)(0)
def g(h: Int => Int): Int = h(0)
g((x: Int) => x)
def f(): Int => Int = (x: Int) => x
val h = (x: Int) => x
\end{verbatim}

The code does similar things to the previous code but uses anonymous functions.

Anonymous functions need explicit parameter types as named functions do. However,
annotating every parameter type is verbose and inconvenient. The Scala compiler
infers the types of parameters when anonymous functions occur where the compiler
expects function types.

\begin{verbatim}
def g(h: Int => Int): Int = h(0)
g(x => x)
\end{verbatim}

Since \code{g} has a parameter of type \code{Int => Int}, the compiler expects
\code{x => x} to have type \code{Int => Int}. It infers the type of \code{x} as
\code{Int}.

\begin{verbatim}
def f0(): Int => Int = x => x
def f1() = (x: Int) => x
def f2() = x => x  // a compile error
\end{verbatim}

\code{f0} has the explicit return type. \code{Int => Int} is the expected type of
\code{x => x}. The compiler infers the type of \code{x} as \code{Int}. While
\code{f1} does not result in a compile error, \code{f2} is problematic. Since
\code{(x: Int) => Int} specifies the parameter type, the compiler knows that its
type is \code{Int => Int}. In contrast, there is no information to infer the type
of \code{x => x}, the body of \code{f2}.

\begin{verbatim}
val h0: Int => Int = x => x
val h1 = (x: Int) => x
val h2 = x => x  // a compile error
\end{verbatim}

As shown in the previous example, \code{h0} and \code{h1} are valid, but
\code{h2} is not.

Most cases using anonymous functions are arguments for function calls so that the
functions do not require explicit parameter types. However, beginners might not
be sure about whether omitting parameter types is allowed or not. Specifying
parameter types is safe when it is not assured.

Scala provides one more syntax for anonymous functions. The syntax uses
underscores. Underscores help programmers to define concise and intuitive
anonymous functions. They make code readable but can appear only in particular
situations. Every parameter occurs exactly once in the body of a function in the
order. Moreover, the function is not an identity function like \code{(x: Int) => x}.
In such a function, underscores can replace parameters in the body.
Otherwise, it is impossible to use underscores to define anonymous functions.

\begin{verbatim}
def g0(h: Int => Int): Int = h(0)
g0(_ + 1)

def g1(h: (Int, Int) => Int): Int = h(0, 0)
g1(_ + _)
\end{verbatim}

The compiler desugars \verb!_ + 1! and obtain \code{x => x + 1}.
\verb!_ + _!
becomes \code{(x, y) => x + y}. The compiler automatically creates parameters
as many as underscores and substitute the underscores with the parameters. The
mechanism clearly shows why the restriction exists.

\begin{verbatim}
val h0 = (_: Int) + 1
val h1 = (_: Int) + (_: Int)
\end{verbatim}

Underscores can have explicit types.

In the code, the compiler cannot infer parameter types and therefore require
explicit parameter types to succeed compiling.

The transformation happens for the shortest expression containing underscores.
Expressing anonymous functions with complex bodies using underscores is tricky.

\begin{verbatim}
def f(x: Int): Int = x
def g1(h: Int => Int): Int = h(0)
def g2(h: (Int, Int) => Int): Int = h(0, 0)
g(f(_))
g1(f(_ + 1))  // a compile error
g2(f(_) + _)
g2(f(_ + 1) + _)  // a compile error
\end{verbatim}

As intended, \verb!f(_)! becomes \code{x => f(x)}, and \verb!f(_) + _! becomes
\code{(x, y) => f(x) + y}. (Actually, there is no need to write \verb!g(f(_))!
because it is equal to \code{g(f)}.) On the other hand, \verb!f(_ + 1)! becomes
\code{f(x => x + 1)} but not \code{x => f(x + 1)}. \verb!f(_ + 1) + _! becomes
\code{y => f(x => x + 1) + y} but not \code{(x, y) => f(x + 1) + y}.

Like type inference of parameter types, novices may not be sure about how
anonymous functions with underscores change. It is recommended to use normal anonymous
functions without underscores for those who are not confident about the mechanism
of underscores.

\section{Closures}

\textit{Closures}\index{closure} are function values that capture
environments, which stores the values of existing variables, when they are defined.
The bodies of closures may
have variables not defined in themselves, and the environments stores the values
of those variables.

\begin{verbatim}
def makeAdder(x: Int): Int => Int = {
  def adder(y: Int): Int = x + y
  adder
}
\end{verbatim}

The definition of \code{adder}, \code{def adder(y: Int): Int = x + y}, does not
define but uses \code{x}. However, the code is correct.

\begin{verbatim}
val add1 = makeAdder(1)
add1(2)
val add2 = makeAdder(2)
add2(2)
\end{verbatim}

\code{add1} and \code{add2} refer to the same \code{adder} function, but the
former returns an integer one larger than an argument, and the latter returns an
integer two larger than an argument. The results of \code{add(1)} and
\code{add(2)} are \code{3} and \code{4}, respectively. It is possible because the
closures capture the environments when they are created. \code{add1} refers to a
thing like \code{(adder, x = 1)} instead of simple \code{adder}. Similarly,
\code{add2} is actually \code{(adder, x = 2)}. Since the environment of
\code{add1} stores the fact that \code{x} is \code{1}, \code{add1(2)} results in
\code{3}. Under the environment of \code{add2}, \code{x} denotes \code{2}, and
thus \code{x + y}, or \code{add2(2)}, is \code{4}.

\section{First-Class Functions and Lists}

The section shows how first-class functions allow generalization of the functions
defined in \refch{immutability}.

\begin{verbatim}
def inc1(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case h :: t => h + 1 :: inc1(t)
}

def square(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case h :: t => h * h :: square(t)
}
\end{verbatim}

\code{inc1} increases every element of a given list by one, and \code{square}
squares every element. The two functions are remarkably similar. To make the
similarity clearer, let us rename the functions to \code{g}.

\begin{verbatim}
def g(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case h :: t => h + 1 :: g(t)
}

def g(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case h :: t => h * h :: g(t)
}
\end{verbatim}

The only difference is the left operand of \code{::} in the third line:
\code{h + 1} versus \code{h * h}. By adding one parameter, the functions become
entirely identical.

\begin{verbatim}
def g(l: List[Int], f: Int => Int): List[Int] = l match {
  case Nil => Nil
  case h :: t => f(h) :: g(t, f)
}
g(l, h => h + 1)

def g(l: List[Int], f: Int => Int): List[Int] = l match {
  case Nil => Nil
  case h :: t => f(h) :: g(t, f)
}
g(l, h => h * h)
\end{verbatim}

This function is called \code{map}. The returned list
has elements \textbf{map}ped by a given function.

\begin{verbatim}
def map(l: List[Int], f: Int => Int): List[Int] = l match {
  case Nil => Nil
  case h :: t => f(h) :: map(t, f)
}
\end{verbatim}

\code{inc1} and \code{square} can be redefined using \code{map}.

\begin{verbatim}
def inc1(l: List[Int]): List[Int] = map(l, h => h + 1)
def square(l: List[Int]): List[Int] = map(l, h => h * h)
\end{verbatim}

An underscore makes \code{inc1} concise.

\begin{verbatim}
def inc1(l: List[Int]): List[Int] = map(l, _ + 1)
\end{verbatim}

Let us compare \code{odd} and \code{positive}.

\begin{verbatim}
def odd(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case h :: t =>
    if (h % 2 != 0)
      h :: odd(t)
    else
      odd(t)
}

def positive(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case h :: t =>
    if (h > 0)
      h :: positive(t)
    else
      positive(t)
}
\end{verbatim}

They look similar. They can become identical by renaming and adding parameters.

\begin{verbatim}
def filter(l: List[Int], f: Int => Boolean): List[Int] = l match {
  case Nil => Nil
  case h :: t =>
    if (f(h))
      h :: filter(t, f)
    else
      filter(t, f)
}
\end{verbatim}


The function is called \code{filter} because it \textbf{filter}s
unwanted elements in an argument.

\code{odd} and \code{positive} can be redefined using \code{filter}.

\begin{verbatim}
def odd(l: List[Int]): List[Int] = filter(l, h => h % 2 != 0)
def positive(l: List[Int]): List[Int] = filter(l, h => h > 0)
\end{verbatim}

Underscores make the functions concise.

\begin{verbatim}
def odd(l: List[Int]): List[Int] = filter(l, _ % 2 != 0)
def positive(l: List[Int]): List[Int] = filter(l, _ > 0)
\end{verbatim}

Let us compare \code{sum} and \code{product} without tail recursion.

\begin{verbatim}
def sum(l: List[Int]): Int = l match {
  case Nil => 0
  case h :: t => h + sum(t)
}

def product(l: List[Int]): Int = l match {
  case Nil => 1
  case h :: t => h * product(t)
}
\end{verbatim}

After renaming the names to \code{g}, two differences exist: \code{0} versus
\code{1} and \code{h + g(t)} versus \code{h * g(t)}. By adding two parameters, an
initial value and a function taking \code{h} and \code{g(t)} as arguments, the
functions become identical.

\begin{verbatim}
def foldRight(l: List, n: Int, f: (Int, Int) => Int): Int = l match {
  case Nil => n
  case Cons(h, t) => f(h, foldRight(t, n, f))
}
\end{verbatim}

This function is called \code{foldRight} since it
appends an initial value at the right side of a list and
\textbf{fold}s the list from the \textbf{right} side using a given function.

\code{sum} and \code{product} can be redefined using \code{foldRight}.

\begin{verbatim}
def sum(l: List[Int]): Int = foldRight(l, 0, (h, gt) => h + gt)
def product(l: List[Int]): Int = foldRight(l, 1, (h, gt) => h * gt)
\end{verbatim}

They may use underscores for conciseness.

\begin{verbatim}
def sum(l: List[Int]): Int = foldRight(l, 0, _ + _)
def product(l: List[Int]): Int = foldRight(l, 1, _ * _)
\end{verbatim}

The following gives an intuitive interpretation of the function:

\begin{verbatim}
  foldRight(List(a, b, .., y, z), n, f)
= f(a, f(b, .. f(y, f(z, n)) .. ))

  foldRight(List(1, 2, 3), 0, add)
= add(1, add(2, add(3, 0)))

  foldRight(List(1, 2, 3), 1, mul)
= mul(1, mul(2, mul(3, 1)))
\end{verbatim}

Let us compare tail-recursive \code{sum} and \code{product}.

\begin{verbatim}
def sum(l: List[Int]): Int = {
  @tailrec def aux(l: List[Int], inter: Int): Int = l match {
    case Nil => inter
    case h :: t => aux(t, inter + h)
  }
  aux(l, 0)
}

def product(l: List[Int]): Int = l match {
  @tailrec def aux(l: List[Int], inter: Int): Int = l match {
    case Nil => inter
    case h :: t => aux(t, inter * h)
  }
  aux(l, 1)
}
\end{verbatim}

After renaming, there are two differences: \code{inter + h} versus \code{inter * h}
and \code{0} versus \code{1}. Similarly, adding two parameters makes the
functions identical.

\begin{verbatim}
def foldLeft(l: List, n: Int, f: (Int, Int) => Int): Int = {
  @tailrec def aux(l: List, inter: Int): Int = l match {
    case Nil => inter
    case Cons(h, t) => aux(t, f(inter, h))
  }
  aux(l, n)
}
\end{verbatim}

This function is called \code{foldLeft}. Its semantics is different from
\code{foldRight}. While \code{foldRight} appends an initial value at
the right side and folds a list from the right side, \code{foldLeft}
prepends an initial value at the left side and \textbf{fold}s
a list from the \textbf{left} side. The following gives an intuitive
interpretation:

\begin{verbatim}
  foldLeft(List(a, b, .., y, z), n, f)
= f(f( .. f(f(n, a), b), .. , y), z)

  foldLeft(List(1, 2, 3), 0, add)
= add(add(add(0, 1), 2), 3)

  foldLeft(List(1, 2, 3), 1, mul)
= mul(mul(mul(1, 1), 2), 3)
\end{verbatim}

The order traversing a list does not affect the results of \code{sum} and
\code{product} Both \code{foldRight} and \code{foldLeft} can express the functions.

\begin{verbatim}
def sum(l: List[Int]): Int = foldLeft(l, 0, _ + _)
def product(l: List[Int]): Int = foldLeft(l, 1, _ * _)
\end{verbatim}

On the other hand, the order is important for some functions.
Consider a function that takes a list of digits as arguments and returns the
decimal number obtained by concatenating the digits.
\code{foldLeft} is the easiest way to implement this function.

\begin{verbatim}
def digitToDecimal(l: List[Int]) = foldLeft(l, 0, _ * 10 + _)

  foldLeft(List(1, 2, 3), 0, f)
= f(f(f(0, 1), 2), 3)
= ((0 * 10 + 1) * 10 + 2) * 10 + 3
= (1 * 10 + 2) * 10 + 3
= 12 * 10 + 3
= 123
\end{verbatim}

Using \code{foldRight} with the same arguments will yield completely different
result.

\begin{verbatim}
def digitToDecimal(l: List[Int]) = foldRight(l, 0, _ * 10 + _)

  foldRight(List(1, 2, 3), 0, f)
= f(1, f(2, f(3, 0)))
= 1 * 10 + (2 * 10 + (3 * 10 + 0))
= 1 * 10 + (2 * 10 + 30)
= 1 * 10 + 50
= 60
\end{verbatim}

\code{map}, \code{filter}, \code{foldRight}, and
\code{foldLeft} are powerful functions. The four functions offer concise
implementation for most procedures dealing with lists.
Since they are so useful, the Scala standard library provies \code{map},
\code{filter}, \code{foldRight}, and \code{foldLeft} as the methods of the
\code{List} class. You do not need to implement \code{map},
\code{filter}, \code{foldRight}, and \code{foldLeft} by yourself.

\code{map(l, f)} can be rewritten to \code{l.map(f)} by using the \code{map}
method instead.

\begin{verbatim}
def inc1(l: List[Int]): List[Int] = l.map(_ + 1)
def square(l: List[Int]): List[Int] = l.map(h => h * h)
\end{verbatim}

\code{filter(l, f)} can be rewritten to \code{l.filter(f)} by using the
\code{filter} method instead.

\begin{verbatim}
def odd(l: List[Int]): List[Int] = l.filter(_ % 2 != 0)
def positive(l: List[Int]): List[Int] = l.filter(_ > 0)
\end{verbatim}

\code{foldRight(l, n, f)} can be rewritten to \code{l.foldRight(n)(f)} by using the
\code{foldRight} method instead.

\begin{verbatim}
def sum(l: List[Int]): Int = l.foldRight(0)(_ + _)
def product(l: List[Int]): Int = l.foldRight(1)(_ * _)
\end{verbatim}

\code{foldLeft(l, n, f)} can be rewritten to \code{l.foldLeft(n)(f)} by using the
\code{foldLeft} method instead.

\begin{verbatim}
def sum(l: List[Int]): Int = l.foldLeft(0)(_ + _)
def product(l: List[Int]): Int = l.foldLeft(1)(_ * _)
def digitToDecimal(l: List[Int]) = l.foldLeft(0)(_ * 10 + _)
\end{verbatim}

The methods in the standard library are polymorphic, i.e. they can take
arguments of various types. For example, our \code{map} function takes only a
list of integers. To use \code{map} for a list of students, we need to define a
new version of \code{map}. However, the \code{map} method in the standard
library can take lists of any types as arguments.

\begin{verbatim}
case class Student(name: String, height: Int)

def heights(l: List[Student]): List[Int] = l.map(_.height)
\end{verbatim}

\section{For Loops}

Scala has for loops.
In Scala, a for loop is an expression, which evalautes to a value.
For expressions are highly expressive.
Unlike \code{while}, which work with mutable variables or objects,
\code{for} Scala helps programmers to write code in a functional and readable way.

The syntax of a for expression is as follows:

\begin{verbatim}
for ([name] <- [expression])
  yield [expression]
\end{verbatim}

For expressions can replace use of the \code{map} method.

\begin{verbatim}
for (n <- List(0, 1, 2))
  yield n * n
\end{verbatim}

It results in \code{List(0, 1, 4)}. The result of \code{for (…) yield [expressions]}
is a collection containing the result of evaluating the \code{[expression]}
at each iteration. For expressions can appear at any places expecting
expressions.

\begin{verbatim}
def square(l: List[Int]): List[Int] =
  for (n <- l)
    yield n * n
\end{verbatim}

In Scala, \code{for} is just syntactic sugar. Instead of giving specific
semantics to \code{for}, syntactic rules transform code using \code{for} into the
code using methods of collections and anonymous functions. The above code becomes
code using and \code{map} by the transformation.

\begin{verbatim}
List(0, 1, 2).map(n => n * n)

def square(l: List[Int]): List[Int] =
  l.map(n => n * n)
\end{verbatim}

For this reason, for expressions are powerful. Any
user-defined types can appear in for expressions if the
types define \code{map}.

For expressions can replace use of the \code{filter} method as well.

\begin{verbatim}
def positive(l: List[Int]): List[Int] =
  for (n <- l if n > 0)
    yield n
\end{verbatim}

Elements not satisfying a given condition will be omitted during iteration.

In addition, combination of \code{map} and \code{filter} can be expressed with a
for loop concisely. Consider a function that takes a list of students and
returns a list of the names of students whose height is greater than 170.
The function can be implemented with \code{map} and \code{filter} like below.

\begin{verbatim}
def tall(l: List[Student]): List[String] =
  l.filter(_.height > 170).map(_.name)
\end{verbatim}

We can use a for expression instead.

\begin{verbatim}
def tall(l: List[Student]): List[String] =
  for (s <- l if s.height > 170)
    yield s.name
\end{verbatim}

\section{Exercises}

\begin{enumerate}
  \item
    Implement a function that takes a list of integers and an integer as
    arguments and increases every element of the list by the given integer. Use
    the \code{map} method.

  \item
    Implement a function that takes a list of integers and an integer as arguments
    and filters elements less than or equal to the given integer out from the list.
    Use the \code{filter} method.

  \item
    Implement a function that takes a list of integers and an integer as arguments
    and returns a list obtained by appending the integer at the end of the list.
    Use the \code{foldRight} method.

  \item
    Implement a function that takes a list of integers
    and returns a list obtained by reversing the order between the elements.
    Use the \code{foldLeft} method.
\end{enumerate}
