\setchapterpreamble[u]{\margintoc}
\chapter{Scala Collections}
\labch{scala-collections}

It is the third article about functional programming. The last article dealt with
first-class functions, anonymous functions, and option types. It generalized
functions treating lists with first-class functions. This article introduces the
\verb!List! and \verb!Option! types defined in the Scala standard library. It
focuses on syntactic differences between the custom types defined in the previous
articles and the types came from the library rather than emphasizing new
concepts. Besides, it deals with \verb!for!, which is extremely expressive.

\section{List}

The library defines the \verb!List! class. The \verb!scala.collection.immutable!
package includes the class. Programmers can use lists without any import
statements because \term{aliases} of types and values required to use lists exist
in the \verb!scala!
package\sidenote{\url{https://www.scala-lang.org/api/current/scala/index.html}}, whom compilers
always automatically import.

Like the custom lists, the empty list is \verb!Nil!.

On the other hand, \verb!::! replaces \verb!Cons!. Expressions like
\verb!::(0, Nil)! construct lists.

The \verb!::! method of the list class provides more intuitive representations of
lists than the previous code. An expression of form \verb![expression].[method name]([expression], …)!
invokes the method referred by the name. \verb!Nil.::(0)!
creates a list with single element \verb!0!. Scala allows using methods as infix
operators. Operators whose names end with the colon are right-associative. Their
owners are the operands at the right sides. Therefore, \verb!0 :: Nil! and
\verb!Nil.::(0)! are the same expression. Both denote the same value as
\verb!::(0, Nil)! does. Similarly, \verb!0 :: 1 :: Nil! and
\verb!Nil.::(0).::(1)! are identical. They and \verb!::(0, ::(1, Nil))! result in
the same list, which contains \verb!0! and \verb!1!. \verb!0 :: 1 :: Nil! is the
most intuitive representation among them.

\verb!List! also can create lists. \verb!List([expression], …)! evaluates every
expression between the round brackets and constructs a list containing the
results. \verb!List(0, 1)! and \verb!0 :: 1 :: Nil! produce the same value. Both
representations are popular, but the \verb!List(…)! form fits enumerating all
elements well while expressions like \verb!0 :: 1 :: l! are typical when
prepending elements in front of existing lists.

\begin{verbatim}
// custom lists
Cons(0, Cons(1, Cons(2, Nil)))

// standard library lists
::(0, ::(1, ::(2, Nil)))
Nil.::(2).::(1).::(0)
0 :: 1 :: 2 :: Nil
List(0, 1, 2)
\end{verbatim}

\verb!::! replaces \verb!Cons! during pattern matching as well. Scala allows
using class names as infix operators in pattern expressions. \verb!case h :: t =>!
is valid.

\begin{verbatim}
// custom lists
Cons(0, Cons(1, Cons(2, Nil))) match {
  case Nil => "foo"
  case Cons(h, t) => "bar"
}

// standard library lists
List(0, 1, 2) match {
  case Nil => "foo"
  case h :: t => "bar"
}
\end{verbatim}

The \verb!List! type in the library is \term{polymorphic}. The custom lists
contain only integral values. However, the lists of the library can be lists
containing values of any types. The types of lists are not \verb!List!'s.
Instead, like \verb!List[Int]!, the types represent the types of the elements of
the lists. \verb!List[Int]! is the type of a list containing only integers.

\begin{verbatim}
// custom lists
Cons(0, Cons(1, Cons(2, Nil))): List

// standard library lists
List(): List[Nothing]
List(true): List[Boolean]
List(0, 1, 2): List[Int]
\end{verbatim}

\verb!Nothing! is the \term{bottom} type, which is a \term{subtype} of every
type. Values never belong to the \verb!Nothing! type, but the empty list has type
\verb!List[Nothing]! since it does not contain any elements. Both
\term{parametric polymorphism} and \term{subtype polymorphism} are essential
concepts, and thus later articles deal with them. For those who are unfamiliar
with the notions, understanding that a list containing values of type \verb!A!
has type \verb!List[A]! is sufficient to use lists.

Lists have the \verb!map!, \verb!filter!, \verb!foldRight!, and \verb!foldLeft!
methods. \verb!foldRight! and \verb!foldLeft! are curried. \term{Currying}
transforms functions with multiple parameters into sequences of functions with a
single parameter. The \verb!:\! and \verb!/:! methods respectively give the same
results as \verb!foldRight! and \verb!foldLeft! give.

\begin{verbatim}
// custom lists
def inc1(l: List): List = list_map(l, _ + 1)
def odd(l: List): List = list_filter(l, _ % 2 != 0)
def sum(l: List): Int = list_foldRight(l, 0, _ + _)
def product(l: List): Int = list_foldLeft(l, 1, _ * _)

// standard library lists
def inc1(l: List[Int]): List[Int] = l.map(_ + 1)
def odd(l: List[Int]): List[Int] = l.filter(_ % 2 != 0)
def sum(l: List[Int]): Int = l.foldRight(0)(_ + _)
def sum(l: List[Int]): Int = (l :\ 0)(_ + _)
def product(l: List[Int]): Int = l.foldLeft(1)(_ * _)
def product(l: List[Int]): Int = (1 /: l)(_ * _)
\end{verbatim}

The methods can take functions of various types as arguments.

\begin{verbatim}
List(1, 2, 3).map(_ == 1)  // List(true, false, false)
List("", "a", "ab").filter(_.length == 1)  // List("a")

def addBack(l: List[Int], n: Int): List[Int] =
  l.foldRight(List(n))(_ :: _)
def addBack(l: List[Int], n: Int): List[Int] =
  (l :\ List(n))(_ :: _)

def reverse(l: List[Int]): List[Int] =
  l.foldLeft(Nil: List[Int])((t, h) => h :: t)
def reverse(l: List[Int]): List[Int] =
  ((Nil: List[Int]) /: l)((t, h) => h :: t)
\end{verbatim}

The \verb!list_get! and \verb!list_getOption! methods find an element at an
arbitrary index. The library provides the same functionality. Lists are per se
functions. They have single integral parameter \verb!n! and return the \verb!n!th
elements of them. Like \verb!list_get!, exceptions occur when \verb!n! is wrong.
The \verb!lift! method converts unsafe functions into safe functions returning
\verb!None! instead of raising exceptions. The lifted functions do the thing
\verb!list_getOption! does.

\begin{verbatim}
// custom lists
list_get(Cons(0, Cons(1, Cons(2, Nil))), 0)
list_getOption(Cons(0, Cons(1, Cons(2, Nil))), 0)

// standard library lists
List(0, 1, 2)(0)
List(0, 1, 2).lift(0)
\end{verbatim}

Other methods substitute the roles of other previously defined functions.

\begin{verbatim}
// custom lists
addBack(Cons(0, Cons(1, Nil)), 2)

length(Cons(0, Cons(1, Cons(2, Nil))))
reverse(Cons(0, Cons(1, Cons(2, Nil))))

// standard library lists
List(0, 1) :+ 2
List(0, 1) ++ List(2)
List(0, 1, 2).length
List(0, 1, 2).reverse
\end{verbatim}

The web site of the
library\sidenote{\url{https://www.scala-lang.org/api/current/scala/collection/immutable/List.html}}
gives the full list of the methods of the \verb!List! class. This article
introduces only one additional important method. The \verb!flatMap! method is
similar to the \verb!map! method, but its parameter is a function returning a
collection. Here, the term 'collection' is broad in its meaning. Even options are
collections. (Precisely, the function returns a value whose type is
\verb!IterableOnce[T]!.) After applying a given function to the elements of a
given list, while \verb!map! puts the results in a list, \verb!flatMap! puts the
elements of the results in a list. Its name implies that it *\term{flat}*tens the
return value of \verb!map!.

\begin{verbatim}
List(0, 1, 2).flatMap(List(_))  // List(0, 1, 2)
List(0, 1, 2).flatMap(0 to _)  // List(0, 0, 1, 0, 1, 2)

def div100(n: Int): Option[Int] =
  if (n == 0) None else Some(100 / n)
List(0, 1, 2).flatMap(div100)  // List(100, 50)
\end{verbatim}

\verb!list_foldLeft! is tail-recursive, but \verb!list_map!, \verb!list_filter!,
and \verb!list_foldRight! are not. Stacks overflow when lists given as arguments
are long. Fortunately, the methods of the library are free from such a problem.
The library defines lists to become mutable only when being accessed inside the
library. The methods use \verb!while! loops, require time complexity of \(O(n)\),
and do not make stacks overflow. Lists are immutable for library users, and
therefore using lists maintains immutability and does not harm the functional
paradigm.

\section{Option}

The library defines the \verb!Option! class as well. The \verb!scala! package
includes the class so that import statements are unnecessary.

The names, \verb!None! and \verb!Some!, are identical to the custom options.

\begin{verbatim}
// custom options
None
Some(0)

// standard library options
None
Some(0)
\end{verbatim}

Therefore, pattern matching is the same.

\begin{verbatim}
// custom options
Some(0) match {
  case None => "foo"
  case Some(n) => "bar"
}

// standard library options
Some(0) match {
  case None => "foo"
  case Some(n) => "bar"
}
\end{verbatim}

Like lists, options are polymorphic. \verb!Some! wraps not only integers but also
any values. Values of type \verb!Option[T]! contain values of type \verb!T! or
nothing.

\begin{verbatim}
// custom options
Some(0): Option

// standard library options
None: Option[Nothing]
Some(true): Option[Boolean]
Some(0): Option[Int]
\end{verbatim}

The class defines the \verb!map! and \verb!flatMap! methods. The two methods can
take functions of various types as arguments.

\begin{verbatim}
// custom options
option_map(Some(0), n => n * n)
option_flatMap(Some(0), div100)

// standard library options
Some(0).map(n => n * n)
Some(0).flatMap(div100)
\end{verbatim}

The web site\sidenote{\url{https://www.scala-lang.org/api/current/scala/Option.html}} shows
the full list of the methods of the \verb!Option! class.

\section{for}

Scala has \verb!for! statements. In fact, \verb!for! expressions, which denote
values, exist in Scala. \verb!for! expressions are highly expressive. Unlike
\verb!while! loops, which work with mutable variables or objects, \verb!for! of
Scala helps programmers to write code in a functional and readable way.

Firstly, let us see \verb!for! statements, which do not produce values. The
syntax is similar to the syntax of Java ('foreach' loops) or Python but different
from the syntax of C.

\begin{verbatim}
for (n <- List(0, 1, 2))
  println(n * n)
\end{verbatim}

The code prints \verb!0!, \verb!1!, and \verb!4!. \verb!n! refers to \verb!0! at
the first iteration, \verb!1! at the second iteration, and \verb!2! at the third
iteration.

\verb!for! expressions use the \verb!yield! keyword.

\begin{verbatim}
for (n <- List(0, 1, 2))
  yield n * n
\end{verbatim}

It results in \verb!List(0, 1, 4)!. The result of \verb!for (…) yield [expressions]!
is a collection containing the result of evaluating the expression
at each iteration. \verb!for! expressions can appear at any places expecting
expressions.

\begin{verbatim}
val x = for (n <- List(0, 1, 2)) yield n * n
\end{verbatim}

In Scala, \verb!for! is just syntactic sugar. Instead of giving specific
semantics to \verb!for!, syntactic rules transform code using \verb!for! into the
code using methods of collections and anonymous functions. The above code becomes
code using \verb!foreach! and \verb!map!.

\begin{verbatim}
List(0, 1, 2).foreach(n => println(n * n))
List(0, 1, 2).map(n => n * n)
\end{verbatim}

For this reason, \verb!for! statements and expressions are powerful. Any
user-defined types can appear in \verb!for! statements or expressions if the
types define methods like \verb!foreach! and \verb!map!.

Programs use \verb!for! expressions for other purposes than accessing each
element in a collection once. \verb!;! allows nesting iterations. A nested
iteration yields values and stores them in a single collection.

\begin{verbatim}
for (n <- List(0, 1, 2);
     m <- 0 to n)
  yield m * m
\end{verbatim}

The result is \verb!List(0, 0, 1, 0, 1, 4)!. Nesting \verb!for! expressions does
not produce the same result.

\begin{verbatim}
for (n <- List(0, 1, 2)) yield
  for (m <- 0 to n)
    yield m * m
// List(Vector(0), Vector(0, 1), Vector(0, 1, 4))
\end{verbatim}

The code using a semicolon is more concise and more readable than the code using
the nested expressions.

\verb!if! prevents accessing elements not satisfying a given condition.

\begin{verbatim}
for (n <- List(0, 1, 2) if n % 2 == 0;
     m <- 0 to n)
  yield m * m
\end{verbatim}

It results in \verb!List(0, 0, 1, 4)!. \verb!1! is skipped.

The code using \verb!;! and \verb!if! changes into the code using \verb!flatMap!
and \verb!filter!.

\begin{verbatim}
List(0, 1, 2)
  .filter(n => n % 2 == 0)
  .flatMap(n => 0 to n)
  .map(m => m * m)
\end{verbatim}

Since options have \verb!foreach!, \verb!map!, \verb!filter!, and \verb!flatMap!,
options can appear in \verb!for! expressions. The remaining of the article shows
how \verb!for! expressions make code easy to understand.

\begin{verbatim}
def f(x: Int): Option[Int] = ...
def g(x: Int, y: Int, z: Int, w: Int): Int = ...
\end{verbatim}

Function \verb!f! may fail and thus returns an option. Function \verb!g! has four
integral parameters. Consider a program that calculates \verb!f(0)!, \verb!f(1)!,
\verb!f(2)!, and \verb!f(3)! and uses the results as arguments of \verb!g! only
if every function call has succeeded. Pattern matching allows simple code.

\begin{verbatim}
(f(0), f(1), f(2), f(3)) match {
  case (Some(x), Some(y), Some(z), Some(w)) =>
    Some(g(x, y, z, w))
  case _ =>
    None
}
\end{verbatim}

It works well because pattern matching can be done on tuples as well. However,
assume that \verb!f! takes a long time to produce the result. Since the program
calls \verb!f! four times regardless of whether the previous call has succeeded
or not, the program is inefficient. It is desirable to call next \verb!f! only if
the last call has returned a value belongs to \verb!Some!. Let us use sequential
pattern matching.

\begin{verbatim}
f(0) match {
  case Some(x) => f(1) match {
    case Some(y) => f(2) match {
      case Some(z) => f(3) match {
        case Some(w) =>
          Some(g(x, y, z, w))
        case None => None }
      case None => None }
    case None => None }
  case None => None }
\end{verbatim}

It is efficient but verbose and complicated. \verb!flatMap! and \verb!map!
improve the code.

\begin{verbatim}
f(0).flatMap(x =>
f(1).flatMap(y =>
f(2).flatMap(z =>
f(3).map(w =>
  g(x, y, z, w)
))))
\end{verbatim}

A \verb!for! expression makes code clear and concise.

\begin{verbatim}
for (x <- f(0);
     y <- f(1);
     z <- f(2);
     w <- f(3))
  yield g(x, y, z, w)
\end{verbatim}
