
\chapter{Solutions to Exercises}
\labch{solutions}

Many exercises are meant to have multiple solutions. Each provided solution may
not be the only solution.

\textbf{\refex{immutability-student}}
\vspace{-1em}
\begin{verbatim}
def names(l: List[Student]): List[String] = l match {
  case Nil => Nil
  case h :: t => h.name :: names(t)
}
\end{verbatim}

\textbf{\refex{immutability-tall}}
\vspace{-1em}
\begin{verbatim}
def tall(l: List[Student]): List[Student] = l match {
  case Nil => Nil
  case h :: t =>
    if (h.height > 170)
      h :: tall(t)
    else
      tall(t)
}
\end{verbatim}

\textbf{\refex{immutability-length}}
\vspace{-1em}
\begin{verbatim}
def length(l: List[Int]): Int = l match {
  case Nil => 0
  case h :: t => 1 + length(t)
}
\end{verbatim}

\textbf{\refex{immutability-append}}
\vspace{-1em}
\begin{verbatim}
def append(l: List[Int], n: Int): List[Int] = l match {
  case Nil => n :: Nil
  case h :: t => h :: append(t, n)
}
\end{verbatim}
\vspace{-1em}
$O(n)$

\textbf{\refex{functions-incby}}
\vspace{-1em}
\begin{verbatim}
def incBy(l: List[Int], n: Int): List[Int] = l.map(_ + n)
\end{verbatim}

\textbf{\refex{functions-gt}}
\vspace{-1em}
\begin{verbatim}
def gt(l: List[Int], n: Int): List[Int] = l.filter(_ > n)
\end{verbatim}

\textbf{\refex{functions-append}}
\vspace{-1em}
\begin{verbatim}
def append(l: List[Int], n: Int): List[Int] =
  l.foldRight(n :: Nil)(_ :: _)
\end{verbatim}

\textbf{\refex{functions-reverse}}
\vspace{-1em}
\begin{verbatim}
def reverse(l: List[Int]): List[Int] =
  l.foldLeft(Nil: List[Int])((l, e) => e :: l)
\end{verbatim}

\textbf{\refex{syntax-and-semantics-expr}}
\begin{enumerate}
  \item No
  \item No
  \item No
  \item No
  \item Yes
\end{enumerate}

\textbf{\refex{syntax-and-semantics-icecream}}
\begin{enumerate}
  \item No
  \item Yes
  \item No
  \item Yes
  \item No
  \item Yes
  \item Yes
\end{enumerate}

\textbf{\refex{syntax-and-semantics-coffee}}
\begin{enumerate}
  \item No
  \item Yes
  \item Yes
  \item Yes
  \item No
  \item Yes
\end{enumerate}

\textbf{\refex{identifiers-arrow}}

\begin{itemize}
  \item $\ebind{\cx_A}{(\ebind{\cx_B}{3}{\esub{5}{\cx_C}})}{\eadd{1}{\cx_D}}$
  \begin{enumerate}
    \item $C\rightarrow B,D\rightarrow A$
    \item No shadowing
  \end{enumerate}
  \item $\ebind{\cx_A}{3}{\ebind{\cy_B}{5}{\eadd{1}{\cx_C}}}$
  \begin{enumerate}
    \item $C\rightarrow A$
    \item No shadowing
  \end{enumerate}
  \item $\ebind{\cx_A}{3}{\ebind{\cx_B}{5}{\eadd{1}{\cx_C}}}$
  \begin{enumerate}
    \item $C\rightarrow B$
    \item $B\rightarrow A$
  \end{enumerate}
\end{itemize}

\textbf{\refex{identifiers-shadowing-impl}}
\vspace{-1em}
\begin{verbatim}
case Num(n) => Set()
case Add(l, r) => helper(l, env) ++ helper(r, env)
case Id(x) => Set()
case Val(x, e, b) =>
  val s = if (env(x)) Set(x) else Set()
  s ++ helper(e, env) ++ helper(b, env + x)
\end{verbatim}

\textbf{\refex{first-order-functions-eval}}
\begin{enumerate}
  \item Free identifier error
  \item $5$
  \item $3$
  \item Free identifier error
  \item Free identifier error
\end{enumerate}

\textbf{\refex{first-class-functions-trace}}

$\sigma_1=[\cx\mapsto5]$\\
$\sigma_2=\sigma_1[\cf\mapsto v_1]$\\
$\sigma_3=\sigma_2[\code{g}\mapsto v_2]$\\
$\sigma_4=\sigma_2[\cx\mapsto1]$\\
$\sigma_5=\sigma_1[\cy\mapsto1]$\\
$v_1=\clov{\cy}{\eadd{\cy}{\cx}}{\sigma_1}$\\
$v_2=\clov{\cx}{\cx}{\sigma_2}$\\
$
\begin{array}{@{}c|c|c@{}}
  \text{expr} & \text{env} & \text{res} \\\hline
\ebind{\cx}{5}{
   \ebind{\code{f}}{\efun{\cy}{\eadd{\cy}{\cx}}}{
     \eapp{(\efun{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}})}
       {(\efun{\cx}{\cx})}}} & \emptyset & \\
5 & \emptyset & 5 \\
\ebind{\code{f}}{\efun{\cy}{\eadd{\cy}{\cx}}}{
  \eapp{(\efun{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}})}
    {(\efun{\cx}{\cx})}} & \sigma_1 & \\
\efun{\cy}{\eadd{\cy}{\cx}} & \sigma_1 & v_1 \\
\eapp{(\efun{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}})}{(\efun{\cx}{\cx})} & \sigma_2 & \\
\efun{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}} & \sigma_2 &
\clov{\code{g}}{\eapp{\code{f}}{(\eapp{\code{g}}{1})}}{\sigma_2} \\
\efun{\cx}{\cx} & \sigma_2 & v_2 \\
\eapp{\code{f}}{(\eapp{\code{g}}{1})} & \sigma_3 & \\
\cf & \sigma_3 & v_1 \\
\eapp{\code{g}}{1} & \sigma_3 \\
\code{g} & \sigma_3 & v_2 \\
1 & \sigma_3 & 1 \\
\cx & \sigma_4 & 1 \\
\eadd{\cy}{\cx} & \sigma_5 \\
\cy & \sigma_5 & 1 \\
\cx & \sigma_5 & 5 \\
\end{array}
$
\\

\textbf{\refex{first-class-functions-scope}}
\begin{enumerate}
  \item Dynamic scoping
  \item The argument is the only identifier the body can use unless the body defines a new identifier by itself.
  \item Static scoping
\end{enumerate}

\textbf{\refex{first-class-functions-rewrite}}

$\eapp{(\efun{\cx}{\efun{\cy}\eapp{\eapp{\cx}{(\esub{10}{\cy})}}})}{\efun{\cy}{\eadd{8}{\cy}}}$
\\

\textbf{\refex{first-class-functions-rewrite-impl}}
\vspace{-1em}
\begin{verbatim}
case Num(n) => Num(n)
case Id(x) => Id(x)
case Val(x, e, b) => App(Fun(x, desugar(b)), desugar(e))
case Fun(x, b) => Fun(x, desugar(b))
case App(f, a) => App(desugar(f), desugar(a))
\end{verbatim}

\textbf{\refex{first-class-functions-pair}}
\vspace{-1em}
\begin{verbatim}
App(
  App(
    Fun("x", Fun("y", Fun("z",
      App(App(Id("z"), Id("x")), Id("y"))
    ))),
    desugar(f)
  ),
  desugar(s)
)
\end{verbatim}

\textbf{\refex{first-class-functions-closure}}

$\eapp{\eapp{(\efun{\cx}{\efun{\cy}{\cx}})}{0}}{0}$
\\

\textbf{\refex{first-class-functions-terminate}}

$\eapp{1}{1}$
\\

\textbf{\refex{first-class-functions-free}}

$\efun{\cx}{\cy}$
\\

\textbf{\refex{syntax-and-semantics-pair}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \evald{e_1}{v_1}\\\evald{e_2}{v_2} }
      { \evald{(e_1,e_2)}{(v_1,v_2)} }
    \]

    \[
      \inferrule
      { \evald{e}{(v_1,v_2)} }
      { \evald{e\textsf{.1}}{v_1} }
    \]

    \[
      \inferrule
      { \evald{e}{(v_1,v_2)} }
      { \evald{e\textsf{.2}}{v_2} }
    \]
  \item
    \[
      \inferrule
      {
        \inferrule
        {
          \evale{8}{8} \\
          \inferrule
          {
            \inferrule
            { \evale{320}{320} \\ \evale{42}{42} }
            { \evale{(320,42)}{(320,42)} }
          }
          { \evale{(320,42)\textsf{.1}}{320} }
        }
        { \evale{(8,(320,42)\textsf{.1})}{(8,320)} }
      }
      { \evale{(8,(320,42)\textsf{.1})\textsf{.2}}{320} }
    \]
\end{enumerate}

\textbf{\refex{syntax-and-semantics-record}}
\[
  \inferrule
  { \evald{e_1}{v_1} \\\cdots\\ \evald{e_n}{v_n} }
  { \evald{\{l_1:e_1,\cdots,l_n:e_n\}}{\langle l_1:v_1,\cdots,l_n:v_n\rangle} }
\]

\[
  \inferrule
  { \evald{e}{\langle\cdots,l:v,\cdots\rangle} }
  { \evald{e.l}{v} }
\]

\textbf{\refex{syntax-and-semantics-stlist}}
\[
  \evald{\textsf{()}}{\textsf{()}}
\]

\[
  \inferrule
  { \evald{e_1}{\textsf{()}}\\ \cdots\\ \evald{e_n}{\textsf{()}} }
  { \evald{e_1;\cdots;e_n}{\textsf{()}} }
\]

\[
  \inferrule
  {
    \evald{e_1}{v_1}\quad\cdots\quad\evald{e_m}{v_m}\quad
    v_m\not=\textsf{()}\quad
    \evald{e_{m+1}}{\textsf{()}}\quad\cdots\quad\evald{e_n}{\textsf{()}}
  }
  { \evald{e_1;\cdots;e_n}{v_m} }
\]

\textbf{\refex{first-class-functions-fv}}
\[
  \inferrule
  { \embox{fv}(e)\subseteq\dom{\sigma}\cup\{x\} }
  { \evald{\efun{x}{e}}{\clov{x}{e}{\sigma}} }
\]

\[
  \inferrule
  { \embox{fv}(e)\not\subseteq\dom{\sigma}\cup\{x\} }
  { \evald{\efun{x}{e}}{\uparrow} }
\]

\textbf{\refex{first-class-functions-mult}}
\begin{enumerate}
  \item
    \[
      \evald{\lambda x_1\cdots x_n. e}{\langle \lambda x_1\cdots x_n.e,\sigma \rangle}
    \]

    \[
      \inferrule
      {
        \evald{e_0}{\langle \lambda x_1\cdots x_n.e,\sigma' \rangle}\\
        \evald{e_1}{v_1}\quad\cdots\quad\evald{e_n}{v_n}\\
        \eval{\sigma'[x_1 \mapsto v_1,\cdots,x_n \mapsto v_n]}{e}{v}
      }
      { \evald{\eappfo{e_0}{e_1,\cdots,e_n}}{v} }
    \]
  \item
    $\sigma_1=[\cf\mapsto{\clov{\cx}{\cx}{\emptyset}},\code{m}\mapsto8],
    \sigma_2=[\cx\mapsto8]$
    \[
      \small
      \inferrule
      {
        \evale{\efun{\code{f}\ \code{m}}{\eappfo{\code{f}}{\code{m}}}}
        {\clov{\code{f}\ \code{m}}{\eappfo{\code{f}}{\code{m}}}{\emptyset}} \\
        \evale{\efun{\cx}{\cx}}{\clov{\cx}{\cx}{\emptyset}} \\
        \evale{8}{8} \\
        \inferrule
        {
          \inferrule
          { \cf\in\dom{\sigma_1} }
          { \eval{\sigma_1}{\code{f}}{\clov{\cx}{\cx}{\emptyset}} }
          \\
          \inferrule
          { \code{m}\in\dom{\sigma_1} }
          { \eval{\sigma_1}{\code{m}}{8} }
          \\
          \inferrule
          { \cx\in\dom{\sigma_2} }
          { \eval{\sigma_2}{\cx}{8} }
        }
        { \eval{\sigma_1}{\eappfo{\code{f}}{\code{m}} }{8} }
      }
      {
        \evale{
          \eappfo{(\efun{\code{f}\
          \code{m}}{\eappfo{\code{f}}{\code{m}}})}{\efun{\cx}{\cx},8}
        }{8}
      }
    \]
\end{enumerate}

\textbf{\refex{first-class-functions-js-app}}
\begin{enumerate}
  \item
    \[
      \eval{\sigma,\alpha}{\efun{x_1\cdots x_n}{e}}{\clov{x_1\cdots x_n}{e}{\sigma}}
    \]
    \[
      \tiny
      \inferrule
      {
        \eval{\sigma,\alpha}{e_0}{\clov{x_1\cdots x_m}{e}{\sigma'}}\\
        \eval{\sigma,\alpha}{e_1}{v_1}\quad\cdots\quad\eval{\sigma,\alpha}{e_n}{v_n}\\
        \eval{\sigma'[x_1\mapsto v_1,\cdots,x_{\min(m,n)}\mapsto v_{\min(m,n)},
        x_{\min(m,n)+1}\mapsto\textsf{undefined},\cdots,x_m\mapsto\textsf{undefined}],
        [v_1,\cdots,v_n]}{e}{v}
      }
      { \eval{\sigma,\alpha}{\eappfo{e_0}{e_1,\cdots,e_n}}{v} }
    \]
    \[
      \inferrule
      { \eval{\sigma,\alpha}{e}{n} \\ 0\le n<\embox{Length}(\alpha) }
      { \eval{\sigma,\alpha}{\textsf{get}\ e}{\alpha[n]} }
    \]
  \item
    \[
      \tiny
      \inferrule
      {
        \eval
        {\emptyset,[]}
        {\efun{\cx\ \cy}{\textsf{get}\ \cx}}
        {\clov{\cx\ \cy}{\textsf{get}\ \cx}{\emptyset}}
        \\
        \eval{\emptyset,[]}{2}{2} \\
        \eval{\emptyset,[]}{19}{19} \\
        \eval{\emptyset,[]}{141}{141} \\
        \inferrule
        {
          \inferrule
          { \cx\in\dom{[\cx\mapsto2,\cy\mapsto19]} }
          { \eval{[\cx\mapsto2,\cy\mapsto19],[2,19,141]}{\cx}{2} }
          \\
          0\le2<\embox{Length}([2,19,141])
        }
        {
          \eval
          {[\cx\mapsto2,\cy\mapsto19],[2,19,141]}
          {\textsf{get}\ \cx}
          {141}
        }
      }
      {
        \eval
        {\emptyset,[]}
        {\eappfo{(\efun{\cx\ \cy}{\textsf{get}\ \cx})}{2,19,141}}
        {141}
      }
    \]
\end{enumerate}

\textbf{\refex{first-class-functions-subst}}
\newcommand{\evals}[2]{#1\Rightarrow#2}
\begin{enumerate}
  \item
    \[
      \evals{n}{n}
    \]

    \[
      \evals{\efun{x}{e}}{\efun{x}{e}}
    \]

    \[
      \inferrule
      { \evals{e_1}{\efun{x}{e}} \\
        \evals{e_2}{v_2} \\
        \evals{e[x/v_2]}{v} }
      { \evals{\eapp{e_1}{e_2}}{v} }
    \]
  \item
      \[
        \begin{array}{rcl}
          n[x/v] &=& n \\
          x'[x/v] &=& v \quad \text{if}\ x=x' \\
          x'[x/v] &=& x' \quad \text{if}\ x\not=x' \\
          (\efun{x'}{e})[x/v] &=& \efun{x'}{e} \quad \text{if}\ x=x' \\
          (\efun{x'}{e})[x/v] &=& \efun{x'}{e[x/v]} \quad \text{if}\ x\not=x' \\
          (\eapp{e_1}{e_2})[x/v] &=& \eapp{e_1[x/v]}{e_2[x/v]} \\
        \end{array}
      \]
  \item
    \begin{enumerate}
        \item 0
        \item error
    \end{enumerate}
  \item
\begin{verbatim}
case Fun(y, b) =>
  if (y == x)
    Fun(y, b)
  else {
    val ny = fresh(binding(b) ++ free(b) ++ free(v) + x)
    Fun(ny, subst(subst(b, y, Id(ny)), x, v))
  }
\end{verbatim}
\end{enumerate}

\textbf{\refex{first-class-functions-js-record}}
\begin{enumerate}
  \item
      \[
        \inferrule
        { \evald{e_1}{v_1} \\\cdots\\ \evald{e_n}{v_n} }
        { \evald{\{l_1:e_1,\cdots,l_n:e_n\}}{\langle l_1:v_1,\cdots,l_n:v_n\rangle} }
      \]

      \[
        \inferrule
        { \evald{e}{\langle\cdots,l:v,\cdots\rangle} }
        { \evald{e.l}{v} }
      \]

      \[
        \inferrule
        {
          \evald{e}{\langle l_1:v_1,\cdots,l_n:v_n\rangle} \\
          l\not\in\{l_1,\cdots,l_n\} \\
          l_i=\code{proto} \\
          \evald{v_i.l}{v}
        }
        { \evald{e.l}{v} }
      \]

      \[
        \inferrule
        {
          \evald{e}{\langle l_1:v_1,\cdots,l_n:v_n\rangle} \\
          l\not\in\{l_1,\cdots,l_n\} \\
          \code{proto}\not\in\{l_1,\cdots,l_n\}
        }
        { \evald{e.l}{\textsf{undefined}} }
      \]

      \[
        \inferrule
        {
          \evald{e_1}{v_1} \\
          \evald{v_1.l}{\clov{x}{e}{\sigma'}} \\
          \evald{e_2}{v_2} \\
          \eval{\sigma'[\code{this}\mapsto v_1,x\mapsto v_2]}{e}{v}
        }
        { \evald{e_1.l(e_2)}{v} }
      \]
  \item
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          { \eval{\emptyset}{1}{1} }
          { \eval{\emptyset}{\{\code{x}:1\}}{\langle\code{x}:1\rangle} }
        }
        { \eval
          {\emptyset}
          {\{\code{proto}:\{\code{x}:1\}\}}
          {\langle\code{proto}:\langle\code{x}:1\rangle\rangle}
        } \\
        \code{x}\not\in\{\code{proto}\} \\
        \code{proto}=\code{proto} \\
        \inferrule
        { \evald{\langle\code{x}:1\rangle}{\langle\code{x}:1\rangle} }
        { \evald{\langle\code{x}:1\rangle.\code{x}}{1} }
      }
      { \eval{\emptyset}{\{\code{proto}:\{\code{x}:1\}\}.\code{x}}{1} }
    \]
  \item
    $\efun{\code{x}}{\code{this}.\code{a}}$
\end{enumerate}

\textbf{\refex{first-class-functions-exc}}
\begin{enumerate}
    \item
    \[
      \evald{n}{n}
    \]

    \[
      \inferrule
      { x\in\dom{\sigma} }
      { \evald{x}{\sigma(x)} }
    \]

    \[
      \evald{\efun{x}{e}}{\clov{x}{e}{\sigma}}
    \]

    \[
      \inferrule
      { \evald{e_1}{\textsf{exc}} }
      { \evald{e_1+e_2}{\textsf{exc}} }
    \]

    \[
      \inferrule
      { \evald{e_1}{v} \\
        \evald{e_2}{\textsf{exc}} }
      { \evald{e_1+e_2}{\textsf{exc}} }
    \]

    \[
      \inferrule
      { \evald{e_1}{n_1} \\
        \evald{e_2}{n_2} }
      { \evald{e_1+e_2}{n_1+n_2} }
    \]

    \[
      \inferrule
      { \evald{e_1}{\textsf{exc}} }
      { \evald{e_1\ e_2}{\textsf{exc}} }
    \]

    \[
      \inferrule
      { \evald{e_1}{v} \\
        \evald{e_2}{\textsf{exc}} }
      { \evald{e_1\ e_2}{\textsf{exc}} }
    \]

    \[
      \inferrule
      { \evald{e_1}{\clov{x}{e}{\sigma'}} \\
        \evald{e_2}{v_2} \\
        \eval{\sigma'[x\mapsto v_2]}{e}{r}
      }
      { \evald{\eapp{e_1}{e_2}}{r} }
    \]

    \[
      \evald{\textsf{throw}}{\textsf{exc}}
    \]

    \[
      \inferrule
      { \evald{e_1}{v} }
      { \evald{\textsf{try}\ e_1\ \textsf{catch}\ e_2}{v} }
    \]

    \[
      \inferrule
      { \evald{e_1}{\textsf{exc}} \\ \evald{e_2}{r} }
      { \evald{\textsf{try}\ e_1\ \textsf{catch}\ e_2}{r} }
    \]
    \item
  \[
    \inferrule
    {
      \inferrule
      {
        \evale{1}{1} \\
        \evale{\textsf{throw}}{\textsf{exc}}
      }
      { \evale{1 + \textsf{throw}}{\textsf{exc}} } \\
      \inferrule
      { \evale{\textsf{throw}}{\textsf{exc}} }
      { \evale{\textsf{throw} + 2}{\textsf{exc}} } \\
    }
    { \evale{\textsf{try}\ (1 + \textsf{throw})\ \textsf{catch}\ (\textsf{throw} + 2)}{\textsf{exc}} }
  \]
\end{enumerate}

\textbf{\refex{recursion-arrow}}

$
\begin{array}{@{}l@{}}
  \ebind{\cf_A}{\efun{\cx_B}{\eifz{\cx_C}{0}{(\eapp{\cf_D}{(\esub{\cx_E}{1})})}}}{ \\
  \erec{\cf_F}{\cx_G}{\eifz{\cx_H}{0}{(\eapp{\cf_I}{(\esub{\cx_J}{1})})}}{ \\
  \eapp{\cf_K}{\cy_L}
  }
  }
\end{array}
$
\begin{enumerate}
  \item $C\rightarrow B,E\rightarrow B,H\rightarrow G,I\rightarrow
    F,J\rightarrow G,K\rightarrow F$
  \item $D,L$
\end{enumerate}

\textbf{\refex{recursion-bindings}}
\vspace{-1em}
\begin{verbatim}
case Num(n) => Set()
case Id(x) => Set()
case Val(x, e, b) => (bindings(e) ++ bindings(b)) + x
case App(f, a) => bindings(f) ++ bindings(a)
case Fun(x, b) => bindings(b) + x
case Rec(f, x, b, e) => bindings(b) ++ bindings(e) + f + x

case Num(n) => Set()
case Id(x) => Set(x)
case Val(x, e, b) => frees(e) ++ (frees(b) - x)
case App(f, a) => frees(f) ++ frees(a)
case Fun(x, b) => frees(b) - x
case Rec(f, x, b, e) => (frees(b) - f - x) ++ (frees(e) - f)
\end{verbatim}

\textbf{\refex{recursion-scope}}
\begin{enumerate}
    \item Does not terminate
    \item 49
\end{enumerate}

\textbf{\refex{recursion-eager-if}}

$\eifz{0}{0}{(\eapp{0}{0})}$
\\

\textbf{\refex{recursion-bool}}
\[ \evald{b}{b} \]

\[
  \inferrule
  { \evald{e_1}{v_1} \\ \evald{e_2}{v_2} }
  { \evald{e_1\wedge e_2}{v_1\wedge v_2} }
\]

\[
  \inferrule
  { \evald{e}{v} }
  { \evald{\neg e}{\neg v} }
\]

\[
  \inferrule
  { \evald{e_1}{\true} \\ \evald{e_2}{v_2} }
  { \evald{\eif{e_1}{e_2}{e_3}}{v_2} }
\]

\[
  \inferrule
  { \evald{e_1}{\false} \\ \evald{e_3}{v_3} }
  { \evald{\eif{e_1}{e_2}{e_3}}{v_3} }
\]

\textbf{\refex{recursion-racket-if}}
\newcommand{\eand}[2]{\textsf{and}\ #1\ #2}
\newcommand{\eor}[2]{\textsf{or}\ #1\ #2}
\begin{enumerate}
  \item
    \[
      { \evald{b}{b} }
    \]

    \[
      \inferrule
      { \evald{e_1}{v_1} \\ v_1\not={\false} \\ \evald{e_2}{v_2} }
      { \evald{\eif{e_1}{e_2}{e_3}}{v_2} }
    \]

    \[
      \inferrule
      { \evald{e_1}{\false} \\ \evald{e_3}{v_3} }
      { \evald{\eif{e_1}{e_2}{e_3}}{v_3} }
    \]

    \[
      \inferrule
      { \evald{e_1}{\false} }
      { \evald{\eand{e_1}{e_2}}{\false} }
    \]

    \[
      \inferrule
      { \evald{e_1}{v_1} \\ v_1\not={\false} \\ \evald{e_2}{v_2} }
      { \evald{\eand{e_1}{e_2}}{v_2} }
    \]

    \[
      \inferrule
      { \evald{e_1}{v_1} \\ v_1\not={\false} }
      { \evald{\eor{e_1}{e_2}}{v_1} }
    \]

    \[
      \inferrule
      { \evald{e_1}{\false} \\ \evald{e_2}{v_2}}
      { \evald{\eor{e_1}{e_2}}{v_2} }
    \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        {
          \eval{\emptyset}{\false}{\false} \\
          \eval{\emptyset}{2}{2}
        }
        { \eval{\emptyset}{\eor{\false}{2}}{2} } \\
        2\not={\false} \\
        \inferrule
        { \eval{\emptyset}{\false}{\false} }
        { \eval{\emptyset}{\eand{\false}{2}}{\false} } \\
      }
      { \eval{\emptyset}{\eif{(\eor{\false}{2})}{(\eand{\false}{2})}{1}}{\false} }
    \]
\end{enumerate}

\textbf{\refex{recursion-fix-nont}}

Change $\ebind{\code{g}}{\eapp{\cy}{\cy}}{}$to
$\ebind{\code{g}}{\efun{\cx}{\eapp{\eapp{\cy}{\cy}}{\cx}}}{}$\!.
\\

\textbf{\refex{recursion-fix-free}}

Change $\ebind{\cf}{\eapp{\cz}{({\efun{\cv}{\sumbodyfv}})}}{}$to
$\ebind{\cf}{\eapp{\cz}{({\efun{\cf}{\efun{\cv}{\sumbodyfv}}})}}{}$\!.
\\

\textbf{\refex{recursion-sum-arrow}}

$\begin{array}{l}
  \ebind{\cf_A}{(\\
  \ \ \ \ \ebind{\cx_B}{\efun{\cy_C}{(\\
  \ \ \ \ \ \ \ \ \ebind{\cf_D}{\efun{\cv_E}{\eapp{\eapp{\cy_F}{\cy_G}}{\cv_H}}}{\\
  \ \ \ \ \ \ \ \ \efun{\cv_I}{\eifz{\cv_J}{0}{(\eadd{\cv_K}{\eapp{\cf_L}{(\esub{\cv_M}{1})}})}}}\\
  \ \ \ \ )}}{\\
  \ \ \ \ \eapp{\cx_N}{\cx_O}\\
  )}}{\\
  \eapp{\cf_P}{10}
  }
\end{array}$
\begin{enumerate}
  \item $F\rightarrow C,G\rightarrow C,H\rightarrow E,J\rightarrow I,
    K\rightarrow I,L\rightarrow D,M\rightarrow I,N\rightarrow B,
    O\rightarrow B,P\rightarrow A$
  \item No shadowing
  \item
    $e={\ebind{\cf}{\efun{\cv}{\eapp{\eapp{\cy}{\cy}}{\cv}}}{\efun{\cv}{\sumbodyfv}}}$
    \\
    $\clov{\cv}{\sumbodyfv}{[
      \cy\mapsto\clov{\cy}{e}{\emptyset},
      \cf\mapsto\clov{\cv}{\eapp{\eapp{\cy}{\cy}}{\cv}}{[\cy\mapsto\clov{\cy}{e}{\emptyset}]}
    ]}$

\end{enumerate}

\textbf{\refex{recursion-describe}}

An argument to $\cz$ must be a function whose fixed point is a recursive function
to be constructed. For example, to make the $\embox{sum}$ function with $\cz$,
its argument must be a function that returns $\embox{sum}$ when $\embox{sum}$ is
given.
\\

\textbf{\refex{recursion-mutual}}

$\begin{array}{@{}l@{}}
  \ebind{\cz}{(\efun{\cb}{\\
  \ \ \ \ \ebind{\code{fx}}{(\efun{\code{fy}}{\\
  \ \ \ \ \ \ \ \ \ebind{\cf}{\efun{\cx}{(\eapp{\code{fy}}{\code{fy}})\textsf{.1}\ \cx}}{\\
  \ \ \ \ \ \ \ \ \ebind{\code{g}}{\efun{\cx}{(\eapp{\code{fy}}{\code{fy}})\textsf{.2}\ \cx}}{\\
  \ \ \ \ \ \ \ \ \eapp{\cb}{(\cf,\code{g})}}}}\\\ \ \ \ )}{\\
  \ \ \ \ \eapp{\code{fx}}{\code{fx}}}}\\)}{\\
  \ebind{\cf}{\eapp{\cz}{\efun{\cf}{(
    \efun{\code{n}}{\eifz{\code{n}}{\true}{(\eapp{\cf\textsf{.2}}{(\esub{\code{n}}{1})})}},
    \efun{\code{n}}{\eifz{\code{n}}{\false}{(\eapp{\cf\textsf{.1}}{(\esub{\code{n}}{1})})}}
  )}}}{\\
  \ebind{\code{even}}{\cf\textsf{.1}}{\\
  \ebind{\code{odd}}{\cf\textsf{.2}}{\\
  (\eapp{\code{even}}{10}, \eapp{\code{odd}}{10})}}}}
\end{array}$
\\

\textbf{\refex{mutable-boxes-trace}}

$
\begin{array}{@{}c|c|c|c@{}}
  \text{expr} & \text{env} & \text{sto} & \text{res} \\\hline
  \eapp{(\efun{\cx}{\eapp{(\efun{\cy}{\eseq{\eset{\cx}{8}}{\ederef{\cy}}})}{\cx}})}{\eref{7}}
  & \emptyset & \emptyset & (8,[a_1\mapsto8]) \\
  \efun{\cx}{\eapp{(\efun{\cy}{\eseq{\eset{\cx}{8}}{\ederef{\cy}}})}{\cx}}
  & \emptyset & \emptyset &
  (\clov{\cx}{\eapp{(\efun{\cy}{\eseq{\eset{\cx}{8}}{\ederef{\cy}}})}{\cx}}{\emptyset},\emptyset) \\
  \eref{7} & \emptyset & \emptyset & (a_1,[a_1\mapsto7]) \\
  7 & \emptyset & \emptyset & (7,\emptyset) \\
  \eapp{(\efun{\cy}{\eseq{\eset{\cx}{8}}{\ederef{\cy}}})}{\cx} &
  [\cx\mapsto a_1] & [a_1\mapsto7] & (8,[a_1\mapsto8]) \\
  \efun{\cy}{\eseq{\eset{\cx}{8}}{\ederef{\cy}}} &
  [\cx\mapsto a_1] & [a_1\mapsto7] &
  (\clov{\cy}{\eseq{\eset{\cx}{8}}{\ederef{\cy}}}{[\cx\mapsto a_1]},[a_1\mapsto7]) \\
  \cx & [\cx\mapsto a_1] & [a_1\mapsto7] & (a_1,[a_1\mapsto7]) \\
  \eseq{\eset{\cx}{8}}{\ederef{\cy}} & [\cx\mapsto a_1,\cy\mapsto a_1]
  & [a_1\mapsto7] & (8,[a_1\mapsto8]) \\
  \eset{\cx}{8} & [\cx\mapsto a_1,\cy\mapsto a_1] & [a_1\mapsto7]
  & (8,[a_1\mapsto8]) \\
  8 & [\cx\mapsto a_1,\cy\mapsto a_1] & [a_1\mapsto7] & (8,[a_1\mapsto7]) \\
  \ederef{\cy} & [\cx\mapsto a_1,\cy\mapsto a_1] & [a_1\mapsto8]
  & (8,[a_1\mapsto8]) \\
  \cy & [\cx\mapsto a_1,\cy\mapsto a_1] & [a_1\mapsto8] & (a_1,[a_1\mapsto8]) \\
\end{array}
$
\\

\textbf{\refex{mutable-boxes-desugar}}
\vspace{-1em}
\begin{verbatim}
App(Fun(fresh(free(r)), desugar(r)), desugar(l))
\end{verbatim}

\textbf{\refex{mutable-boxes-landin}}

$\begin{array}{l}
  \ebind{\cz}{\efun{\cb}{(\\
  \ \ \ \ \ebind{\ca}{\eref{\efun{\cx}{\cy}}}{\\
  \ \ \ \ \ebind{\cf}{(\eapp{\cb}{\efun{\cx}{\eapp{\ederef{\ca}}{\cx}}})}{\\
  \ \ \ \ \eseq{\eset{\ca}{\cf}}{\\
  \ \ \ \ \cf\\
  }}})}}{\\
  \ebind{\cf}{\eapp{\cz}{(\efun{\cf}{\efun{\cv}{\sumbodyfv}})}}{\\
  \eapp{\cf}{10}}}
\end{array}$
\\

\textbf{\refex{mutable-variables-trace}}

$
\begin{array}{@{}c|c|c@{}}
  \text{expr} & \text{env} & \text{sto} \\\hline
  \eapp{(\efun{\cx}{\cx})}{(\eapp{(\efun{\cx}{\cx})}{1})} & \emptyset & \emptyset \\
  \efun{\cx}{\cx} & \emptyset & \emptyset \\
  \eapp{(\efun{\cx}{\cx})}{1} & \emptyset & \emptyset \\
  \efun{\cx}{\cx} & \emptyset & \emptyset \\
  1 & \emptyset & \emptyset \\
  \cx & [\cx\mapsto a_1] & [a_1\mapsto1] \\
  \cx & [\cx\mapsto a_2] & [a_1\mapsto1,a_2\mapsto1] \\
\end{array}
$
\\

\textbf{\refex{mutable-variables-cbr}}
\begin{enumerate}
  \item CBR
  \item
    $[\code{n} \mapsto a_1, \cf \mapsto a_2, \cx \mapsto a_4]$,\\
$[
    a_1 \mapsto 42,
    a_2 \mapsto \clov{\code{g}}{\eapp{\code{g}}{\code{n}}}{[\code{n} \mapsto a_1]},
    a_3 \mapsto \clov{\cx}{\eadd{\cx}{8}}{[\code{n} \mapsto a_1, \code{f} \mapsto a_2]},
    a_4 \mapsto 42
]$
  \item
    $[\code{n} \mapsto a_1, \cf \mapsto a_2, \cx \mapsto a_1]$,\\
$[
    a_1 \mapsto 42,
    a_2 \mapsto \clov{\code{g}}{\eapp{\code{g}}{\code{n}}}{[\code{n} \mapsto a_1]},
    a_3 \mapsto \clov{\cx}{\eadd{\cx}{8}}{[\code{n} \mapsto a_1, \code{f} \mapsto a_2]}
]$
\end{enumerate}

\textbf{\refex{mutable-variables-record}}
\begin{enumerate}
  \item
\begin{verbatim}
val (RecV(fields), rs) = interp(r, env, fs)
interp(b, fenv + (x -> fields(f)), rs)
\end{verbatim}
  \item 2,
    $[a_1 \mapsto 2, a_2 \mapsto \{\cz{:}a_1\}, a_3 \mapsto \clov{\cy}{\eset{\cy}{2}}{[\cx \mapsto a_2]}]$
  \item 1,
    $[a_1 \mapsto 1, a_2 \mapsto \{\cz{:}a_1\}, a_3 \mapsto \clov{\cy}{\eset{\cy}{2}}{[\cx \mapsto a_2]}, a_4 \mapsto 2]$
\end{enumerate}

\textbf{\refex{mutable-variables-ptr}}
\begin{enumerate}
    \item
\[
  \inferrule
  { \sevald{}{e}{a}{1} \\ a\in\dom{M_1} }
  { \sevald{}{\ast e}{M_1(a)}{1} }
\]

\[
  \inferrule
  { x\in\dom{\sigma} }
  { \sevald{}{\&x}{\sigma(x)}{} }
\]

\[
  \inferrule
  { \sevald{}{e_2}{v}{1} \\ \sevald{1}{e_1}{a}{2} }
  { \seval{\sigma}{M}{\ast\eset{e_1}{e_2}}{v}{M_2[a\mapsto v]} }
\]
\item
\begin{verbatim}
case Deref(p) =>
  val (pv, ps) = interp(p, env, sto)
  val PtrV(a) = pv
  (ps(a), ps)
case Ref(x) => (PtrV(env(x)), sto)
case Assign(p, e) =>
  val (ev, es) = interp(e, env, sto)
  val (pv, ps) = interp(p, env, es)
  val PtrV(a) = pv
  (ev, ps + (a -> ev))
\end{verbatim}
\end{enumerate}

\textbf{\refex{mutable-variables-imp}}
\begin{enumerate}
  \item
    \[
      { \evald{\eskip}{\sigma} }
    \]

    \[
      \inferrule
      { \evald{e}{v} }
      { \evald{\eset{x}{e}}{\sigma[x\mapsto v]} }
    \]

    \[
      \inferrule
      { \evald{e}{0} \\ \evald{c_1}{\sigma_1} }
      { \evald{\eifz{e}{c_1}{c_2}}{\sigma_1} }
    \]

    \[
      \inferrule
      { \evald{e}{v} \\ v\not=0 \\ \evald{c_2}{\sigma_2} }
      { \evald{\eifz{e}{c_1}{c_2}}{\sigma_2} }
    \]

    \[
      \inferrule
      { \evald{e}{0} \\ \evald{c}{\sigma_1} \\ \eval{\sigma_1}{\ewhilez{e}{c}}{\sigma_2} }
      { \evald{\ewhilez{e}{c}}{\sigma_2} }
    \]

    \[
      \inferrule
      { \evald{e}{v} \\ v\not=0 }
      { \evald{\ewhilez{e}{c}}{\sigma} }
    \]

    \[
      \inferrule
      { \evald{c_1}{\sigma_1} \\ \eval{\sigma_1}{c_2}{\sigma_2} }
      { \evald{\eseq{c_1}{c_2}}{\sigma_2} }
    \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        { \eval{\emptyset}{0}{0} }
        { \eval{\emptyset}{\eset{{\cx}}{0}}{[{\cx}\mapsto0]} }
        \\
        \inferrule
        {
          \inferrule
          { {\cx}\in\dom{[{\cx}\mapsto0]} }
          { \eval{[{\cx}\mapsto0]}{{\cx}}{0} }
          \quad
          \inferrule
          {}
          { \eval{[{\cx}\mapsto0]}{{\eskip}}{[{\cx}\mapsto0]} }
        }
        { \eval{[{\cx}\mapsto0]}
          {\eseq{\eifz{{\cx}}{{\eskip}}{\eset{{\cx}}{1}}}}
          {[{\cx}\mapsto0]} }
      }
      { \eval{\emptyset}
        {\eseq{\eset{{\cx}}{0}}{\eifz{{\cx}}{{\eskip}}{\eset{{\cx}}{1}}}}
        {[{\cx}\mapsto0]}
      }
    \]
\end{enumerate}

\textbf{\refex{garbage-collection-copying}}

\begin{itemize}
  \item Stack: \code{13}
\item From space:
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|@{\hskip0pt}c@{\hskip0pt}|}
 \hline
 {1}&{2}&{2}&{3}&{7}&{99}&{19}&{99}&{16}&{10}&{99}&{13}&{5}\\
 \hline \multicolumn{1}{c}{}\\[-16pt]
  \multicolumn{1}{c}{\tiny \code{0}}&
  \multicolumn{1}{c}{\tiny \code{1}}&
  \multicolumn{1}{c}{\tiny \code{2}}&
  \multicolumn{1}{c}{\tiny \code{3}}&
  \multicolumn{1}{c}{\tiny \code{4}}&
  \multicolumn{1}{c}{\tiny \code{5}}&
  \multicolumn{1}{c}{\tiny \code{6}}&
  \multicolumn{1}{c}{\tiny \code{7}}&
  \multicolumn{1}{c}{\tiny \code{8}}&
  \multicolumn{1}{c}{\tiny \code{9}}&
  \multicolumn{1}{c}{\tiny \code{10}}&
  \multicolumn{1}{c}{\tiny \code{11}}&
  \multicolumn{1}{c}{\tiny \code{12}}
 \\
\end{tabular}
\item To space:
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|@{\hskip0pt}c@{\hskip0pt}|}
 \hline
 {3}&{16}&{5}&{4}&{19}&{13}&{1}&{4}&{0}&{0}&{0}&{0}&{0}\\
 \hline \multicolumn{1}{c}{}\\[-16pt]
  \multicolumn{1}{c}{\tiny \code{13}}&
  \multicolumn{1}{c}{\tiny \code{14}}&
  \multicolumn{1}{c}{\tiny \code{15}}&
  \multicolumn{1}{c}{\tiny \code{16}}&
  \multicolumn{1}{c}{\tiny \code{17}}&
  \multicolumn{1}{c}{\tiny \code{18}}&
  \multicolumn{1}{c}{\tiny \code{19}}&
  \multicolumn{1}{c}{\tiny \code{20}}&
  \multicolumn{1}{c}{\tiny \code{21}}&
  \multicolumn{1}{c}{\tiny \code{22}}&
  \multicolumn{1}{c}{\tiny \code{23}}&
  \multicolumn{1}{c}{\tiny \code{24}}&
  \multicolumn{1}{c}{\tiny \code{25}}
 \\
\end{tabular}
\end{itemize}

\textbf{\refex{lazy-evaluation-trace}}
\begin{itemize}
  \item Call-by-name\\
$
\begin{array}{@{}c|c@{}}
  \text{expr} & \text{env} \\\hline
  \eapp{(\efun{\cx}{\eadd{\cx}{\cx}})}{(\eadd{1}{2})} & \emptyset \\
  \efun{\cx}{\eadd{\cx}{\cx}} & \emptyset \\
  \eadd{\cx}{\cx} & [\cx\mapsto\exprv{\eadd{1}{2}}{\emptyset}] \\
  \cx & [\cx\mapsto\exprv{\eadd{1}{2}}{\emptyset}] \\
  \eadd{1}{2} & \emptyset \\
  1 & \emptyset \\
  2 & \emptyset \\
  \cx & [\cx\mapsto\exprv{\eadd{1}{2}}{\emptyset}] \\
  \eadd{1}{2} & \emptyset \\
  1 & \emptyset \\
  2 & \emptyset \\
\end{array}
$
  \item Call-by-need\\
$
\begin{array}{@{}c|c@{}}
  \text{expr} & \text{env} \\\hline
  \eapp{(\efun{\cx}{\eadd{\cx}{\cx}})}{(\eadd{1}{2})} & \emptyset \\
  \efun{\cx}{\eadd{\cx}{\cx}} & \emptyset \\
  \eadd{\cx}{\cx} & [\cx\mapsto(\eadd{1}{2},\emptyset,\cdot)] \\
  \cx & [\cx\mapsto(\eadd{1}{2},\emptyset,\cdot)] \\
  \eadd{1}{2} & \emptyset \\
  1 & \emptyset \\
  2 & \emptyset \\
  \cx & [\cx\mapsto(\eadd{1}{2},\emptyset,3)] \\
\end{array}
$
\end{itemize}

\textbf{\refex{lazy-evaluation-eval}}
\begin{enumerate}
  \item CBV: error, CBN: error
  \item CBV: error, CBN: 10
  \item CBV: error, CBN: error
  \item CBV: error, CBN: $\exprv{\eadd{1}{\efun{\cx}{\cx}}}{\emptyset}$
  \item CBV: error, CBN: 3
  \item CBV: error, CBN: error
  \item CBV: error, CBN: 8
  \item CBV: $\clov{\cx}{(\eapp{(\efun{\cy}{42})}{(\eapp{9}{2})})}{\emptyset}$,
    CBN: $\clov{\cx}{(\eapp{(\efun{\cy}{42})}{(\eapp{9}{2})})}{\emptyset}$
  \item CBV: error, CBN: error
  \item CBV: error, CBN: 15
\end{enumerate}

\textbf{\refex{lazy-evaluation-scope}}
\begin{enumerate}
  \item error
  \item 12
  \item error
  \item error
\end{enumerate}

\textbf{\refex{lazy-evaluation-strict}}

$\eapp{(\efun{\cy}{\eapp{(\efun{\cx}{\eadd{\cx}{0}})}{\cy}})}{0}$
\\

\textbf{\refex{lazy-evaluation-val}}
\vspace{-1em}
\begin{verbatim}
case Val(x, e, b) =>
  interp(b, env + (x -> ExprV(e, env)))
case If0(c, t, f) =>
  interp(if (strict(interp(c, env)) == NumV(0)) t else f, env)
\end{verbatim}

\textbf{\refex{lazy-evaluation-pair}}
\vspace{-1em}
\begin{verbatim}
case class PairV(f: Value, s: Value) extends Value

case Pair(f, s) => PairV(ExprV(f, env), ExprV(s, env))
case Fst(e) =>
  val PairV(v, _) = strict(interp(e, env))
  v
case Snd(e) =>
  val PairV(_, v) = strict(interp(e, env))
  v
\end{verbatim}

\textbf{\refex{lazy-evaluation-list}}
\vspace{-1em}
\begin{verbatim}
case class ConsV(h: Value, t: Value) extends Value

case Nil => NilV
case Cons(h, t) => ConsV(ExprV(h, env), ExprV(t, env))
case Head(e) =>
  val ConsV(h, _) = strict(interp(e, env))
  strict(h)
case Tail(e) =>
  val ConsV(_, t) = strict(interp(e, env))
  val v = strict(t)
  if (isList(v)) v else error()
\end{verbatim}

\textbf{\refex{lazy-evaluation-racket}}
\begin{enumerate}
  \item
    \[
      \stricte{n}{n}
    \]
    \[
      \inferrule
      {}
      { \stricte{\clov{x}{e}{\sigma}}{\clov{x}{e}{\sigma}} }
    \]
    \[
      \inferrule
      { \evald{e}{v} }
      { \stricte{\delay(e,\sigma)}{v} }
    \]
    \[
      \inferrule
      { \evald{e}{v'} \\ \stricte{v'}{v} }
      { \stricte{\lazy(e,\sigma)}{v} }
    \]
  \item
    \[
      \evald{\delay\ e}{\delay(e,\sigma)}
    \]
    \[
      \inferrule
      {}
      { \evald{\lazy\ e}{\lazy(e,\sigma)} }
    \]
    \[
      \inferrule
      { \evald{e}{v'} \\ \stricte{v'}{v} }
      { \evald{\force\ e}{v} }
    \]
\end{enumerate}

\textbf{\refex{continuations-lfae}}
\vspace{-1em}
\begin{verbatim}
case ExprV(e, env) =>
  interp(e, env, v => strict(v, k))

case Add(l, r) =>
  interp(l, env, v1 =>
    interp(r, env, v2 =>
      strict(v1, n =>
        strict(v2, m => {
          val NumV(l) = n
          val NumV(r) = m
          k(NumV(l + r))
        }))))
case App(f, a) =>
  interp(f, env, v =>
    strict(v, fv => {
      val CloV(x, b, fenv) = fv
      interp(b, fenv + (x -> ExprV(a, env)), k)
    }))
\end{verbatim}

\textbf{\refex{first-class-continuations-result}}
\begin{enumerate}
  \item 3
  \item 6
  \item Error
  \item 5
  \item Does not terminate
\end{enumerate}

\textbf{\refex{first-class-continuations-print}}

$\begin{array}{@{}l}
  \eapp{(\evcc{\cx}{\cx})}{\efun{\cy}{\cy}} \\
  \evcc{\cx}{\cx} \\
  \cx \\
  \efun{\cy}{\cy} \\
  \efun{\cy}{\cy} \\
  \cy \\
\end{array}$
\\

\textbf{\refex{first-class-continuations-reduction}}

$\sigma=[\cx\mapsto\langle\emptyset\vdash8::(+)::\square,\blacksquare\rangle]$
\\
$
\begin{array}{lrcr}
& \emptyset\vdash (\evcc{\cx}{42+(\cx\ 2)})+8::\square &||& \blacksquare \\
\rightarrow & \emptyset\vdash\evcc{\cx}{42+(\cx\ 2)}
  ::\emptyset\vdash8::(+)::\square &||& \blacksquare \\
\rightarrow & \sigma\vdash42+(\cx\ 2)
  ::\emptyset\vdash8::(+)::\square &||& \blacksquare \\
\rightarrow & \sigma\vdash42::\sigma\vdash(\cx\ 2)::(+)
  ::\emptyset\vdash8::(+)::\square &||& \blacksquare \\
\rightarrow & \sigma\vdash(\cx\ 2)::(+)
  ::\emptyset\vdash8::(+)::\square &||& 42::\blacksquare \\
\rightarrow & \sigma\vdash\cx::\sigma\vdash2::(@)::(+)
  ::\emptyset\vdash8::(+)::\square &||& 42::\blacksquare \\
\rightarrow & \sigma\vdash2::(@)::(+)::\emptyset\vdash8::(+)::\square
  &||& \langle\emptyset\vdash8::(+)::\square,\blacksquare\rangle::42::\blacksquare \\
\rightarrow & (@)::(+)::\emptyset\vdash8::(+)::\square
  &||& 2::\langle\emptyset\vdash8::(+)::\square,\blacksquare\rangle::42::\blacksquare \\
\rightarrow & \emptyset\vdash8::(+)::\square &||& 2::\blacksquare \\
\rightarrow & (+)::\square &||& 8::2::\blacksquare \\
\rightarrow & \square &||& 10::\blacksquare \\
\end{array}
$
\\

\textbf{\refex{first-class-continuations-var}}
\vspace{-1em}
\begin{verbatim}
case Num(n) => k(NumV(n), sto)
case Id(x) => k(sto(env(x)), sto)
case Fun(x, b) => k(CloV(x, b, env), sto)
case App(f, a) =>
  interp(f, env, sto, (fv, fs) =>
    interp(a, env, fs, (av, as) => fv match {
      case CloV(x, b, fenv) =>
        val addr = malloc(as)
        interp(b, fenv + (x -> addr), as + (addr -> av), k)
      case ContV(k) => k(av, as)
    })
  )
case Set(x, e) =>
  interp(e, env, sto, (v, s) =>
    k(v, s + (env(x) -> v))
  )
case Vcc(x, b) =>
  val addr = malloc(sto)
  interp(b, env + (x -> addr), sto + (addr -> ContV(k)), k)
\end{verbatim}

\textbf{\refex{first-order-representation-of-continuations-val}}
\vspace{-1em}
\begin{verbatim}
case class ValSecondK(x: String, b: Expr, env: Env, k: Cont) extends Cont
case class If0SecondK(t: Expr, f: Expr, env: Env, k: Cont) extends Cont

case ValSecondK(x, b, env, k) => interp(b, env + (x -> v), k)
case If0SecondK(t, f, env, k) => interp(if (v == NumV(0)) t else f, env, k)

case Val(x, e, b) => interp(e, env, ValSecondK(x, b, env, k))
case If0(c, t, f) => interp(c, env, If0SecondK(t, f, env, k))
\end{verbatim}

\textbf{\refex{first-order-representation-of-continuations-pair}}
\vspace{-1em}
\begin{verbatim}
case class PairSecondK(s: Expr, env: Env, k: Cont) extends Cont
case class DoPairK(fv: Value, k: Cont) extends Cont
case class DoFstK(k: Cont) extends Cont
case class DoSndK(k: Cont) extends Cont

case PairSecondK(s, env, k) => interp(s, env, DoPairK(v, k))
case DoPairK(fv, k) => continue(k, PairV(fv, v))
case DoFstK(k) =>
  val PairV(fv, _) = v
  continue(k, fv)
case DoSndK(k) =>
  val PairV(_, sv) = v
  continue(k, sv)

case Pair(f, s) => interp(f, env, PairSecondK(s, env, k))
case Fst(p) => interp(p, env, DoFstK(k))
case Snd(p) => interp(p, env, DoSndK(k))
\end{verbatim}

\textbf{\refex{nameless-representation-of-expressions-trans}}

$\eapp{\eapp{\eapp{(\efun{}{\efun{}{\efun{}{\eadd{(\esub{\underline{0}}{\underline{2}})}{\underline{1}}}}})}{42}}{0}}{10}$
\\

\textbf{\refex{nameless-representation-of-expressions-detrans}}

$\efun{\cx}{\efun{\cy}{\efun{\cz}{\eapp{\eapp{\cz}{\cy}}{\cz}}}}$
\\

\textbf{\refex{type-systems-unsound}}

$\eadd{1}{\cx}$
\\

\textbf{\refex{type-systems-list}}

\[
  \typeofd{\textsf{nil}[\tau]}{\textsf{list}\ \tau}
\]

\[
  \inferrule
  { \typeofd{e_1}{\tau} \\ \typeofd{e_2}{\textsf{list}\ \tau} }
  { \typeofd{\textsf{cons}\ e_1\ e_2}{\textsf{list}\ \tau} }
\]

\[
  \inferrule
  { \typeofd{e}{\textsf{list}\ \tau} }
  { \typeofd{\textsf{head}\ e}{\tau} }
\]

\[
  \inferrule
  { \typeofd{e}{\textsf{list}\ \tau} }
  { \typeofd{\textsf{tail}\ e}{\textsf{list}\ \tau} }
\]

\textbf{\refex{type-systems-box}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \typeofd{e}{\tau} }
      { \typeofd{\eref{e}}{\eref{\tau}} }
    \]

    \[
      \inferrule
      { \typeofd{e}{\eref{\tau}} }
      { \typeofd{\ederef{e}}{\tau} }
    \]

    \[
      \inferrule
      { \typeofd{e_1}{\eref{\tau}} \\ \typeofd{e_2}{\tau} }
      { \typeofd{\eset{e_1}{e_2}}{\tau} }
    \]

    \[
      \inferrule
      { \typeofd{e_1}{\tau_1} \\ \typeofd{e_2}{\tau_2} }
      { \typeofd{\eseq{e_1}{e_2}}{\tau_2} }
    \]
  \item
    $\Gamma_1=[\cx:\eref{\tnum}],\Gamma_2=\Gamma_1[\cy:\tnum]$
    \[
      \tiny
      \inferrule
      {
        \inferrule
        { \typeofe{3}{\tnum} }
        { \typeofe{\eref{3}}{\eref{\tnum}} }
        \\
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \inferrule
              { \cx\in\dom{\Gamma_1} }
              { \typeof{\Gamma_1}{\cx}{\eref{\tnum}} }
            }
            { \typeof{\Gamma_1}{\ederef{\cx}}{\tnum} }
            \\
            \typeof{\Gamma_1}{7}{\tnum}
          }
          { \typeof{\Gamma_1}{\ederef{\cx}+7}{\tnum} }
          \\
          \inferrule
          {
            \inferrule
            {
              \inferrule
              { \cx\in\dom{\Gamma_2} }
              { \typeof{\Gamma_2}{\cx}{\eref{\tnum}} }
              \\
              \typeof{\Gamma_2}{8}{\tnum}
            }
            { \typeof{\Gamma_2}{\eset{\cx}{8}}{\tnum} }
            \\
            \inferrule
            {
              \inferrule
              { \cy\in\dom{\Gamma_2}}
              { \typeof{\Gamma_2}{\cy}{\tnum} }
              \\
              \inferrule
              {
                \inferrule
                { \cx\in\dom{\Gamma_2} }
                { \typeof{\Gamma_2}{\cx}{\eref{\tnum}} }
              }
              { \typeof{\Gamma_2}{\ederef{\cx}}{\tnum} }
            }
            { \typeof{\Gamma_2}{\cy+\ederef{\cx}}{\tnum} }
          }
          { \typeof{\Gamma_2}{\eseq{\eset{\cx}{8}}{\cy+\ederef{\cx}}}{\tnum} }
        }
        { \typeof{\Gamma_1}{\ebind{\cy}{\ederef{\cx}+7}{\eseq{\eset{\cx}{8}}{\cy+\ederef{\cx}}}}{\tnum} }
      }
      { \typeofe{\ebind{\cx}{\eref{3}}{\ebind{\cy}{\ederef{\cx}+7}{\eseq{\eset{\cx}{8}}{\cy+\ederef{\cx}}}}}{\tnum} }
    \]

\end{enumerate}

\textbf{\refex{type-systems-var}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { x\in\dom{\Gamma} \\ \typeofd{e}{\Gamma(x)} }
      { \typeofd{\eset{x}{e}}{\Gamma(x)} }
    \]
  \item
    \[
      \inferrule
      { \typeofd{e}{\tau\ast} }
      { \typeofd{\ast e}{\tau} }
    \]

    \[
      \inferrule
      { x\in\dom{\Gamma} }
      { \typeofd{\&x}{\Gamma(x)\ast} }
    \]

    \[
      \inferrule
      { \typeofd{e_1}{\tau\ast} \\ \typeofd{e_2}{\tau} }
      { \typeofd{\ast\eset{e_1}{e_2}}{\tau} }
    \]
\end{enumerate}

\textbf{\refex{typing-recursive-functions-terminate}}

$\erect{\cf}{\cx}{\tnum}{\tarrow{\tnum}{\tnum}}{\eapp{\cf}{\cx}}{\eapp{\cf}{0}}$
\\

\textbf{\refex{typing-recursive-functions-imp}}
\begin{enumerate}
  \item
    \[
      \typeofd{n}{\tnum}
    \]

    \[
      \typeofd{b}{\textsf{bool}}
    \]

    \[
      \inferrule
      { x\in\dom{\Gamma} }
      { \typeofd{x}{\Gamma(x)} }
    \]

    \[
      \inferrule
      { \typeofd{e_1}{\tnum} \\ \typeofd{e_2}{\tnum} }
      { \typeofd{e_1+e_2}{\tnum} }
    \]

    \[
      \inferrule
      { \typeofd{e_1}{\tnum} \\ \typeofd{e_2}{\tnum} }
      { \typeofd{e_1<e_2}{\textsf{bool}} }
    \]
  \item
    \[
      \typeofd{\textsf{skip}}{\Gamma}
    \]

    \[
      \inferrule
      { x\not\in\dom{\Gamma} \\ \typeofd{e}{\tau} }
      { \typeofd{\eset{x}{e}}{\Gamma[x:\tau]} }
    \]

    \[
      \inferrule
      { x\in\dom{\Gamma} \\ \typeofd{e}{\Gamma(x)} }
      { \typeofd{\eset{x}{e}}{\Gamma} }
    \]

    \[
      \inferrule
      { \typeofd{e}{\textsf{bool}} \\
        \typeofd{c_1}{\Gamma_1} \\
        \typeofd{c_2}{\Gamma_1} }
      { \typeofd{\eif{e}{c_1}{c_2}}{\Gamma_1} }
    \]

    \[
      \inferrule
      { \typeofd{e}{\textsf{bool}} \\ \typeofd{c}{\Gamma_1} }
      { \typeofd{\textsf{while}\ e\ c}{\Gamma} }
    \]

    \[
      \inferrule
      { \typeofd{c_1}{\Gamma_1} \\ \typeof{\Gamma_1}{c_2}{\Gamma_2} }
      { \typeofd{\eseq{c_1}{c_2}}{\Gamma_2} }
    \]
\end{enumerate}

\textbf{\refex{algebraic-data-types-eval}}
\begin{enumerate}
  \item 10
  \item 10
\end{enumerate}

\textbf{\refex{algebraic-data-types-norec}}

$\etdef{\code{A}}{\cX}{\code{A}}{\cY}{\tnum}{0}$
\\

\textbf{\refex{algebraic-data-types-nowf}}

$\begin{array}{@{}l}
  \etdef{\cX}{\code{A}}{\code{Y}}{\code{B}}{\tnum}{ \\
  \eapp{( \\
  \ \ \ \ \etdef{\cY}{\code{C}}{\tnum}{\code{D}}{\tnum}{ \\
  \ \ \ \ \efunt{\cx}{\cX}{\ematch{\cx}{ \\
  \ \ \ \ \ \ \ \ \code{A}}{\cy}{\ematch{\cy}{ \\
  \ \ \ \ \ \ \ \ \ \ \ \ \code{C}}{\cz}{0}{ \\
  \ \ \ \ \ \ \ \ \ \ \ \ \code{D}}{\cz}{0}}{ \\
  \ \ \ \ \ \ \ \ \code{B}}{\cy}{0}} \\
  })}{( \\
  \ \ \ \ \etdef{\cY}{\code{E}}{\tnum}{\code{F}}{\tnum}{ \\
  \ \ \ \ \eapp{\code{A}}{(\eapp{\code{E}}{0})} \\
  })}}
\end{array}$

\textbf{\refex{algebraic-data-types-nested}}

$\textsf{Color}$
\[
  \inferrule
  { \typeofd{e}{t} \\
    t\in\dom{\Gamma} \\
    \Gamma(t)=x_1@\tau_1+x_2@\tau_2 \\
    \Gamma'=\Gamma[x_1:\tarrow{\tau_1}{t},x_2:\tarrow{\tau_2}{t}] \\
    \typeof{\Gamma'[x_3:\tau_1]}{e_1}{\tau} \\
    \typeof{\Gamma'[x_4:\tau_2]}{e_2}{\tau} }
  { \typeofd{\ematch{e}{x_1}{x_3}{e_1}{x_2}{x_4}{e_2}}{\tau} }
\]

\textbf{\refex{algebraic-data-types-mult}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \wftd{\tau_1}\\\cdots\\\wftd{\tau_n}\\\wftd{\tau} }
      { \wftd{\tarrow{(\tau_1,\cdots,\tau_n)}{\tau}} }
    \]
  \item
    \[
      \inferrule
      { \wftd{\tau_1}\\\cdots\\\wftd{\tau_n} \\
        \typeof{\Gamma[x_1:\tau_1,\cdots,x_n:\tau_n]}{e}{\tau} }
      { \typeofd{\efun{(x_1{:}\tau_1,\cdots,x_n{:}\tau_n)}{e}}{\tarrow{(\tau_1,\cdots,\tau_n)}{\tau}} }
    \]

    \[
      \inferrule
      { \typeofd{e}{\tarrow{(\tau_1,\cdots,\tau_n)}{\tau}} \\
        \typeofd{e_1}{\tau_1}\\\cdots\\\typeofd{e_n}{\tau_n} }
      { \typeofd{e(e_1,\cdots,e_n)}{\tau} }
    \]

    \[
      \inferrule
      {
        \Gamma'=\Gamma[t=x_1@(\tau_{11},\cdots,\tau_{1m_1})+\cdots+x_n@(\tau_{n1},\cdots,\tau_{nm_n}),
        x_1:\tarrow{(\tau_{11},\cdots,\tau_{1m_1})}{t},\cdots,x_n:\tarrow{(\tau_{n1},\cdots,\tau_{nm_n})}{t}] \\
        \wft{\Gamma'}{\tau_{11}} \\\cdots\\ \wft{\Gamma'}{\tau_{nm_n}} \\
        \typeof{\Gamma'}{e}{\tau}
      }
      { \typeofd{\textsf{type}\
      t=x_1@(\tau_{11},\cdots,\tau_{1m_1})+\cdots+x_n@(\tau_{n1},\cdots,\tau_{nm_n})\
      \textsf{in}\ e}{\tau} }
    \]

    \[
      \inferrule
      {
        \typeofd{e}{t} \\
        t\in\dom{\Gamma} \\
        \Gamma(t)=x_1@(\tau_{11},\cdots,\tau_{1m_1})+\cdots+x_n@(\tau_{n1},\cdots,\tau_{nm_n}) \\
        \typeof{\Gamma[x_{11}:\tau_{11},\cdots,x_{1m_1}:\tau_{1m_1}]}{e_1}{\tau}
        \quad\cdots\quad
        \typeof{\Gamma[x_{n1}:\tau_{n1},\cdots,x_{nm_n}:\tau_{nm_n}]}{e_n}{\tau}
      }
      { \typeofd{e\ \textsf{match}\ x_1(x_{11},\cdots,x_{1m_1})\rightarrow
      e_1,\cdots,x_n(x_{n1},\cdots,x_{nm_n})\rightarrow e_n}{\tau} }
    \]
  \item
    $\Gamma=[\code{Fruit}=\code{Apple}@()+\code{Banana}@(\tarrow{(\code{Fruit})}{\tnum},\code{Fruit})+\code{Cherry}@(\tnum),
        \code{Apple}:\tarrow{()}{\code{Fruit}},
        \code{Banana}:\tarrow{(\tarrow{(\code{Fruit})}{\tnum},\code{Fruit})}{\code{Fruit}},
        \code{Cherry}:\tarrow{(\tnum)}{\code{Fruit}}
        ]$\\
    $\Gamma'=\Gamma[\cf:\tarrow{(\code{Fruit})}{\tnum},\cx:\code{Fruit}]$\\
    $e'={\code{Apple}()\ \textsf{match}\ \code{Apple}()\rightarrow
          42,\code{Banana}(\cf,\cx)\rightarrow\cf(\cx),\code{Cherry}(\cx)\rightarrow\cx}$\\
    $e={\textsf{type}\
    \code{Fruit}=\code{Apple}@()+\code{Banana}@(\tarrow{(\code{Fruit})}{\tnum},\code{Fruit})+
          \code{Cherry}@(\tnum)\ \textsf{in}\ e'
          }$\\
    \[
      \scriptsize
      T:
      \inferrule
      {
        \inferrule
        {
          \inferrule
          { \code{Apple}\in\dom{\Gamma} }
          { \typeofd{\code{Apple}}{\tarrow{()}{\code{Fruit}}} }
        }
        { \typeofd{\code{Apple}()}{\code{Fruit}} }
        \\
        \code{Fruit}\in\dom{\Gamma}
        \\
        \Gamma(\code{Fruit})=\code{Apple}@()+\code{Banana}@(\tarrow{(\code{Fruit})}{\tnum},\code{Fruit})+\code{Cherry}@(\tnum)
        \\
        \typeofd{42}{\tnum}
        \\
        \inferrule
        {
          \inferrule
          { \cf\in\dom{\Gamma'} }
          { \typeof{\Gamma'}{\cf}{\tarrow{(\code{Fruit})}{\tnum}} }
          \\
          \inferrule
          { \cx\in\dom{\Gamma'} }
          { \typeof{\Gamma'}{\cx}{\code{Fruit}} }
        }
        { \typeof{\Gamma'}{\cf(\cx)}{\tnum} }
        \\
        \inferrule
        { \cx\in\dom{\Gamma[\cx:\tnum]} }
        { \typeof{\Gamma[\cx:\tnum]}{\cx}{\tnum} }
      }
      {
        \typeofd{e'}{\tnum}
      }
    \]
    \[
      \scriptsize
      \inferrule
      {
        \Gamma=\Gamma
        \quad
        \inferrule
        {
          \inferrule
          { \code{Fruit}\in\dom{\Gamma} }
          { \wftd{\code{Fruit}} }
          \\
          \wftd{\tnum}
        }
        { \wftd{\tarrow{(\code{Fruit})}{\tnum}} }
        \quad
        \inferrule
        { \code{Fruit}\in\dom{\Gamma} }
        { \wftd{\code{Fruit}} }
        \quad
        \wftd{\tnum}
        \quad
        T
      }
      { \typeofe{e}{\tnum} }
    \]
\end{enumerate}

\textbf{\refex{algebraic-data-types-nonterminate}}

$\begin{array}{@{}l@{}}
  \textsf{type}\ \cX=\code{toX}@(\tarrow{\cX}{\cX}); \\
  \textsf{val}\ \code{fromX}:\tarrow{\cX}{(\tarrow{\cX}{\cX})}=\efunt{\cx}{\cX}{\cx\ \textsf{match}\ \code{toX}(\cf)\rightarrow\cf};\\
  \textsf{val}\ \cf:\cX=\eapp{\code{toX}}{(\efunt{\cx}{\cX}{(\eapp{(\eapp{\code{fromX}}{\cx})}{\cx})})};\\
  \eapp{(\eapp{\code{fromX}}{\cf})}{\cf}
\end{array}$
\\

\textbf{\refex{parametric-polymorphism-typeck}}
\begin{enumerate}
  \item
    $\Gamma_1=[\cf:{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}]$\\
    $\Gamma_2=[\alpha,\cx:\alpha]$\\
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \inferrule
              { \alpha\in\dom{[\alpha]} }
              { \wft{[\alpha]}{\alpha} }
              \\
              \inferrule
              { \alpha\in\dom{[\alpha]} }
              { \wft{[\alpha]}{\alpha} }
            }
            { \wft{[\alpha]}{\tarrow{\alpha}{\alpha}} }
          }
          { \wft{\emptyset}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}} }
          \\
          \inferrule
          {
            \inferrule
            {
              \inferrule
              { \cf\in\dom{\Gamma_1} }
              { \typeof{\Gamma_1}{\cf}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}} }
            }
            { \typeof{\Gamma_1}{\etapp{\cf}{\tnum}}{\tarrow{\tnum}{\tnum}} }
            \\
            \typeof{\Gamma_1}{10}{\tnum}
          }
          { \typeof{\Gamma_1}{\etapp{\cf}{\tnum}\ 10}{\tnum} }
        }
        {
          \typeofe{\efunt{\cf}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}{
          \etapp{\cf}{\tnum}\
          10}}{\tarrow{(\tforall{\alpha}{\tarrow{\alpha}{\alpha}})}{\tnum}}
        }
        \\
        \inferrule
        {
          \inferrule
          {
            \inferrule
            { \alpha\in\dom{[\alpha]} }
            { \wft{[\alpha]}{\alpha} }
            \\
            \inferrule
            { \cx\in\dom{\Gamma_2} }
            { \typeof{\Gamma_2}{\cx}{\alpha} }
          }
          {
            \typeof{[\alpha]}{\efunt{\cx}{\alpha}{\cx}}{\tarrow{\alpha}{\alpha}}
          }
        }
        {
          \typeofe{\etfun{\alpha}{\efunt{\cx}{\alpha}{\cx}}}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}
        }
      }
      { \typeofe{(\efunt{\cf}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}{
        \etapp{\cf}{\tnum}\ 10})\
        (\etfun{\alpha}{\efunt{\cx}{\alpha}{\cx}})}{\tnum} }
    \]
  \item
    $\Gamma_1=[\alpha,\beta]$\\
    $\Gamma_2=\Gamma_1[\cf:\tarrow{\alpha}{\beta}]$\\
    $\Gamma_3=\Gamma_2[\cx:\alpha]$\\
    $\Gamma_4=[\cy:\tnum]$\\
    \[
      T:
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \inferrule
              {
                \inferrule
                {
                  \inferrule
                  { \alpha\in\dom{\Gamma_1} }
                  { \wft{\Gamma_1}{\alpha} }
                  \\
                  \inferrule
                  { \beta\in\dom{\Gamma_1} }
                  { \wft{\Gamma_1}{\beta} }
                }
                { \wft{\Gamma_1}{\tarrow{\alpha}{\beta}} }
                \\
                \inferrule
                {
                  \inferrule
                  { \alpha\in\dom{\Gamma_2} }
                  { \wft{\Gamma_2}{\alpha} }
                  \\
                  \inferrule
                  {
                    \inferrule
                    { \cf\in\dom{\Gamma_3} }
                    { \typeof{\Gamma_3}{\cf}{\tarrow{\alpha}{\beta}} }
                    \\
                    \inferrule
                    { \cx\in\dom{\Gamma_3} }
                    { \typeof{\Gamma_3}{\cx}{\alpha} }
                  }
                  { \typeof{\Gamma_3}{\cf\ \cx}{\beta} }
                }
                {
                  \typeof{\Gamma_2}
                  {\efunt{\cx}{\alpha}{\cf\ \cx}}{\tarrow{\alpha}{\beta}}
                }
              }
              { \typeof{\Gamma_1}{
                  \efunt{\cf}{\tarrow{\alpha}{\beta}}{
                    \efunt{\cx}{\alpha}{\cf\ \cx}}}
                {\tarrow{(\tarrow{\alpha}{\beta})}{(\tarrow{\alpha}{\beta})}}
              }
            }
            { \typeof{[\alpha]}{\etfun{\beta}{
                \efunt{\cf}{\tarrow{\alpha}{\beta}}{
                  \efunt{\cx}{\alpha}{\cf\ \cx}}}}
              {\tforall{\beta}{\tarrow{(\tarrow{\alpha}{\beta})}{(\tarrow{\alpha}{\beta})}}}
            }
          }
          { \typeofe
            {\etfun{\alpha}{\etfun{\beta}{
              \efunt{\cf}{\tarrow{\alpha}{\beta}}{
                \efunt{\cx}{\alpha}{\cf\ \cx}}}}}
            {\tforall{\alpha}{\tforall{\beta}{\tarrow{(\tarrow{\alpha}{\beta})}{(\tarrow{\alpha}{\beta})}}}}
          }
        }
        {
          \typeofe
          {\etapp{(\etfun{\alpha}{\etfun{\beta}{
            \efunt{\cf}{\tarrow{\alpha}{\beta}}{
              \efunt{\cx}{\alpha}{\cf\ \cx}
            }
          }})}{\tnum}}
          {\tforall{\beta}{\tarrow{(\tarrow{\tnum}{\beta})}{(\tarrow{\tnum}{\beta})}}}
        }
      }
      { \typeofe
        {\etapp{\etapp{(\etfun{\alpha}{\etfun{\beta}{
          \efunt{\cf}{\tarrow{\alpha}{\beta}}{
            \efunt{\cx}{\alpha}{\cf\ \cx}
          }
        }})}{\tnum}}{\tnum}
        }
        {\tarrow{(\tarrow{\tnum}{\tnum})}{(\tarrow{\tnum}{\tnum})}}
      }
    \]
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          T
          \\
          \inferrule
          {
            \wft{\emptyset}{\tnum} \\
            \inferrule
            {
              \typeof{\Gamma_4}{17}{\tnum}
              \\
              \inferrule
              { \cy\in\dom{\Gamma_4} }
              { \typeof{\Gamma_4}{\cy}{\tnum} }
            }
            { \typeof{\Gamma_4}{17-\cy}{\tnum} }
          }
          { \typeofe{\efunt{\cy}{\tnum}{17-\cy}}{\tarrow{\tnum}{\tnum}} }
        }
        { \typeofe{\etapp{\etapp{(\etfun{\alpha}{\etfun{\beta}{
            \efunt{\cf}{\tarrow{\alpha}{\beta}}{
              \efunt{\cx}{\alpha}{\cf\ \cx}
            }
          }})}{\tnum}}{\tnum}\ (\efunt{\cy}{\tnum}{17-\cy})}
          {\tarrow{\tnum}{\tnum}} }
        \\
        \typeofe{9}{\tnum}
      }
      {
        \typeofe{
          \etapp{\etapp{(\etfun{\alpha}{\etfun{\beta}{
            \efunt{\cf}{\tarrow{\alpha}{\beta}}{
              \efunt{\cx}{\alpha}{\cf\ \cx}
            }
          }})}{\tnum}}{\tnum}\ (\efunt{\cy}{\tnum}{17-\cy})\ 9
        }{\tnum}
      }
    \]
\end{enumerate}

\textbf{\refex{parametric-polymorphism-nameless}}
\vspace{-1em}
\begin{verbatim}
case class ArrowT(p: Type, r: Type) extends Type
case class ForallT(t: Type) extends Type
case class VarT(i: Int) extends Type

case NumT => Nameless.NumT
case ArrowT(p, r) =>
  Nameless.ArrowT(transform(p, ctx), transform(r, ctx))
case ForallT(a, t) =>
  Nameless.ForallT(transform(t, a :: ctx))
case VarT(a) =>
  Nameless.VarT(locate(a, ctx))
\end{verbatim}

\textbf{\refex{parametric-polymorphism-adt}}
\begin{enumerate}
  \item
    \[
      \inferrule
      {
        \Gamma'=\Gamma[t=[\alpha]x_1@\tau_1+x_2@\tau_2,x_1:\tforall{\alpha}{\tarrow{\tau_1}{t[\alpha]}},x_2:\tforall{\alpha}{\tarrow{\tau_2}{t[\alpha]}}] \\
        t\not\in\dom{\Gamma} \\
        \Gamma'[\alpha]\vdash\tau_1 \\
        \Gamma'[\alpha]\vdash\tau_2 \\
        \typeof{\Gamma'}{e}{\tau} \\
        \wftd{\tau}
      }
      { \typeofd{\etdef{t[\alpha]}{x_1}{\tau_1}{x_2}{\tau_2}{e}}{\tau} }
    \]

    \[
      \inferrule
      {
        t\in\dom{\Gamma} \\
        \Gamma(t)=[\alpha]x_1@\tau_1+x_2@\tau_2 \\
        \typeofd{e}{t[\tau]} \\
        \typeof{\Gamma[x_3:\tau_1[\alpha\leftarrow\tau]]}{e_1}{\tau'} \\
        \typeof{\Gamma[x_4:\tau_2[\alpha\leftarrow\tau]]}{e_2}{\tau'}
      }
      { \typeofd{\ematch{e}{x_1}{x_3}{e_1}{x_2}{x_4}{e_2}}{\tau'} }
    \]
  \item
    \[
      \inferrule
      { t\in\dom{\Gamma} \\ \wftd{\tau} }
      { \Gamma\vdash t[\tau] }
    \]
  \item
    $\tforall{\alpha}{\tarrow{\code{option}[\alpha]}{\tarrow{\alpha}{\alpha}}}$
\end{enumerate}

\textbf{\refex{subtype-polymorphism-welltyped}}
\begin{enumerate}
  \item Not well-typed
  \item
  \[
    \scriptsize
    \inferrule
    {
      \typeofe{1}{\tnum} \\
      \typeofe{\{\}}{\{\}} \\
      \inferrule
      {
        \inferrule
        { \typeof{\emptyset}{2}{\tnum} }
        { \typeof{\emptyset}{\{\ca=2\}}{\{\ca:\tnum\}} }
        \\
        \subt{\{\ca:\tnum\}}{\{\}}
      }
      { \typeofe{\{\ca=2\}}{\{\}} }
    }
    { \typeofe{\eifz{1}{\{\}}{\{\ca=2\}}}{\{\}} }
  \]
\end{enumerate}

\textbf{\refex{subtype-polymorphism-arrow}}

$\eapp{(\efunt{\cx}{\tarrow{\tnum}{\tnum}}{\eapp{\cx}{1}})}{1}$
\\

\textbf{\refex{subtype-polymorphism-subtyper}}
\vspace{-1em}
\begin{verbatim}
case (_, TopT) => true
case (BottomT, _) => true
case (NumT, NumT) => true
case (ArrowT(p1, r1), ArrowT(p2, r2)) =>
  subtype(p2, p1) && subtype(r1, r2)
case (RecordT(fs1), RecordT(fs2)) =>
  fs2.forall{
    case (x, t2) => fs1.get(x) match {
      case None => false
      case Some(t1) => subtype(t1, t2)
    }
  }
\end{verbatim}

\textbf{\refex{subtype-polymorphism-typer}}
\vspace{-1em}
\begin{verbatim}
case Add(l, r) =>
  val lt = typeCheck(l, tenv)
  val rt = typeCheck(r, tenv)
  if (!subtype(lt, NumT)) error()
  if (!subtype(rt, NumT)) error()
  NumT
case App(f, a) =>
  val ft = typeCheck(f, tenv)
  val at = typeCheck(a, tenv)
  ft match {
    case NumT => error()
    case ArrowT(pt, rt) =>
      if (!subtype(at, pt)) error()
      rt
    case TopT => error()
    case BottomT => BottomT
  }
\end{verbatim}

\textbf{\refex{subtype-polymorphism-lattice}}
\vspace{-1em}
\begin{verbatim}
case (BottomT, t) => t
case (t, BottomT) => t
case (NumT, NumT) => NumT
case (ArrowT(p1, r1), ArrowT(p2, r2)) =>
  ArrowT(glb(p1, p2), lub(r1, r2))
case (RecordT(fs1), RecordT(fs2)) =>
  val fs = fs1.keySet & fs2.keySet
  RecordT(fs.map(x => x -> lub(fs1(x), fs2(x))).toMap)

case (TopT, t) => t
case (t, TopT) => t
case (NumT, NumT) => NumT
case (ArrowT(p1, r1), ArrowT(p2, r2)) =>
  ArrowT(lub(p1, p2), glb(r1, r2))
case (RecordT(fs1), RecordT(fs2)) =>
  val fs = fs1.keySet | fs2.keySet
  RecordT(fs.map(x =>
    x -> glb(fs1.getOrElse(x, TopT), fs2.getOrElse(x, TopT))
  ).toMap)

case If0(c, t, f) =>
  val ct = typeCheck(c, tenv)
  val tt = typeCheck(t, tenv)
  val ft = typeCheck(f, tenv)
  if (subtype(ct, NumT)) lub(tt, ft) else error()
\end{verbatim}

\textbf{\refex{subtype-polymorphism-box}}
\[
\inferrule
{ \subt{\tau_1}{\tau_2} \\ \subt{\tau_2}{\tau_1} }
{ \subt{\textsf{box}\ \tau_1}{\textsf{box}\ \tau_2} }
\]

\textbf{\refex{subtype-polymorphism-list}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \subt{\tau_1}{\tau_2} }
      { \subt{\textsf{list}\ \tau_1}{\textsf{list}\ \tau_2} }
    \]
  \item
    \[
      \inferrule
      { \subt{\tau_1}{\tau_2} \\ \subt{\tau_2}{\tau_1} }
      { \subt{\textsf{list}\ \tau_1}{\textsf{list}\ \tau_2} }
    \]
\end{enumerate}

\textbf{\refex{subtype-polymorphism-vcc}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \typeof{\Gamma[x:\tarrow{\tau}{\tbot}]}{e}{\tau} }
      { \typeofd{(\evcc{x}{e}){:}\tau}{\tau} }
    \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \inferrule
              { \cx\in\dom{\Gamma} }
              { \typeofd{\cx}{\tarrow{\tnum}{\tbot}} }
              \\
              \typeofd{1}{\tnum}
            }
            { \typeofd{\eapp{\cx}{1}}{\tbot} }
            \\
            \subt{\tbot}{\tarrow{\tnum}{\tnum}}
          }
          { \typeofd{\eapp{\cx}{1}}{\tarrow{\tnum}{\tnum}} }
          \\
          \typeofd{42}{\tnum}
        }
        { \typeofd{\eapp{(\eapp{\cx}{1})}{42}}{\tnum} }
      }
      { \typeofe{(\evcc{\cx}{\eapp{(\eapp{\cx}{1})}{42}}){:}\tnum}{\tnum} }
    \]

    $\Gamma=[\cx:\tarrow{\tnum}{\tbot}]$
\end{enumerate}

\textbf{\refex{subtype-polymorphism-intersection}}
\begin{enumerate}
  \item
    \[
      \inferrule{\subt{\tau_1}{\tau_3}}{\subt{\tau_1\land\tau_2}{\tau_3}}
    \]

    \[
      \inferrule{\subt{\tau_2}{\tau_3}}{\subt{\tau_1\land\tau_2}{\tau_3}}
    \]
  \item
    \[
      \inferrule{\subt{\tau_3}{\tau_1}\\\subt{\tau_3}{\tau_2}}{\subt{\tau_3}{\tau_1\land\tau_2}}
    \]
  \item
    \[
      \inferrule
      {
        \inferrule
        { \subt{\tau_2}{\tau_2} }
        { \subt{\tau_1\land\tau_2}{\tau_2} } \\
        \inferrule
        { \subt{\tau_1}{\tau_1} }
        { \subt{\tau_1\land\tau_2}{\tau_1} }
      }
      { \subt{\tau_1\land\tau_2}{\tau_2\land\tau_1} }
    \]
\end{enumerate}

\textbf{\refex{subtype-polymorphism-union}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \subt{\tau_1}{\tau_3} \\ \subt{\tau_2}{\tau_3} }
      { \subt{(\tau_1\lor\tau_2)}{\tau_3} }
    \]
  \item
    \[
      \inferrule
      { \subt{\tau_3}{\tau_1} }
      { \subt{\tau_3}{(\tau_1\lor\tau_2)} }
    \]

    \[
      \inferrule
      { \subt{\tau_3}{\tau_2} }
      { \subt{\tau_3}{(\tau_1\lor\tau_2)} }
    \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        {
          \inferrule
          { \subt{\tau_1}{\tau_1} }
          { \subt{\tau_1}{(\tau_1\lor(\tau_2\lor\tau_3))} }
          \\
          \inferrule
          {
            \inferrule
            { \subt{\tau_2}{\tau_2} }
            { \subt{\tau_2}{(\tau_2\lor\tau_3)} }
          }
          { \subt{\tau_2}{(\tau_1\lor(\tau_2\lor\tau_3))} }
        }
        { \subt{(\tau_1\lor\tau_2)}{(\tau_1\lor(\tau_2\lor\tau_3))} }
        \\
        \inferrule
        {
          \inferrule
          { \subt{\tau_3}{\tau_3} }
          { \subt{\tau_3}{(\tau_2\lor\tau_3)} }
        }
        { \subt{\tau_3}{(\tau_1\lor(\tau_2\lor\tau_3))} }
      }
      { \subt{((\tau_1\lor\tau_2)\lor\tau_3)}{(\tau_1\lor(\tau_2\lor\tau_3))} }
    \]
\end{enumerate}

\textbf{\refex{subtype-polymorphism-adt}}
\[
  \inferrule
  {
    \Gamma(t_1)=x_1@\tau_1+\cdots+x_n@\tau_n \\
    \Gamma(t_2)=x_1@\tau_1'+\cdots+x_n@\tau_n'+x_{n+1}@\tau_{n+1}'+\cdots+x_{n+m}@\tau_{n+m}' \\
    \Gamma\vdash\subt{\tau_1}{\tau_1'} \\
    \cdots \\
    \Gamma\vdash\subt{\tau_n}{\tau_n'}
  }
  { \Gamma\vdash\subt{t_1}{t_2} }
\]

\textbf{\refex{subtype-polymorphism-exception}}
\[
  { \typeofd{n}{\tnum\uparrow\tbot} }
\]
\[
  \inferrule
  { \typeofd{e_1}{\tnum\uparrow\tau} \\ \typeofd{e_2}{\tnum\uparrow\tau} }
  { \typeofd{e_1+e_2}{\tnum\uparrow\tau} }
\]
\[
  \inferrule
  { x\in\dom{\Gamma} }
  { \typeofd{x}{\Gamma(x)\uparrow\tbot} }
\]
\[
  \inferrule
  { \typeof{\Gamma[x:\tau_1]}{e}{\tau_2\uparrow\tau_3} }
  { \typeofd{\efunt{x}{\tau_1}{e}}{(\tarrow{\tau_1}{\tau_2/\uparrow\tau_3})\uparrow\tbot} }
\]
\[
  \inferrule
  { \typeofd{e_1}{(\tarrow{\tau_1}{\tau_2/\uparrow\tau_3})\uparrow\tau_3} \\
    \typeofd{e_2}{\tau_1\uparrow\tau_3} }
  { \typeofd{e_1\ e_2}{\tau_2\uparrow\tau_3} }
\]
\[
  \inferrule
  { \typeofd{e}{\tau\uparrow\tau} }
  { \typeofd{\textsf{throw}\ e}{\tbot\uparrow\tau} }
\]
\[
  \inferrule
  { \typeofd{e_1}{\tau_1\uparrow\tau_2} \\
    \typeofd{e_2}{(\tarrow{\tau_2}{\tau_1/\uparrow\tau_3})\uparrow\tau_3}}
  { \typeofd{\textsf{try}\ e_1\ \textsf{catch}\ e_2}{\tau_1\uparrow\tau_3} }
\]

\textbf{\refex{type-inference-pair}}
\begin{enumerate}
  \item
\begin{verbatim}
case (PairT(l1, r1), PairT(l2, r2)) =>
  unify(l1, l2)
  unify(r1, r2)

case PairT(l, r) =>
  occurs(t1, l) || occurs(t1, r)

case Pair(l, r) =>
  val lt = typeCheck(l, tenv)
  val rt = typeCheck(r, tenv)
  PairT(lt, rt)
case Fst(e) =>
  val et = typeCheck(e, tenv)
  val ft = VarT(None)
  val st = VarT(None)
  unify(PairT(ft, st), et)
  ft
case Snd(e) =>
  val et = typeCheck(e, tenv)
  val ft = VarT(None)
  val st = VarT(None)
  unify(PairT(ft, st), et)
  st
\end{verbatim}
  \item
    \verb+ArrowT(VarT(Some(PairT(VarT(Some(NumT)), VarT(None)))), NumT)+
\end{enumerate}

\textbf{\refex{type-inference-box}}
\vspace{-1em}
\begin{verbatim}
case (BoxT(t3), BoxT(t4)) =>
  unify(t3, t4)

case BoxT(t) =>
  occurs(t1, t)

case NewBox(e) =>
  val et = typeCheck(e, tenv)
  BoxT(et)
case OpenBox(b) =>
  val bt = typeCheck(b, tenv)
  val t = VarT(None)
  unify(bt, BoxT(t))
  t
case SetBox(b, e) =>
  val bt = typeCheck(b, tenv)
  val et = typeCheck(e, tenv)
  unify(bt, BoxT(et))
  et
\end{verbatim}

\textbf{\refex{type-inference-list}}
\vspace{-1em}
\begin{verbatim}
case (ListT(t3), ListT(t4)) =>
  unify(t3, t4)

case ListT(t) =>
  occurs(t1, t)

case Nil =>
  val t = VarT(None)
  ListT(t)
case Cons(h, t) =>
  val ht = typeCheck(h, tenv)
  val tt = typeCheck(t, tenv)
  unify(ListT(ht), tt)
  tt
case Head(e) =>
  val et = typeCheck(e, tenv)
  val t = VarT(None)
  unify(et, ListT(t))
  t
case Tail(e) =>
  val et = typeCheck(e, tenv)
  val t = VarT(None)
  unify(et, ListT(t))
  et
\end{verbatim}

\textbf{\refex{type-inference-option}}
\vspace{-1em}
\begin{verbatim}
case (OptionT(t3), OptionT(t4)) =>
  unify(t3, t4)

case OptionT(t) =>
  occurs(t1, t)

case NoneE =>
  OptionT(VarT(None))
case SomeE(e) =>
  OptionT(typeCheck(e, tenv))
case Match(e, e1, x, e2) =>
  val et = typeCheck(e, tenv)
  val t = VarT(None)
  unify(OptionT(t), et)
  val nt = typeCheck(e1, tenv)
  val st = typeCheck(e2, tenv + (x -> t))
  unify(nt, st)
  nt
\end{verbatim}

\textbf{\refex{type-inference-sysf}}
\begin{enumerate}
  \item
    \[
      \begin{array}{rcl}
        \ersr{n}&=&n \\
        \ersr{\eadd{e_1}{e_2}}&=&\eadd{\ersr{e_1}}{\ersr{e_2}} \\
        \ersr{\esub{e_1}{e_2}}&=&\esub{\ersr{e_1}}{\ersr{e_2}} \\
        \ersr{x}&=&x \\
        \ersr{\efunt{x}{\tau}{e}}&=&\efun{x}{\ersr{e}} \\
        \ersr{\eapp{e_1}{e_2}}&=&\eapp{\ersr{e_1}}{\ersr{e_2}} \\
        \ersr{\etfun{\alpha}{e}}&=&\ersr{e} \\
        \ersr{\etapp{e}{\tau}}&=&\ersr{e} \\
      \end{array}
    \]
  \item
    \begin{enumerate}
      \item $\eapp{(\efun{\cx}{\cx})}{1}$
      \item $\eapp{\eapp{(\efun{\cx}{\efun{\cy}{\cy}})}{1}}{2}$
    \end{enumerate}
  \item
    \begin{enumerate}
      \item
        $\efunt{\cx}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}
        {\eapp{\eapp{(\etapp{\cx}{\tarrow{\tnum}{\tnum}})}{(\efunt{\cx}{\tnum}{\cx})}}{(\eapp{\etapp{\cx}{\tnum}}{1})}}$
      \item
        $\eapp{
          \eapp{(\efunt{\cx}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}{\efunt{\cy}{\tnum}{\eapp{\eapp{(\etapp{\cx}{\tarrow{\tnum}{\tnum}})}{(\etapp{\cx}{\tnum})}}{\cy}}})}
          {(\etfun{\alpha}{\efunt{\cx}{\alpha}{\cx}})}
        }{1}$
      \item
        $\eapp{(\efunt{\cx}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}{\eapp{\eapp{(\etapp{\cx}{\tarrow{\tnum}{\tnum}})}{(\etapp{\cx}{\tnum})}}{1}})}
        {\etfun{\alpha}{\efunt{\cy}{\alpha}{\cy}}}$
    \end{enumerate}
\end{enumerate}

\textbf{\refex{type-inference-hm}}
\begin{enumerate}
  \item
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \cx\in\dom{\Gamma_1} \\
              \tarrow{\tnum}{\tnum}\succ\tarrow{\tnum}{\tnum}
            }
            { \typeof{\Gamma_1}{\cx}{\tarrow{\tnum}{\tnum}} }
            \\
            \typeof{\Gamma_1}{42}{\tnum}
          }
          { \typeof{\Gamma_1}{\eapp{\cx}{42}}{\tnum} }
        }
        { \typeofe{\efun{\cx}{\eapp{\cx}{42}}}{\tarrow{(\tarrow{\tnum}{\tnum})}{\tnum}} } \\
        \inferrule
        {
          \inferrule
          { \cy\in\dom{\Gamma_2} \\ \tnum\succ\tnum }
          { \typeof{\Gamma_2}{\cy}{\tnum} }
        }
        { \typeofe{\efun{\cy}{\cy}}{\tarrow{\tnum}{\tnum}} }
      }
      { \typeofe{\eapp{(\efun{\cx}{\eapp{\cx}{42}})}{\efun{\cy}{\cy}}}{\tnum} }
    \]
    $\Gamma_1=[\cx:\tarrow{\tnum}{\tnum}]$, $\Gamma_2=[\cy:\tnum]$
  \item Not well-typed
  \item
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          { \cy\in\dom{\Gamma_1} \\ \alpha\succ\alpha }
          { \typeof{\Gamma_1}{\cy}{\alpha} }
        }
        { \typeofe{\efun{\cy}{\cy}}{\tarrow{\alpha}{\alpha}} }
        \\
        \inferrule
        { \embox{FTV}(\tarrow{\alpha}{\alpha})\setminus\embox{FTV}(\emptyset)=\{\alpha\} }
        { \tarrow{\alpha}{\alpha}\prec_\emptyset\tforall{\alpha}{\tarrow{\alpha}{\alpha}} }
        \\
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \cx\in\dom{\Gamma_2} \\
              \tforall{\alpha}{\tarrow{\alpha}{\alpha}}\succ\tarrow{\tnum}{\tnum}
            }
            { \typeof{\Gamma_2}{\cx}{\tarrow{\tnum}{\tnum}} }
            \\
            \typeof{\Gamma_2}{42}{\tnum}
          }
          { \typeof{\Gamma_2}{\eapp{\cx}{42}}{\tnum} }
          \inferrule
          {
            \inferrule
            {
              \cx\in\dom{\Gamma_2} \\
              \tforall{\alpha}{\tarrow{\alpha}{\alpha}}\succ\tarrow{\tbool}{\tbool}
            }
            { \typeof{\Gamma_2}{\cx}{\tarrow{\tbool}{\tbool}} }
            \\
            \typeof{\Gamma_2}{\true}{\tbool}
          }
          { \typeof{\Gamma_2}{\eapp{\cx}{\true}}{\tbool} }
        }
        { \typeof{\Gamma_2}{\eseq{\eapp{\cx}{42}}{\eapp{\cx}{\true}}}{\tbool} }
      }
      { \typeofe{\ebind{\cx}{\efun{\cy}{\cy}}{\eseq{\eapp{\cx}{42}}{\eapp{\cx}{\true}}}}{\tbool} }
    \]

    $\Gamma_1=[\cy:\alpha]$,
    $\Gamma_2=[\cx:\forall\alpha.\alpha\rightarrow\alpha]$
\end{enumerate}
