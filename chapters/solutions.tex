\setchapterpreamble[u]{\margintoc}
\chapter{Solutions to Selected Exercises}
\labch{solutions}

Many exercises are meant to have multiple solutions. Each provided solution may
not be the only solution.

\textbf{\refex{immutability-student}}
\vspace{-1em}
\begin{verbatim}
def names(l: List[Student]): List[String] = l match {
  case Nil => Nil
  case h :: t => h.name :: names(t)
}
\end{verbatim}

\textbf{\refex{immutability-tall}}
\vspace{-1em}
\begin{verbatim}
def tall(l: List[Student]): List[Student] = l match {
  case Nil => Nil
  case h :: t =>
    if (h.height > 170)
      h :: tall(t)
    else
      tall(t)
}
\end{verbatim}

\textbf{\refex{immutability-length}}
\vspace{-1em}
\begin{verbatim}
def length(l: List[Int]): Int = l match {
  case Nil => 0
  case h :: t => 1 + length(t)
}
\end{verbatim}

\textbf{\refex{immutability-append}}
\vspace{-1em}
\begin{verbatim}
def append(l: List[Int], n: Int): List[Int] = l match {
  case Nil => n :: Nil
  case h :: t => h :: append(t, n)
}
\end{verbatim}
\vspace{-1em}
$O(n)$

\textbf{\refex{functions-incby}}
\vspace{-1em}
\begin{verbatim}
def incBy(l: List[Int], n: Int): List[Int] = l.map(_ + n)
\end{verbatim}

\textbf{\refex{functions-gt}}
\vspace{-1em}
\begin{verbatim}
def gt(l: List[Int], n: Int): List[Int] = l.filter(_ > n)
\end{verbatim}

\textbf{\refex{functions-append}}
\vspace{-1em}
\begin{verbatim}
def append(l: List[Int], n: Int): List[Int] =
  l.foldRight(n :: Nil)(_ :: _)
\end{verbatim}

\textbf{\refex{functions-reverse}}
\vspace{-1em}
\begin{verbatim}
def reverse(l: List[Int]): List[Int] =
  l.foldLeft(Nil: List[Int])((l, e) => e :: l)
\end{verbatim}

\textbf{\refex{identifiers-shadowing-impl}}
\vspace{-1em}
\begin{verbatim}
case Num(n) => Set()
case Add(l, r) => helper(l, env) ++ helper(r, env)
case Id(x) => Set()
case Val(x, e, b) =>
  val s = if (env(x)) Set(x) else Set()
  s ++ helper(e, env) ++ helper(b, env + x)
\end{verbatim}

\textbf{\refex{first-class-functions-rewrite}}

$\eapp{(\efun{\cx}{\efun{\cy}\eapp{\eapp{\cx}{(\esub{10}{\cy})}}})}{\efun{\cy}{\eadd{8}{\cy}}}$
\\

\textbf{\refex{first-class-functions-rewrite-impl}}
\vspace{-1em}
\begin{verbatim}
case Num(n) => Num(n)
case Id(x) => Id(x)
case Val(x, e, b) => App(Fun(x, desugar(b)), desugar(e))
case Fun(x, b) => Fun(x, desugar(b))
case App(f, a) => App(desugar(f), desugar(a))
\end{verbatim}

\textbf{\refex{first-class-functions-closure}}

$\eapp{\eapp{(\efun{\cx}{\efun{\cy}{\cx}})}{0}}{0}$
\\

\textbf{\refex{first-class-functions-terminate}}

$\eapp{1}{1}$
\\

\textbf{\refex{first-class-functions-subst}}
\newcommand{\evals}[2]{#1\Rightarrow#2}
\begin{enumerate}
  \item
      \[
        \evals{n}{n}
        \qquad
        \inferrule
        { \evals{e_1}{n_1} \\ \evals{e_2}{n_2} }
        { \evals{\eadd{e_1}{e_2}}{\eadd{n_1}{n_2}} }
      \]

      \[
        \evals{\efun{x}{e}}{\efun{x}{e}}
        \qquad
        \inferrule
        { \evals{e_1}{\efun{x}{e}} \\
          \evals{e_2}{v_2} \\
          \evals{e[x/v_2]}{v} }
        { \evals{\eapp{e_1}{e_2}}{v} }
      \]
  \item
      \[
        \begin{array}{rcl}
          n[x/v] &=& n \\
          (\eadd{e_1}{e_2})[x/v] &=& \eadd{e_1[x/v]}{e_2[x/v]} \\
          x'[x/v] &=& v \quad \text{if}\ x=x' \\
          x'[x/v] &=& x' \quad \text{if}\ x\not=x' \\
          (\efun{x'}{e})[x/v] &=& \efun{x'}{e} \quad \text{if}\ x=x' \\
          (\efun{x'}{e})[x/v] &=& \efun{x'}{e[x/v]} \quad \text{if}\ x\not=x' \\
          (\eapp{e_1}{e_2})[x/v] &=& \eapp{e_1[x/v]}{e_2[x/v]} \\
        \end{array}
      \]
  \item
    \begin{enumerate}
        \item 22
        \item Error
    \end{enumerate}
  \item
\begin{verbatim}
case Fun(y, b) =>
  if (y == x)
    Fun(y, b)
  else {
    val ny = fresh(binding(b) ++ free(b) ++ free(v) ++ Set(x))
    Fun(ny, subst(subst(b, y, Id(ny)), x, v))
  }
\end{verbatim}
\end{enumerate}

\textbf{\refex{first-class-functions-js-record}}
\begin{enumerate}
  \item
      \[
        \inferrule
        { \evald{e_1}{v_1} \\\cdots\\ \evald{e_n}{v_n} }
        { \evald{\{l_1:e_1,\ldots,l_n:e_n\}}{\langle l_1:v_1,\ldots,l_n:v_n\rangle} }
      \]

      \[
        \inferrule
        { \evald{e}{\langle\ldots,l:v,\ldots\rangle} }
        { \evald{e.l}{v} }
      \]

      \[
        \inferrule
        {
          \evald{e}{\langle l_1:v_1,\ldots,l_n:v_n\rangle} \\
          l\not\in\{l_1,\ldots,l_n\} \\
          l_i=\code{proto} \\
          \evald{v_i.l}{v}
        }
        { \evald{e.l}{v} }
      \]

      \[
        \inferrule
        {
          \evald{e}{\langle l_1:v_1,\ldots,l_n:v_n\rangle} \\
          l\not\in\{l_1,\ldots,l_n\} \\
          \code{proto}\not\in\{l_1,\ldots,l_n\}
        }
        { \evald{e.l}{\textsf{undefined}} }
      \]

      \[
        \inferrule
        {
          \evald{e_1}{v_1} \\
          \evald{v_1.l}{\clov{x}{e}{\sigma'}} \\
          \evald{e_2}{v_2} \\
          \eval{\sigma'[\code{this}\mapsto v_1,x\mapsto v_2]}{e}{v}
        }
        { \evald{e_1.l(e_2)}{v} }
      \]
  \item
    {
      \[
        \tiny
        \inferrule
        {
          \inferrule
          {
            \inferrule
            { \eval{\emptyset}{1}{1} }
            { \eval{\emptyset}{\{\code{x}:1\}}{\langle\code{x}:1\rangle} }
          }
          { \eval
            {\emptyset}
            {\{\code{proto}:\{\code{x}:1\}\}}
            {\langle\code{proto}:\langle\code{x}:1\rangle\rangle}
          } \\
          \code{x}\not\in\{\code{proto}\} \\
          \code{proto}=\code{proto} \\
          \inferrule
          { \evald{\langle\code{x}:1\rangle}{\langle\code{x}:1\rangle} }
          { \evald{\langle\code{x}:1\rangle.\code{x}}{1} }
        }
        { \eval{\emptyset}{\{\code{proto}:\{\code{x}:1\}\}.\code{x}}{1} }
      \]
    }
  \item
    $\efun{\code{x}}{\code{this}.\code{a}}$
\end{enumerate}

\textbf{\refex{first-class-functions-exc}}
\begin{enumerate}
    \item
    \[
      \begin{array}{c}
        \inferrule
        {}
        { \evald{n}{n} }
        \quad
        \inferrule
        { x\in\dom{\sigma} }
        { \evald{x}{\sigma(x)} }
        \\[2em]
        \inferrule
        {}
        { \evald{\efun{x}{e}}{\clov{x}{e}{\sigma}} }
        \quad
        \inferrule
        { \evald{e_1}{\textsf{exc}} }
        { \evald{e_1+e_2}{\textsf{exc}} }
        \\[2em]
        \inferrule
        { \evald{e_1}{v} \\
          \evald{e_2}{\textsf{exc}} }
        { \evald{e_1+e_2}{\textsf{exc}} }
        \quad
        \inferrule
        { \evald{e_1}{n_1} \\
          \evald{e_2}{n_2} }
        { \evald{e_1+e_2}{n_1+n_2} }
        \\[2em]
        \inferrule
        { \evald{e_1}{\textsf{exc}} }
        { \evald{e_1\ e_2}{\textsf{exc}} }
        \quad
        \inferrule
        { \evald{e_1}{v} \\
          \evald{e_2}{\textsf{exc}} }
        { \evald{e_1\ e_2}{\textsf{exc}} }
        \\[2em]
        \inferrule
        { \evald{e_1}{\clov{x}{e}{\sigma'}} \\
          \evald{e_2}{v_2} \\
          \eval{\sigma'[x\mapsto v_2]}{e}{r}
        }
        { \evald{\eapp{e_1}{e_2}}{r} }
        \\[2em]
        \inferrule
        {}
        { \evald{\textsf{throw}}{\textsf{exc}} }
        \quad
        \inferrule
        { \evald{e_1}{v} }
        { \evald{\textsf{try}\ e_1\ \textsf{catch}\ e_2}{v} }
        \\[2em]
        \inferrule
        { \evald{e_1}{\textsf{exc}} \\ \evald{e_2}{r} }
        { \evald{\textsf{try}\ e_1\ \textsf{catch}\ e_2}{r} }
      \end{array}
    \]
    \item
  \[
    \inferrule
    {
      \inferrule
      {
        \evale{1}{1} \\
        \evale{\textsf{throw}}{\textsf{exc}}
      }
      { \evale{1 + \textsf{throw}}{\textsf{exc}} } \\
      \inferrule
      { \evale{\textsf{throw}}{\textsf{exc}} }
      { \evale{\textsf{throw} + 2}{\textsf{exc}} } \\
    }
    { \evale{\textsf{try}\ (1 + \textsf{throw})\ \textsf{catch}\ (\textsf{throw} + 2)}{\textsf{exc}} }
  \]
\end{enumerate}

\textbf{\refex{recursion-scope}}
\begin{enumerate}
    \item Does not terminate
    \item 49
\end{enumerate}

\textbf{\refex{recursion-eager-if}}

$\eifz{0}{0}{(\eapp{0}{0})}$
\\

\textbf{\refex{recursion-racket-if}}
\newcommand{\eand}[2]{\textsf{and}\ #1\ #2}
\newcommand{\eor}[2]{\textsf{or}\ #1\ #2}
\begin{enumerate}
  \item
    \[
      \begin{array}{c}
      \inferrule
      {}
      { \evald{b}{b} }
      \quad
      \inferrule
      { \evald{e_1}{v_1} \\ v_1\not={\false} \\ \evald{e_2}{v_2} }
      { \evald{\eif{e_1}{e_2}{e_3}}{v_2} }
      \\[2em]
      \inferrule
      { \evald{e_1}{\false} \\ \evald{e_3}{v_3} }
      { \evald{\eif{e_1}{e_2}{e_3}}{v_3} }
      \quad
      \inferrule
      { \evald{e_1}{\false} }
      { \evald{\eand{e_1}{e_2}}{\false} }
      \\[2em]
      \inferrule
      { \evald{e_1}{v_1} \\ v_1\not={\false} \\ \evald{e_2}{v_2} }
      { \evald{\eand{e_1}{e_2}}{v_2} }
      \\[2em]
      \inferrule
      { \evald{e_1}{v_1} \\ v_1\not={\false} }
      { \evald{\eor{e_1}{e_2}}{v_1} }
      \quad
      \inferrule
      { \evald{e_1}{\false} \\ \evald{e_2}{v_2}}
      { \evald{\eor{e_1}{e_2}}{v_2} }
      \end{array}
    \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        {
          \eval{\emptyset}{\false}{\false} \\
          \eval{\emptyset}{2}{2}
        }
        { \eval{\emptyset}{\eor{\false}{2}}{2} } \\
        2\not={\false} \\
        \inferrule
        { \eval{\emptyset}{\false}{\false} }
        { \eval{\emptyset}{\eand{\false}{2}}{\false} } \\
      }
      { \eval{\emptyset}{\eif{(\eor{\false}{2})}{(\eand{\false}{2})}{1}}{\false} }
    \]
\end{enumerate}

\textbf{\refex{recursion-fix-nont}}

Change $\ebind{\code{g}}{\eapp{\cy}{\cy}}{}$to
$\ebind{\code{g}}{\efun{\cx}{\eapp{\eapp{\cy}{\cy}}{\cx}}}{}$\!.
\\

\textbf{\refex{recursion-fix-free}}

Change $\ebind{\cf}{\eapp{\cz}{({\efun{\cv}{\sumbodyfv}})}}{}$to
$\ebind{\cf}{\eapp{\cz}{({\efun{\cf}{\efun{\cv}{\sumbodyfv}}})}}{}$\!.
\\

\textbf{\refex{recursion-mutual}}

$\begin{array}{@{}l@{}}
  \ebind{\cz}{(\efun{\cb}{\\
  \ \ \ \ \ebind{\code{fx}}{(\efun{\code{fy}}{\\
  \ \ \ \ \ \ \ \ \ebind{\cf}{\efun{\cx}{(\eapp{\code{fy}}{\code{fy}})\textsf{.1}\ \cx}}{\\
  \ \ \ \ \ \ \ \ \ebind{\code{g}}{\efun{\cx}{(\eapp{\code{fy}}{\code{fy}})\textsf{.2}\ \cx}}{\\
  \ \ \ \ \ \ \ \ \eapp{\cb}{(\cf,\code{g})}}}}\\\ \ \ \ )}{\\
  \ \ \ \ \eapp{\code{fx}}{\code{fx}}}}\\)}{\\
  \ebind{\cf}{\eapp{\cz}{\efun{\cf}{(
    \efun{\code{n}}{\eifz{\code{n}}{\true}{(\eapp{\cf\textsf{.2}}{(\esub{\code{n}}{1})})}},
    \efun{\code{n}}{\eifz{\code{n}}{\false}{(\eapp{\cf\textsf{.1}}{(\esub{\code{n}}{1})})}}
  )}}}{\\
  \ebind{\code{even}}{\cf\textsf{.1}}{\\
  \ebind{\code{odd}}{\cf\textsf{.2}}{\\
  (\eapp{\code{even}}{10}, \eapp{\code{odd}}{10})}}}}
\end{array}$
\\

\textbf{\refex{mutable-boxes-desugar}}
\vspace{-1em}
\begin{verbatim}
App(Fun(fresh(free(r)), desugar(r)), desugar(l))
\end{verbatim}

\textbf{\refex{mutable-variables-cbr}}
\begin{enumerate}
  \item CBR
  \item
    $[\code{n} \mapsto a_1, \cf \mapsto a_2, \cx \mapsto a_4]$,\\
$[
    a_1 \mapsto 42,
    a_2 \mapsto \clov{\code{g}}{\eapp{\code{g}}{\code{n}}}{[\code{n} \mapsto a_1]},
    a_3 \mapsto \clov{\cx}{\eadd{\cx}{8}}{[\code{n} \mapsto a_1, \code{f} \mapsto a_2]},
    a_4 \mapsto 42
]$
  \item
    $[\code{n} \mapsto a_1, \cf \mapsto a_2, \cx \mapsto a_1]$,\\
$[
    a_1 \mapsto 42,
    a_2 \mapsto \clov{\code{g}}{\eapp{\code{g}}{\code{n}}}{[\code{n} \mapsto a_1]},
    a_3 \mapsto \clov{\cx}{\eadd{\cx}{8}}{[\code{n} \mapsto a_1, \code{f} \mapsto a_2]}
]$
\end{enumerate}

\textbf{\refex{mutable-variables-record}}
\begin{enumerate}
  \item
\begin{verbatim}
val (RecV(fields), rs) = interp(r, env, fs)
interp(b, fenv + (x -> fields(f)), rs)
\end{verbatim}
  \item 2,
    $[a_1 \mapsto 2, a_2 \mapsto \{\cz{:}a_1\}, a_3 \mapsto \clov{\cy}{\eset{\cy}{2}}{[\cx \mapsto a_2]}]$
  \item 1,
    $[a_1 \mapsto 1, a_2 \mapsto \{\cz{:}a_1\}, a_3 \mapsto \clov{\cy}{\eset{\cy}{2}}{[\cx \mapsto a_2]}, a_4 \mapsto 2]$
\end{enumerate}

\textbf{\refex{mutable-variables-imp}}
\begin{enumerate}
  \item
      \[
        \begin{array}{c}
        \inferrule
        {}
        { \evald{\eskip}{\sigma} }
        \quad
        \inferrule
        { \evald{e}{v} }
        { \evald{\eset{x}{e}}{\sigma[x\mapsto v]} }
        \\[2em]
        \inferrule
        { \evald{e}{0} \\ \evald{c_1}{\sigma_1} }
        { \evald{\eifz{e}{c_1}{c_2}}{\sigma_1} }
        \quad
        \inferrule
        { \evald{e}{v} \\ v\not=0 \\ \evald{c_2}{\sigma_2} }
        { \evald{\eifz{e}{c_1}{c_2}}{\sigma_2} }
        \\[2em]
        \inferrule
        { \evald{e}{0} \\ \evald{c}{\sigma_1} \\ \eval{\sigma_1}{\ewhile{e}{c}}{\sigma_2} }
        { \evald{\ewhile{e}{c}}{\sigma_2} }
        \\[2em]
        \inferrule
        { \evald{e}{v} \\ v\not=0 }
        { \evald{\ewhile{e}{c}}{\sigma} }
        \quad
        \inferrule
        { \evald{c_1}{\sigma_1} \\ \eval{\sigma_1}{c_2}{\sigma_2} }
        { \evald{\eseq{c_1}{c_2}}{\sigma_2} }
        \end{array}
      \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        { \eval{\emptyset}{0}{0} }
        { \eval{\emptyset}{\eset{{\cx}}{0}}{[{\cx}\mapsto0]} }
        \\
        \inferrule
        {
          \inferrule
          { {\cx}\in\dom{[{\cx}\mapsto0]} }
          { \eval{[{\cx}\mapsto0]}{{\cx}}{0} }
          \quad
          \inferrule
          {}
          { \eval{[{\cx}\mapsto0]}{{\eskip}}{[{\cx}\mapsto0]} }
        }
        { \eval{[{\cx}\mapsto0]}
          {\eseq{\eifz{{\cx}}{{\eskip}}{\eset{{\cx}}{1}}}}
          {[{\cx}\mapsto0]} }
      }
      { \eval{\emptyset}
        {\eseq{\eset{{\cx}}{0}}{\eifz{{\cx}}{{\eskip}}{\eset{{\cx}}{1}}}}
        {[{\cx}\mapsto0]}
      }
    \]
\end{enumerate}

\textbf{\refex{garbage-collection-copying}}

\begin{itemize}
  \item Stack: \code{13}
\item From space:
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|@{\hskip0pt}c@{\hskip0pt}|}
 \hline
 {1}&{2}&{2}&{3}&{7}&{99}&{19}&{99}&{16}&{10}&{99}&{13}&{5}\\
 \hline \multicolumn{1}{c}{}\\[-16pt]
  \multicolumn{1}{c}{\tiny \code{0}}&
  \multicolumn{1}{c}{\tiny \code{1}}&
  \multicolumn{1}{c}{\tiny \code{2}}&
  \multicolumn{1}{c}{\tiny \code{3}}&
  \multicolumn{1}{c}{\tiny \code{4}}&
  \multicolumn{1}{c}{\tiny \code{5}}&
  \multicolumn{1}{c}{\tiny \code{6}}&
  \multicolumn{1}{c}{\tiny \code{7}}&
  \multicolumn{1}{c}{\tiny \code{8}}&
  \multicolumn{1}{c}{\tiny \code{9}}&
  \multicolumn{1}{c}{\tiny \code{10}}&
  \multicolumn{1}{c}{\tiny \code{11}}&
  \multicolumn{1}{c}{\tiny \code{12}}
 \\
\end{tabular}
\item To space:
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|@{\hskip0pt}c@{\hskip0pt}|}
 \hline
 {3}&{16}&{5}&{4}&{19}&{13}&{1}&{4}&{0}&{0}&{0}&{0}&{0}\\
 \hline \multicolumn{1}{c}{}\\[-16pt]
  \multicolumn{1}{c}{\tiny \code{13}}&
  \multicolumn{1}{c}{\tiny \code{14}}&
  \multicolumn{1}{c}{\tiny \code{15}}&
  \multicolumn{1}{c}{\tiny \code{16}}&
  \multicolumn{1}{c}{\tiny \code{17}}&
  \multicolumn{1}{c}{\tiny \code{18}}&
  \multicolumn{1}{c}{\tiny \code{19}}&
  \multicolumn{1}{c}{\tiny \code{20}}&
  \multicolumn{1}{c}{\tiny \code{21}}&
  \multicolumn{1}{c}{\tiny \code{22}}&
  \multicolumn{1}{c}{\tiny \code{23}}&
  \multicolumn{1}{c}{\tiny \code{24}}&
  \multicolumn{1}{c}{\tiny \code{25}}
 \\
\end{tabular}
\end{itemize}

\textbf{\refex{lazy-evaluation-strict}}

$\eapp{(\efun{\cy}{\eapp{(\efun{\cx}{\eadd{\cx}{0}})}{\cy}})}{0}$
\\

\textbf{\refex{lazy-evaluation-val}}
\vspace{-1em}
\begin{verbatim}
case Val(x, e, b) =>
  interp(b, env + (x -> ExprV(e, env)))
case If0(c, t, f) =>
  interp(if (strict(interp(c, env)) == NumV(0)) t else f, env)
\end{verbatim}

\textbf{\refex{lazy-evaluation-pair}}
\vspace{-1em}
\begin{verbatim}
case class PairV(f: Value, s: Value) extends Value

case Pair(f, s) => PairV(ExprV(f, env), ExprV(s, env))
case Fst(e) =>
  val PairV(v, _) = strict(interp(e, env))
  v
case Snd(e) =>
  val PairV(_, v) = strict(interp(e, env))
  v
\end{verbatim}

\textbf{\refex{lazy-evaluation-list}}
\vspace{-1em}
\begin{verbatim}
case class ConsV(h: Value, t: Value) extends Value

case Nil => NilV
case Cons(h, t) => ConsV(ExprV(h, env), ExprV(t, env))
case Head(e) =>
  val ConsV(h, _) = strict(interp(e, env))
  strict(h)
case Tail(e) =>
  val ConsV(_, t) = strict(interp(e, env))
  val v = strict(t)
  if (isList(v)) v else error()
\end{verbatim}

\textbf{\refex{continuations-lfae}}
\vspace{-1em}
\begin{verbatim}
case ExprV(e, env) =>
  interp(e, env, v => strict(v, k))

case Add(l, r) =>
  interp(l, env, v1 =>
    interp(r, env, v2 =>
      strict(v1, n =>
        strict(v2, m => {
          val NumV(l) = n
          val NumV(r) = m
          k(NumV(l + r))
        }))))
case App(f, a) =>
  interp(f, env, v =>
    strict(v, fv => {
      val CloV(x, b, fenv) = fv
      interp(b, fenv + (x -> ExprV(a, env)), k)
    }))
\end{verbatim}

\textbf{\refex{first-class-continuations-result}}
\begin{enumerate}
  \item 3
  \item 6
  \item Error
  \item 5
  \item Does not terminate
\end{enumerate}

\textbf{\refex{first-class-continuations-print}}

$\begin{array}{@{}l}
  \eapp{(\evcc{\cx}{\cx})}{\efun{\cy}{\cy}} \\
  \evcc{\cx}{\cx} \\
  \cx \\
  \efun{\cy}{\cy} \\
  \efun{\cy}{\cy} \\
  \cy \\
\end{array}$
\\

\textbf{\refex{first-order-representation-of-continuations-pair}}
\vspace{-1em}
\begin{verbatim}
case class PairSecondK(s: Expr, env: Env, k: Cont) extends Cont
case class DoPairK(fv: Value, k: Cont) extends Cont
case class DoFstK(k: Cont) extends Cont
case class DoSndK(k: Cont) extends Cont

case PairSecondK(s, env, k) => interp(s, env, DoPairK(v, k))
case DoPairK(fv, k) => continue(k, PairV(fv, v))
case DoFstK(k) =>
  val PairV(fv, _) = v
  continue(k, fv)
case DoSndK(k) =>
  val PairV(_, sv) = v
  continue(k, sv)

case Pair(f, s) => interp(f, env, PairSecondK(s, env, k))
case Fst(p) => interp(p, env, DoFstK(k))
case Snd(p) => interp(p, env, DoSndK(k))
\end{verbatim}

\textbf{\refex{nameless-representation-of-expressions-trans}}

$\eapp{\eapp{\eapp{(\efun{}{\efun{}{\efun{}{\eadd{(\esub{\underline{0}}{\underline{2}})}{\underline{1}}}}})}{42}}{0}}{10}$
\\

\textbf{\refex{typing-recursive-functions-terminate}}

$\erect{\cf}{\cx}{\tnum}{\tarrow{\tnum}{\tnum}}{\eapp{\cf}{\cx}}{\eapp{\cf}{0}}$
\\

\textbf{\refex{algebraic-data-types-norec}}

$\etdef{\code{A}}{\cX}{\code{A}}{\cY}{\tnum}{0}$
\\

\textbf{\refex{algebraic-data-types-nowf}}

$\begin{array}{@{}l}
  \etdef{\cX}{\code{A}}{\code{Y}}{\code{B}}{\tnum}{ \\
  \eapp{( \\
  \ \ \ \ \etdef{\cY}{\code{C}}{\tnum}{\code{D}}{\tnum}{ \\
  \ \ \ \ \efunt{\cx}{\cX}{\ematch{\cx}{ \\
  \ \ \ \ \ \ \ \ \code{A}}{\cy}{\ematch{\cy}{ \\
  \ \ \ \ \ \ \ \ \ \ \ \ \code{C}}{\cz}{0}{ \\
  \ \ \ \ \ \ \ \ \ \ \ \ \code{D}}{\cz}{0}}{ \\
  \ \ \ \ \ \ \ \ \code{B}}{\cy}{0}} \\
  })}{( \\
  \ \ \ \ \etdef{\cY}{\code{E}}{\tnum}{\code{F}}{\tnum}{ \\
  \ \ \ \ \eapp{\code{A}}{(\eapp{\code{E}}{0})} \\
  })}}
\end{array}$

\textbf{\refex{parametric-polymorphism-nameless}}
\vspace{-1em}
\begin{verbatim}
case class ArrowT(p: Type, r: Type) extends Type
case class ForallT(t: Type) extends Type
case class VarT(i: Int) extends Type

case NumT => Nameless.NumT
case ArrowT(p, r) =>
  Nameless.ArrowT(transform(p, ctx), transform(r, ctx))
case ForallT(a, t) =>
  Nameless.ForallT(transform(t, a :: ctx))
case VarT(a) =>
  Nameless.VarT(locate(a, ctx))
\end{verbatim}

\textbf{\refex{parametric-polymorphism-adt}}
\begin{enumerate}
  \item
    \[
      \inferrule
      {
        \Gamma'=\Gamma[t=[\alpha]x_1@\tau_1+x_2@\tau_2,x_1:\tforall{\alpha}{\tarrow{\tau_1}{t[\alpha]}},x_2:\tforall{\alpha}{\tarrow{\tau_2}{t[\alpha]}}] \\
        t\not\in\dom{\Gamma} \\
        \Gamma'[\alpha]\vdash\tau_1 \\
        \Gamma'[\alpha]\vdash\tau_2 \\
        \typeof{\Gamma'}{e}{\tau} \\
        \wftd{\tau}
      }
      { \typeofd{\etdef{t[\alpha]}{x_1}{\tau_1}{x_2}{\tau_2}{e}}{\tau} }
    \]
    \[
      \inferrule
      {
        t\in\dom{\Gamma} \\
        \Gamma(t)=[\alpha]x_1@\tau_1+x_2@\tau_2 \\
        \typeofd{e}{t[\tau]} \\
        \typeof{\Gamma[x_3:\tau_1[\alpha\leftarrow\tau]]}{e_1}{\tau'} \\
        \typeof{\Gamma[x_4:\tau_2[\alpha\leftarrow\tau]]}{e_2}{\tau'}
      }
      { \typeofd{\ematch{e}{x_1}{x_3}{e_1}{x_2}{x_4}{e_2}}{\tau'} }
    \]
  \item
    \[
      \inferrule
      { t\in\dom{\Gamma} \\ \wftd{\tau} }
      { \Gamma\vdash t[\tau] }
    \]
  \item
    $\tforall{\alpha}{\tarrow{\code{option}[\alpha]}{\tarrow{\alpha}{\alpha}}}$
\end{enumerate}

\textbf{\refex{subtype-polymorphism-welltyped}}
\begin{enumerate}
  \item Not well-typed
  \item
  \[
    \scriptsize
    \inferrule
    {
      \typeofe{1}{\tnum} \\
      \typeofe{\{\}}{\{\}} \\
      \inferrule
      {
        \inferrule
        { \typeof{\emptyset}{2}{\tnum} }
        { \typeof{\emptyset}{\{\ca=2\}}{\{\ca:\tnum\}} }
        \\
        \subt{\{\ca:\tnum\}}{\{\}}
      }
      { \typeofe{\{\ca=2\}}{\{\}} }
    }
    { \typeofe{\eifz{1}{\{\}}{\{\ca=2\}}}{\{\}} }
  \]
\end{enumerate}

\textbf{\refex{subtype-polymorphism-arrow}}

$\eapp{(\efunt{\cx}{\tarrow{\tnum}{\tnum}}{\eapp{\cx}{1}})}{1}$
\\

\textbf{\refex{subtype-polymorphism-subtyper}}
\vspace{-1em}
\begin{verbatim}
case (_, TopT) => true
case (BottomT, _) => true
case (NumT, NumT) => true
case (ArrowT(p1, r1), ArrowT(p2, r2)) =>
  subtype(p2, p1) && subtype(r1, r2)
case (RecordT(fs1), RecordT(fs2)) =>
  fs2.forall{
    case (x, t2) => fs1.get(x) match {
      case None => false
      case Some(t1) => subtype(t1, t2)
    }
  }
\end{verbatim}

\textbf{\refex{subtype-polymorphism-typer}}
\vspace{-1em}
\begin{verbatim}
  case Add(l, r) =>
    val lt = typeCheck(l, tenv)
    val rt = typeCheck(r, tenv)
    if (!subtype(lt, NumT)) error()
    if (!subtype(rt, NumT)) error()
    NumT
  case App(f, a) =>
    val ft = typeCheck(f, tenv)
    val at = typeCheck(a, tenv)
    ft match {
      case NumT => error()
      case ArrowT(pt, rt) =>
        if (!subtype(at, pt)) error()
        rt
      case TopT => error()
      case BottomT => BottomT
    }
\end{verbatim}

\textbf{\refex{subtype-polymorphism-box}}

$
\inferrule
{ \subt{\tau_1}{\tau_2} \\ \subt{\tau_2}{\tau_1} }
{ \subt{\textsf{box}\ \tau_1}{\textsf{box}\ \tau_2} }
$
\\

\textbf{\refex{subtype-polymorphism-vcc}}
\begin{enumerate}
  \item
    \[
      \inferrule
      { \typeof{\Gamma[x:\tarrow{\tau}{\tbot}]}{e}{\tau} }
      { \typeofd{(\evcc{x}{e}){:}\tau}{\tau} }
    \]
  \item
    \[
      \scriptsize
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \inferrule
              { \cx\in\dom{\Gamma} }
              { \typeofd{\cx}{\tarrow{\tnum}{\tbot}} }
              \\
              \typeofd{1}{\tnum}
            }
            { \typeofd{\eapp{\cx}{1}}{\tbot} }
            \\
            \subt{\tbot}{\tarrow{\tnum}{\tnum}}
          }
          { \typeofd{\eapp{\cx}{1}}{\tarrow{\tnum}{\tnum}} }
          \\
          \typeofd{42}{\tnum}
        }
        { \typeofd{\eapp{(\eapp{\cx}{1})}{42}}{\tnum} }
      }
      { \typeofe{(\evcc{\cx}{\eapp{(\eapp{\cx}{1})}{42}}){:}\tnum}{\tnum} }
    \]

    $\Gamma=[\cx:\tarrow{\tnum}{\tbot}]$
\end{enumerate}

\textbf{\refex{subtype-polymorphism-intersection}}
\begin{enumerate}
  \item
    \[
      \inferrule{\subt{\tau_1}{\tau_3}}{\subt{\tau_1\land\tau_2}{\tau_3}}
      \qquad
      \inferrule{\subt{\tau_2}{\tau_3}}{\subt{\tau_1\land\tau_2}{\tau_3}}
    \]
  \item
    \[
      \inferrule{\subt{\tau_3}{\tau_1}\\\subt{\tau_3}{\tau_2}}{\subt{\tau_3}{\tau_1\land\tau_2}}
    \]
  \item
    \[
      \inferrule
      {
        \inferrule
        { \subt{\tau_2}{\tau_2} }
        { \subt{\tau_1\land\tau_2}{\tau_2} } \\
        \inferrule
        { \subt{\tau_1}{\tau_1} }
        { \subt{\tau_1\land\tau_2}{\tau_1} }
      }
      { \subt{\tau_1\land\tau_2}{\tau_2\land\tau_1} }
    \]
\end{enumerate}

\textbf{\refex{subtype-polymorphism-adt}}
\[
  \begin{array}{c}
  \inferrule
  {
    \Gamma(t_1)=x_1@\tau_1+\cdots+x_n@\tau_n \\
    \Gamma(t_2)=x_1@\tau_1+\cdots+x_n@\tau_n+x_{n+1}@\tau_{n+1}+\cdots+x_{n+m}@\tau_{n+m} \\
  }
  { \Gamma\vdash\subt{t_1}{t_2} }
  \\[2em]
  \inferrule
  {
    \Gamma(t_1)=x_1@\tau_1+\cdots+x_n@\tau_n \\
    \Gamma(t_2)=x_1@\tau_1'+\cdots+x_n@\tau_n' \\
    \Gamma\vdash\subt{\tau_1}{\tau_1'} \\
    \cdots \\
    \Gamma\vdash\subt{\tau_n}{\tau_n'}
  }
  { \Gamma\vdash\subt{t_1}{t_2} }
  \\[2em]
  \inferrule
  {
    \Gamma(t_1)=x_1@\tau_1+\cdots+x_n@\tau_n \\
    \Gamma(t_2)=x_1'@\tau_1'+\cdots+x_n'@\tau_n' \\
    x_1@\tau_1+\cdots+x_n@\tau_n
    \ \text{is a permutation of}\
    x_1'@\tau_1'+\cdots+x_n'@\tau_n'
  }
  { \Gamma\vdash\subt{t_1}{t_2} }
  \end{array}
\]
(The last rule is unnecessary in fact because the $\_@\_+\cdots+\_@\_$ notation
denotes a set, whose equality is already not affected by the order of its elements.)

\textbf{\refex{subtype-polymorphism-exception}}
\[
  \begin{array}{c}
    \inferrule
    {}
    { \typeofd{n}{\tnum\uparrow\tbot} }
    \quad
    \inferrule
    { \typeofd{e_1}{\tnum\uparrow\tau} \\ \typeofd{e_2}{\tnum\uparrow\tau} }
    { \typeofd{e_1+e_2}{\tnum\uparrow\tau} }
    \\[2em]
    \inferrule
    { x\in\dom{\Gamma} }
    { \typeofd{x}{\Gamma(x)\uparrow\tbot} }
    \quad
    \inferrule
    { \typeof{\Gamma[x:\tau_1]}{e}{\tau_2\uparrow\tau_3} }
    { \typeofd{\efunt{x}{\tau_1}{e}}{(\tarrow{\tau_1}{\tau_2/\uparrow\tau_3})\uparrow\tbot} }
    \\[2em]
    \inferrule
    { \typeofd{e_1}{(\tarrow{\tau_1}{\tau_2/\uparrow\tau_3})\uparrow\tau_3} \\
      \typeofd{e_2}{\tau_1\uparrow\tau_3} }
    { \typeofd{e_1\ e_2}{\tau_2\uparrow\tau_3} }
    \\[2em]
    \inferrule
    { \typeofd{e}{\tau\uparrow\tau} }
    { \typeofd{\textsf{throw}\ e}{\tbot\uparrow\tau} }
    \quad
    \inferrule
    { \typeofd{e_1}{\tau_1\uparrow\tau_2} \\
      \typeofd{e_2}{(\tarrow{\tau_2}{\tau_1/\uparrow\tau_3})\uparrow\tau_3}}
    { \typeofd{\textsf{try}\ e_1\ \textsf{catch}\ e_2}{\tau_1\uparrow\tau_3} }
  \end{array}
\]

\textbf{\refex{type-inference-pair}}
\begin{enumerate}
  \item
\begin{verbatim}
case (PairT(l1, r1), PairT(l2, r2)) =>
  unify(l1, l2)
  unify(r1, r2)

case PairT(l, r) =>
  occurs(t1, l) || occurs(t1, r)

case Pair(l, r) =>
  val lt = typeCheck(l, tenv)
  val rt = typeCheck(r, tenv)
  PairT(lt, rt)
case Fst(e) =>
  val et = typeCheck(e, tenv)
  val ft = VarT(None)
  val st = VarT(None)
  unify(PairT(ft, st), et)
  ft
case Snd(e) =>
  val et = typeCheck(e, tenv)
  val ft = VarT(None)
  val st = VarT(None)
  unify(PairT(ft, st), et)
  st
\end{verbatim}
  \item
    \verb+ArrowT(VarT(Some(PairT(VarT(Some(NumT)), VarT(None)))), NumT)+
\end{enumerate}

\textbf{\refex{type-inference-box}}
\vspace{-1em}
\begin{verbatim}
case (BoxT(t3), BoxT(t4)) =>
  unify(t3, t4)

case BoxT(t) =>
  occurs(t1, t)

case NewBox(e) =>
  val et = typeCheck(e, tenv)
  BoxT(et)
case OpenBox(b) =>
  val bt = typeCheck(b, tenv)
  val t = VarT(None)
  unify(bt, BoxT(t))
  t
case SetBox(b, e) =>
  val bt = typeCheck(b, tenv)
  val et = typeCheck(e, tenv)
  unify(bt, BoxT(et))
  et
\end{verbatim}

\textbf{\refex{type-inference-list}}
\vspace{-1em}
\begin{verbatim}
case (ListT(t3), ListT(t4)) =>
  unify(t3, t4)

case ListT(t) =>
  occurs(t1, t)

case Nil =>
  val t = VarT(None)
  ListT(t)
case Cons(h, t) =>
  val ht = typeCheck(h, tenv)
  val tt = typeCheck(t, tenv)
  unify(ListT(ht), tt)
  tt
case Head(e) =>
  val et = typeCheck(e, tenv)
  val t = VarT(None)
  unify(et, ListT(t))
  t
case Tail(e) =>
  val et = typeCheck(e, tenv)
  val t = VarT(None)
  unify(et, ListT(t))
  et
\end{verbatim}

\textbf{\refex{type-inference-sysf}}
\begin{enumerate}
  \item
    \[
      \begin{array}{rcl}
        \ersr{n}&=&n \\
        \ersr{\eadd{e_1}{e_2}}&=&\eadd{\ersr{e_1}}{\ersr{e_2}} \\
        \ersr{\esub{e_1}{e_2}}&=&\esub{\ersr{e_1}}{\ersr{e_2}} \\
        \ersr{x}&=&x \\
        \ersr{\efunt{x}{\tau}{e}}&=&\efun{x}{\ersr{e}} \\
        \ersr{\eapp{e_1}{e_2}}&=&\eapp{\ersr{e_1}}{\ersr{e_2}} \\
        \ersr{\etfun{\alpha}{e}}&=&\ersr{e} \\
        \ersr{\etapp{e}{\tau}}&=&\ersr{e} \\
      \end{array}
    \]
  \item
    \begin{enumerate}
      \item $\eapp{(\efun{\cx}{\cx})}{1}$
      \item $\eapp{\eapp{(\efun{\cx}{\efun{\cy}{\cy}})}{1}}{2}$
    \end{enumerate}
  \item
    \begin{enumerate}
      \item
        $\efunt{\cx}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}
        {\eapp{\eapp{(\etapp{\cx}{\tarrow{\tnum}{\tnum}})}{(\efunt{\cx}{\tnum}{\cx})}}{(\eapp{\etapp{\cx}{\tnum}}{1})}}$
      \item
        $\eapp{
          \eapp{(\efunt{\cx}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}{\efunt{\cy}{\tnum}{\eapp{\eapp{(\etapp{\cx}{\tarrow{\tnum}{\tnum}})}{(\etapp{\cx}{\tnum})}}{\cy}}})}
          {(\etfun{\alpha}{\efunt{\cx}{\alpha}{\cx}})}
        }{1}$
      \item
        $\eapp{(\efunt{\cx}{\tforall{\alpha}{\tarrow{\alpha}{\alpha}}}{\eapp{\eapp{(\etapp{\cx}{\tarrow{\tnum}{\tnum}})}{(\etapp{\cx}{\tnum})}}{1}})}
        {\etfun{\alpha}{\efunt{\cy}{\alpha}{\cy}}}$
    \end{enumerate}
\end{enumerate}

\textbf{\refex{type-inference-hm}}
\begin{enumerate}
  \item
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              \cx\in\dom{\Gamma_1} \\
              \tarrow{\tnum}{\tnum}\succ\tarrow{\tnum}{\tnum}
            }
            { \typeof{\Gamma_1}{\cx}{\tarrow{\tnum}{\tnum}} }
            \\
            \typeof{\Gamma_1}{42}{\tnum}
          }
          { \typeof{\Gamma_1}{\eapp{\cx}{42}}{\tnum} }
        }
        { \typeofe{\efun{\cx}{\eapp{\cx}{42}}}{\tarrow{(\tarrow{\tnum}{\tnum})}{\tnum}} } \\
        \inferrule
        {
          \inferrule
          { \cz\in\dom{\Gamma_2} \\ \tnum\succ\tnum }
          { \typeof{\Gamma_2}{\cz}{\tnum} }
        }
        { \typeofe{\efun{\cz}{\cz}}{\tarrow{\tnum}{\tnum}} }
      }
      { \typeofe{\eapp{(\efun{\cx}{\eapp{\cx}{42}})}{\efun{\cz}{\cz}}}{\tnum} }
    \]
    $\Gamma_1=[\cx:\tarrow{\tnum}{\tnum}]$, $\Gamma_2=[\cz:\tnum]$
  \item Not well-typed
  \item
    \[
      \tiny
      \inferrule
      {
        \inferrule
        {
          \inferrule
          { \cz\in\dom{\Gamma_1} \\ \alpha\succ\alpha }
          { \typeof{\Gamma_1}{\cz}{\alpha} }
        }
        { \typeofe{\efun{\cz}{\cz}}{\tarrow{\alpha}{\alpha}} }
        \\
        \inferrule
        { \embox{FTV}(\tarrow{\alpha}{\alpha})\setminus\embox{FTV}(\emptyset)=\{\alpha\} }
        { \tarrow{\alpha}{\alpha}\prec_\emptyset\tforall{\alpha}{\tarrow{\alpha}{\alpha}} }
        \\
        \inferrule
        {
          \inferrule
          {
            \inferrule
            {
              x\in\dom{\Gamma_2} \\
              \tforall{\alpha}{\tarrow{\alpha}{\alpha}}\succ\tarrow{\tnum}{\tnum}
            }
            { \typeof{\Gamma_2}{\cx}{\tarrow{\tnum}{\tnum}} }
            \\
            \typeof{\Gamma_2}{42}{\tnum}
          }
          { \typeof{\Gamma_2}{\eapp{\cx}{42}}{\tnum} }
          \inferrule
          {
            \inferrule
            {
              x\in\dom{\Gamma_2} \\
              \tforall{\alpha}{\tarrow{\alpha}{\alpha}}\succ\tarrow{\tbool}{\tbool}
            }
            { \typeof{\Gamma_2}{\cx}{\tarrow{\tbool}{\tbool}} }
            \\
            \typeof{\Gamma_2}{\true}{\tbool}
          }
          { \typeof{\Gamma_2}{\eapp{\cx}{\true}}{\tbool} }
        }
        { \typeof{\Gamma_2}{\eseq{\eapp{\cx}{42}}{\eapp{\cx}{\true}}}{\tbool} }
      }
      { \typeofe{\ebind{\cx}{\efun{\cz}{\cz}}{\eseq{\eapp{\cx}{42}}{\eapp{\cx}{\true}}}}{\tbool} }
    \]

    $\Gamma_1=[\cz:\alpha]$,
    $\Gamma_2=[\cx:\forall\alpha.\alpha\rightarrow\alpha]$
\end{enumerate}
