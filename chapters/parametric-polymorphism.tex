\setchapterpreamble[u]{\margintoc}
\chapter{Parametric Polymorphism}
\labch{parametric-polymorphism}

This article defines TpolyFAE by adding parametric polymorphism to TFAE. It
defines the abstract syntax, the dynamic semantics, and the type system of
TpolyFAE and implements a type checker and an interpreter of TFAE.

\section{Parametric Polymorphism}

A function in TFAE is more restrictive than a function in FAE. Consider
$\lambda x.x$ in FAE. It is an identity function, which takes a value as an
argument and returns the value without changing it. Any value can be an argument
for this function. Since the body of the function do nothing with the argument,
the evaluation of the body never causes a type error. On the other hand,
$\lambda x:\textsf{num}.x$ in TFAE is an identity function that takes only an
integer. The parameter type annotation restricts the type of an argument to be
only $\textsf{num}$. The type system rejects a program that passes a nonintegral
value to the function. However, the body does not use the argument. Even if
the argument is nonintegral, a type error never happens. If the parameter type
annotation changes, the function will be able to take a value of another type
as an argument without changing its body. For example, \(\lambda x:\textsf{
bool}.x\) is a well-typed identity function for Boolean values. \(\lambda
x:\textsf{num}.x\) and $\lambda x:\textsf{bool}.x$ do the exactly same thing but
cannot be represented by a single function just because their parameter types
are different.

The following FAE expression does not cause a type error:

\[
\begin{array}{l}
\textsf{let}\ f=\lambda x.x\ \textsf{in} \\
\textsf{let}\ x=f\ 1\ \textsf{in} \\
f\ \textsf{true}
\end{array}
\]

The TFAE type system rejects the following TFAE expression even though does
not cause a type error:

\[
\begin{array}{l}
\textsf{let}\ f=\lambda x:\textsf{num}.x\ \textsf{in} \\
\textsf{let}\ x=f\ 1\ \textsf{in} \\
f\ \textsf{true}
\end{array}
\]

The following expression is a revised version, which is well-typed because of
an additional function $g$.

\[
\begin{array}{l}
\textsf{let}\ f=\lambda x:\textsf{num}.x\ \textsf{in} \\
\textsf{let}\ g=\lambda x:\textsf{bool}.x\ \textsf{in} \\
\textsf{let}\ x=f\ 1\ \textsf{in} \\
g\ \textsf{true}
\end{array}
\]

Polymorphism resolves the problem. Polymorphism is a notion of using a single
entity as multiple types. For example, it may allow $\lambda x.x$ to be used
as multiple types. Multiple sorts of polymorphism exist. Parametric
polymorphism, subtype polymorphism, and ad-hoc polymorphism are most widely
used. This article focuses on only parametric polymorphism. The next article
will deal with subtype polymorphism. Overloading is one form of ad-hoc
polymorphism, and ad-hoc polymorphism is outside the scope of the course.

Parametric polymorphism allows an entity to be instantiated as multiple types
with parameters. Until this point, the term "parameter" has been used to
explain functions. $x$ is the parameter of $\lambda x.x+x$. The body,
$x+x$, is parametrized by the parameter, $x$. A function abstracts an
expression with an expression. Consider $\lambda x.x+x$. The expression
$1+1$ is the same as $(\lambda x.x+x)\ 1$; $2+2$ is the same as
$(\lambda x.x+x)\ 2$; $(1+2)+(1+2)$ is the same as \((\lambda x.x+x)\
(1+2)\). A function abstracts an expression by replacing some portion of the
expression with the parameter of a function. By applying a function to an
expression, multiple expressions sharing the common form can be expressed in a
consistent way. Parts that are different in each expression can be expressed
by an argument.

Parametric polymorphism is a notion that applies the concept of a function to
types. A function abstracts an expression with an expression. When a function
is applied to an expression, the result is an expression. If a language
supports parametric polymorphism, there are type functions and type
applications. A type function abstracts an expression with a type. When a type
function is applied to a type, the result is an expression. Consider \(\lambda
x:\textsf{num}.x\) and $\lambda x:\textsf{bool}.x$. The only difference is their
parameter type annotations. Let the type annotations be replaced with a
parameter. $\Lambda\alpha.\lambda x:\alpha.x$ can be obtained. The
expression is a type function, which abstracts an expression with a type. (The
article uses $\Lambda$ instead of $\lambda$ to distinguish type functions
from "normal" functions.) A type function can be applied to a type. The
article uses $[]$ for type applications. $e\ [\tau]$ is an expression that
applies a type function $e$ to a type $\tau$. Therefore, \(\lambda x:\textsf{
num}.x\) is the same as $(\Lambda\alpha.\lambda x:\alpha.x)\ [\textsf{num}]$.
Similarly, $\lambda x:\textsf{bool}.x$ is the same as \((\Lambda\alpha.\lambda
x:\alpha.x)\ [\textsf{bool}]\). These show type applications, which are applying
type functions to types.

Via parametric polymorphism, the previous example can be a well-typed
expression without defining function more than once.

\[
\begin{array}{l}
\textsf{let}\ f=\Lambda\alpha.\lambda x:\alpha.x\ \textsf{in} \\
\textsf{let}\ x=f\ \lbrack\textsf{num}\rbrack\ 1\ \textsf{in} \\
f\ \lbrack\textsf{bool}\rbrack\ \textsf{true}
\end{array}
\]

It is more complex than the FAE expression, but defines a function only once,
not like the TFAE expression. With a type function and type applications, it
uses a single function, $\lambda x:\alpha.x$, as a function of the \(\textsf{
num}\rightarrow\textsf{num}\) type and a function the
\(\textsf{bool}\rightarrow\textsf{
bool}\) type at the same time. The example shows why the term "parametric
polymorphism" is used: a single entity with a type parameter can be used as
multiple types.

Traditionally, functional languages have featured parametric polymorphism. For
example, OCaml and Haskell is well-known for their type systems that support
parametric polymorphism. On the other hand, object-oriented languages have
featured only subtype polymorphism. For instance, in case of Java, versions
from JDK 1.0 to J2SE 1.4 lack parametric polymorphism. However, programmers in
these days require more features for languages as their programs become more
complicated. For this reason, Java has been supporting parametric polymorphism
since J2SE 5.0. Many recent languages, such as Scala, are designed to be
multi-paradigm languages and provide both parametric and subtype polymorphism.

\section{Abstract Syntax}

The following is a portion of the abstract syntax of TpolyFAE:

\[
\begin{array}{rrcl}
\text{Type Identifier} & \alpha & \in & \mathit{TId} \\
\text{Expression} & e & ::= & \cdots \\
&&|& \Lambda\alpha.e \\
&&|& e\ \lbrack\tau\rbrack \\
\text{Value} & v & ::= & \cdots \\
&&|& \langle \Lambda\alpha.e,\sigma\rangle \\
\text{Type} & \tau & ::= & \cdots \\
&&|& \alpha \\
&&|& \forall\alpha.\tau \\
\end{array}
\]

Omitted parts are the same as TFAE.

Metavariable $\alpha$ ranges over type identifiers. Sometimes, type
identifiers being used as type parameters are called type variables.

$\Lambda\alpha.e$ is a type function. Another name of a type function is a
type abstraction. $\alpha$ is the type parameter of the function. The scope of
$\alpha$ is $e$. Here, $\alpha$ is a binding occurrence. If $\alpha$
appears inside $e$, it is a bound occurrence. Previously shown
$\Lambda\alpha.\lambda x:\alpha.x$ is one example of a type function.

$\alpha$ can be a type. In $\Lambda\alpha.\lambda x:\alpha.x$, the second
$\alpha$ is the type of $x$. It is similar to that $t$, which is the name
of a type, can be a type in TVFAE. The syntax does not care where type
identifiers occur. However, like in TVFAE, every type identifier must be used
only inside its scope. Well-formedness rules and typing rules check whether a
type identifier exist at a valid place.

$\langle\Lambda\alpha.e,\sigma\rangle$ is a type function value. A function
results in a closure, which is a function value; a type function results in a
type function value. The body of a function is evaluated when the function is
applied to an argument, and for the evaluation, the closure stores an
environment that is provided when the closure is constructed. Similarly, the
body of a type function is evaluated when the type function is applied to a type
argument, and for the evaluation, the type function values captures the
environment. Evaluation of $\Lambda\alpha.e$ under $\sigma$ results in
$\langle\Lambda\alpha.e,\sigma\rangle$. For example, \(\Lambda\alpha.\lambda
x:\alpha.x\) results in \(\langle\Lambda\alpha.\lambda
x:\alpha.x,\emptyset\rangle\) under the empty environment.

$\forall\alpha.\tau$ is the type of a type function. If the type of $e$ is
$\tau$, then the type of $\Lambda\alpha.e$ is $\forall\alpha.\tau$. For
instance, since the type of $\lambda x:\alpha.x$ is
$\alpha\rightarrow\alpha$, the type of $\Lambda\alpha.\lambda x:\alpha.x$ is
$\forall\alpha.\alpha\rightarrow\alpha$. Types of the form
$\forall\alpha.\tau$ are called universal types or *universally quantified
types*. Universal types bind type identifiers. In $\forall\alpha.\tau$,
$\alpha$ is a binding occurrence, and its scope is $\tau$.

$e\ [\tau]$ is a type application. If $e$ denotes a type function, \(e\
[\tau]\) evaluates the body of the type function under the environment captured
by the type function. A function application adds the value of an argument to
the environment. Environments store values, and type environments stores types.
However, type environments do not exist at run time. Thus, a type application
cannot add a type argument to the type environment. Instead, it uses
a substitution. If $e$ results in $\langle\Lambda\alpha.e',\sigma\rangle$,
evaluating $e\ [\tau]$ is the same as evaluating an expression obtained by
substituting $\alpha$ with $\tau$ in $e'$ under $\sigma$. Consider the
previous example again. Since $\Lambda\alpha.\lambda x:\alpha.x$ results in
$\langle\Lambda\alpha.\lambda x:\alpha.x,\emptyset\rangle$, evaluating
$(\Lambda\alpha.\lambda x:\alpha.x)\ [\textsf{num}]$ is the same as evaluating
$\lambda x:\textsf{num}.x$, which is obtained by substituting $\alpha$ with
$\textsf{num}$ in $\lambda x:\alpha.x$, under $\emptyset$. The result is
$\langle\lambda x:\textsf{num}.x,\emptyset\rangle$.

A type function is an expression whose type is a universal type, while a type
application is an expression that uses a value of a universal type. If the type
of $e$ is $\forall\alpha.\tau'$, then the type of $e\ [\tau]$ is a type
obtained by substituting $\alpha$ with $\tau$ in $\tau'$. In the previous
example, the type of $\Lambda\alpha.\lambda x:\alpha.x$ is
$\forall\alpha.\alpha\rightarrow\alpha$. Therefore, the type of
$(\Lambda\alpha.\lambda x:\alpha.x)\ [\textsf{num}]$ is \(\textsf{
num}\rightarrow\textsf{num}\), which is obtained by substituting $\alpha$ with
$\textsf{num}$ in $\alpha\rightarrow\alpha$.

\section{Dynamic Semantics}

Substitutions must be defined first. Two sorts of substitutions exist:
substitutions on types and substitutions on expressions. Consider substitutions
on
types first.

$\tau'[\alpha\leftarrow\tau]$ is a type obtained by substituting $\alpha$
with $\tau$ in $\tau'$. A substitution is a function from a type, a type
identifier, and a type to a type. Substituting $\alpha$ with $\tau$ means
replacing every free occurrence of $\alpha$ with $\tau$. Bound occurrences
of $\alpha$ must not be replaced.

The following defines substitutions on types:

\[
\begin{array}{rcl}
\textsf{num} \lbrack\alpha\leftarrow\tau\rbrack &=& \textsf{num} \\
(\tau_1\rightarrow\tau_2) \lbrack\alpha\leftarrow\tau\rbrack &=&
(\tau_1
\lbrack\alpha\leftarrow\tau\rbrack)\rightarrow(\tau_2\lbrack\alpha\leftarrow\tau\rbrack)
\\
\alpha \lbrack\alpha\leftarrow\tau\rbrack &=& \tau \\
\alpha' \lbrack\alpha\leftarrow\tau\rbrack &=& \alpha'\\
\textsf{(if } \alpha\not=\alpha'\textsf{)} \\
(\forall\alpha.\tau') \lbrack\alpha\leftarrow\tau\rbrack &=& \forall\alpha.\tau'
\\
(\forall\alpha'.\tau') \lbrack\alpha\leftarrow\tau\rbrack &=&
\forall\alpha'.(\tau'\lbrack\alpha\leftarrow\tau\rbrack) \\
\textsf{(if } \alpha\not=\alpha'\textsf{)} \\
\end{array}
\]

Now, consider substitutions on expressions. $e[\alpha\leftarrow\tau]$ is an
expression obtained by substituting $\alpha$ with $\tau$ in $e$. In this
case, a substitution is a function from an expression, a type identifier and a
type to an expression. Only free occurrences of $\alpha$ in $e$ are replaced
with $\tau$.

The following defines substitutions on expressions:

\[
\begin{array}{rcl}
n \lbrack\alpha\leftarrow\tau\rbrack &=& n \\
(e_1+e_2) \lbrack\alpha\leftarrow\tau\rbrack &=&
(e_1\lbrack\alpha\leftarrow\tau\rbrack) + (e_2\lbrack\alpha\leftarrow\tau\rbrack)
\\
(e_1-e_2) \lbrack\alpha\leftarrow\tau\rbrack &=&
(e_1\lbrack\alpha\leftarrow\tau\rbrack) - (e_2\lbrack\alpha\leftarrow\tau\rbrack)
\\
x \lbrack\alpha\leftarrow\tau\rbrack &=& x \\
(\lambda x:\tau'.e) \lbrack\alpha\leftarrow\tau\rbrack &=&
\lambda
x:(\tau'\lbrack\alpha\leftarrow\tau\rbrack).(e\lbrack\alpha\leftarrow\tau\rbrack)
\\
(e_1\ e_2) \lbrack\alpha\leftarrow\tau\rbrack &=&
(e_1\lbrack\alpha\leftarrow\tau\rbrack)\ (e_2\lbrack\alpha\leftarrow\tau\rbrack)
\\
(\Lambda\alpha.e)\lbrack\alpha\leftarrow\tau\rbrack &=& \Lambda\alpha.e \\
(\Lambda\alpha'.e)\lbrack\alpha\leftarrow\tau\rbrack &=&
\Lambda\alpha'.(e\lbrack\alpha\leftarrow\tau\rbrack)\\
\textsf{(if } \alpha\not=\alpha'\textsf{)} \\
(e\ \lbrack\tau'\rbrack)\lbrack\alpha\leftarrow\tau\rbrack &=&
(e\lbrack\alpha\leftarrow\tau\rbrack)\ \lbrack
\tau'\lbrack\alpha\leftarrow\tau\rbrack\rbrack \\
\end{array}
\]

Finally, we define the dynamic semantics of TpolyFAE. Consider only rules that
are not in the type system of TFAE.

\[
\sigma\vdash \Lambda\alpha.e\Rightarrow \langle \Lambda\alpha.e,\sigma\rangle
\]

A type function results in a type function value. No computation is required.
The type function value captures the current environment.

\[
\inferrule
{ \sigma\vdash e\Rightarrow \langle\Lambda\alpha.e',\sigma'\rangle \\
  \sigma'\vdash e'\lbrack\alpha\leftarrow\tau\rbrack \Rightarrow v }
{ \sigma\vdash e\ \lbrack\tau\rbrack\Rightarrow v }
\]

An expression at the type function position has to be evaluated to evaluate a
type application. The result must be a type function value. The value of the
whole expression is the same as the value of an expression obtained by
substituting the type parameter with the type argument in the body.

The following proof tree proves that the result of \((\Lambda\alpha.\lambda
x:\alpha.x)\ [\textsf{num}]\ 1\) is $1$.

\[
\inferrule
{
  {\Large\inferrule
  {
    \emptyset\vdash\Lambda\alpha.\lambda x:\alpha.x
    \Rightarrow\langle\Lambda\alpha.\lambda x:\alpha.x,\emptyset\rangle \\
    \emptyset\vdash\lambda x:\textsf{num}.x
    \Rightarrow\langle\lambda x.x,\emptyset\rangle
  }
  { \emptyset\vdash
    (\Lambda\alpha.\lambda x:\alpha.x)\ \lbrack\textsf{num}\rbrack
    \Rightarrow\langle\lambda x.x,\emptyset\rangle
  }} \\
  \emptyset\vdash 1\Rightarrow 1 \\
  {\Large\inferrule
  { x\in\mathit{Domain}(\lbrack x\mapsto1\rbrack) }
  { \lbrack x\mapsto1\rbrack\vdash x\Rightarrow 1 }}
}
{ \emptyset\vdash
(\Lambda\alpha.\lambda x:\alpha.x)\ \lbrack\textsf{num}\rbrack\ 1
\Rightarrow 1 }
\]

\section{Type System}

The definition of a type environment needs to be revised. A type environment in
TpolyFAE has to be able to store type identifiers in addition to the type of
variables. Type identifiers do not have further information. Only their
existence is important. The following is a new definition:

\[
\begin{array}{rrcl}
\text{Type Environment} & \Gamma & \in &
\mathit{Id}\cup\mathit{TId}\xrightarrow{\text{fin}}
\text{Type}\cup\{\cdot\} \\
\end{array}
\]

Now, the codomain of a type environment contains $\cdot$, which is a
meaningless mathematical object. For brevity, let $\Gamma[\alpha]$ denote
$\Gamma[\alpha:\cdot]$.

\subsection{Well-Formed Types}

Type environments stores type identifiers. Whether a type is well-formed or not
has to be determined under a type environment.

\[\Gamma\vdash\textsf{num}\]

\[
\inferrule
{ \Gamma\vdash\tau_1 \\
  \Gamma\vdash\tau_2 }
{ \Gamma\vdash\tau_1\rightarrow\tau_2 }
\]

The above rules are the same as those of TVFAE.

\[
\inferrule
{ \alpha\in\mathit{Domain}(\Gamma) }
{ \Gamma\vdash\alpha }
\]

If $\alpha$ is in the type environment, it is well-formed.

\[
\inferrule
{ \Gamma\lbrack\alpha\rbrack\vdash\tau }
{ \Gamma\vdash\forall\alpha.\tau }
\]

In $\forall\alpha.\tau$, $\alpha$ can appear inside $\tau$. Therefore,
$\alpha$ must be in the type environment when the well-formedness of $\tau$
is checked. $\forall\alpha.\tau$ is well-formed under $\Gamma$ if $\tau$
is well-formed under $\Gamma[\alpha]$. For example, $\forall\alpha.\alpha$
is well-formed under the empty type environment, while $\forall\alpha.\beta$
is ill-formed under the same type environment.

\subsection{Typing Rules}

First, consider TFAE typing rules that need fixes.

\[
\inferrule
{ \Gamma\vdash\tau \\ \Gamma\lbrack x:\tau\rbrack\vdash e:\tau' }
{ \Gamma\vdash \lambda x:\tau.e:\tau\rightarrow\tau' }
\]

Like in TVFAE, the rule for lambda abstractions has to check the well-formedness
of parameter types.

The following is a TFAE typing rule for function applications.

\[
\inferrule
{ \Gamma\vdash e_1:\tau'\rightarrow\tau \\
  \Gamma\vdash e_2:\tau' }
{ \Gamma\vdash e_1\ e_2:\tau }
\]

Using the exactly same rule does not break type soundness. However, it restricts
the expressiveness of the language. Consider the following expression:

\[(\lambda x:(\forall\alpha.\alpha\rightarrow\alpha).x)\ (\Lambda\beta.\lambda
x:\beta.x)\]

The type of $\Lambda\beta.\lambda x:\beta.x$ is
$\forall\beta.\beta\rightarrow\beta$. The function \(\lambda
x:(\forall\alpha.\alpha\rightarrow\alpha).x\) takes an argument of the
$\forall\alpha.\alpha\rightarrow\alpha$ type. The above rule rejects the
expression. However, in fact, $\forall\beta.\beta\rightarrow\beta$ is the same
as $\forall\alpha.\alpha\rightarrow\alpha$ since the type parameter is
consistently renamed. Defining equivalence of types resolves the issue.

The following rules define equivalence of types:

\[
\tau\equiv\tau
\]

\[
\inferrule
{ \tau\equiv\tau'\lbrack\alpha'\leftarrow\alpha\rbrack }
{ \forall\alpha.\tau\equiv\forall\alpha'.\tau' }
\]

Two equal types are equivalent. Two universal types are equivalent if types
after consistent renaming of the type parameter is equivalent.

\[
\inferrule
{ \Gamma\vdash e_1:\tau'\rightarrow\tau \\
  \Gamma\vdash e_2:\tau'' \\
  \tau'\equiv\tau'' }
{ \Gamma\vdash e_1\ e_2:\tau }
\]

The above is a revised rule for function applications. It allows cases when the
parameter type and the argument type are equivalent.

Now, consider new typing rules for TpolyFAE.

\[
\inferrule
{ \alpha\not\in\mathit{Domain}(\Gamma) \\
  \Gamma\lbrack\alpha\rbrack\vdash e:\tau }
{ \Gamma\vdash \Lambda \alpha.e:\forall\alpha.\tau }
\]

The type of $\Lambda\alpha.e$ is $\forall\alpha.\tau$ if the type of $e$
is $\tau$. $\alpha$ is well-formed during the type checking of $e$.
Therefore, $e$ needs to be type-checked under the type environment with
$\alpha$. Note that there is a premise that $\alpha$ must not exist in the
initial type environment. If the premise disappears, the language becomes no
more type sound. Consider $\Lambda\alpha.\lambda x:\alpha.\Lambda\alpha.x$ to
find how the type soundness can be broken.

\[
\inferrule
{ \Gamma\vdash\tau \\ \Gamma\vdash e:\forall\alpha.\tau' }
{ \Gamma\vdash e\ \lbrack\tau\rbrack:\tau'\lbrack\alpha\leftarrow\tau\rbrack }
\]

If the type of $e$ is $\forall\alpha.\tau'$, the type of $e\ [\tau]$ is a
type obtained by substituting $\alpha$ with $\tau$ in $\tau'$. Since
$\tau$ is a type given by a programmer, well-formeness of $\tau$ must be
checked.

The following proof tree proves the type of \((\Lambda\alpha.\lambda
x:\alpha.x)\ [\textsf{num}]\ 1\) is $\textsf{num}$.

\[
\inferrule
{
  \inferrule
  {\huge
    \inferrule
    {
      \inferrule
      {
        \inferrule
        { \alpha\in\mathit{Domain}(\lbrack\alpha\rbrack) }
        { \lbrack\alpha\rbrack\vdash\alpha } \\
        \inferrule
        { x\in\mathit{Domain}(\lbrack\alpha,x:\alpha\rbrack) }
        { \lbrack\alpha,x:\alpha\rbrack\vdash x:\alpha }
      }
      { \lbrack\alpha\rbrack\vdash\lambda x:\alpha.x:\alpha\rightarrow\alpha }
    }
    { \emptyset\vdash\Lambda\alpha.\lambda x:\alpha.x:
      \forall\alpha.\alpha\rightarrow\alpha } \\
    {\Large\emptyset\vdash\textsf{num}}
  }
  { \Large\emptyset\vdash(\Lambda\alpha.\lambda x:\alpha.x)\
\lbrack\textsf{num}\rbrack:
    \textsf{num}\rightarrow\textsf{num}
  } \\
  \emptyset\vdash 1:\textsf{num} \\
  \textsf{num}\equiv\textsf{num}
}
{ \emptyset\vdash
(\Lambda\alpha.\lambda x:\alpha.x)\ \lbrack\textsf{num}\rbrack\ 1:
\textsf{num} }
\]

\section{Implementing Type Checker}

The following Scala code implements the abstract syntax of TpolyFAE:

\begin{verbatim}
sealed trait Expr
case class Num(n: Int) extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Sub(l: Expr, r: Expr) extends Expr
case class Id(x: String) extends Expr
case class Fun(x: String, t: Type, b: Expr) extends Expr
case class App(f: Expr, a: Expr) extends Expr
case class TFun(a: String, b: Expr) extends Expr
case class TApp(f: Expr, t: Type) extends Expr

sealed trait Type
case object NumT extends Type
case class ArrowT(p: Type, r: Type) extends Type
case class ForallT(a: String, t: Type) extends Type
case class IdT(a: String) extends Type
\end{verbatim}

An \code{Expr} instance represents a TpolyFAE expression; a \code{TFun} instance
represents a type function; a \code{TApp} instance represents a type application;
a
\code{ForallT} instance represents a universal type; a \code{IdT} instance
represents a
type identifier as a type. A type identifier is any string.

\begin{verbatim}
case class TEnv(
  vars: Map[String, Type] = Map(),
  tbinds: Set[String] = Set()
) {
  def +(p: (String, Type)): TEnv =
    copy(vars = vars + p)
  def +(x: String): TEnv =
    copy(tbinds = tbinds + x)
  def contains(x: String): Boolean = tbinds(x)
}
\end{verbatim}

\code{TEnv} is the type of a type environment. The field \code{vars} stores the
types of
variables; the filed \code{tbinds} stores bound type identifiers. The methods
\code{+} and
\code{contains} help using type environments. For example, the following shows
adding
a variable and a type to a type environment:

\begin{verbatim}
env + ("x" -> NumT)
env + "alpha"
\end{verbatim}

Also, the following shows how one can check whether a type identifier is bound
to a type environment:

\begin{verbatim}
env.contains("alpha")
\end{verbatim}

The following function \code{subst} defines substitutions on types:

\begin{verbatim}
def subst(t1: Type, a: String, t2: Type): Type = t1 match {
  case NumT => t1
  case ArrowT(p, r) => ArrowT(subst(p, a, t2), subst(r, a, t2))
  case IdT(a1) => if (a == a1) t2 else t1
  case ForallT(a1, t) => if (a == a1) t1 else ForallT(a1, subst(t, a, t2))
}
\end{verbatim}

The function \code{mustSame} now considers equivalence of types:

\begin{verbatim}
def mustSame(t1: Type, t2: Type): Type = (t1, t2) match {
  case (NumT, NumT) => t1
  case (ArrowT(p1, r1), ArrowT(p2, r2)) =>
    ArrowT(mustSame(p1, p2), mustSame(r1, r2))
  case (IdT(a1), IdT(a2)) if a1 == a2 => t1
  case (ForallT(a1, t1), ForallT(a2, t2)) =>
    ForallT(a1, mustSame(t1, subst(t2, a2, IdT(a1))))
  case _ => throw new Exception
}
\end{verbatim}

The function \code{validType} checks whether a given type is well-formed under a
given type environment:

\begin{verbatim}
def validType(t: Type, env: TEnv): Type = t match {
  case NumT => t
  case ArrowT(p, r) =>
    ArrowT(validType(p, env), validType(r, env))
  case IdT(t) =>
    if (env.contains(t)) IdT(t)
    else throw new Exception
  case ForallT(a, t) => ForallT(a, validType(t, env + a))
}
\end{verbatim}

Now, consider the function \code{typeCheck}.

\begin{verbatim}
case TFun(a, b) =>
  if (env.contains(a)) throw new Exception
  ForallT(a, typeCheck(b, env + a))
\end{verbatim}

\[
\inferrule
{ \alpha\not\in\mathit{Domain}(\Gamma) \\
  \Gamma\lbrack\alpha\rbrack\vdash e:\tau }
{ \Gamma\vdash \lambda \alpha.e:\forall\alpha.\tau }
\]

The type parameter of a type function must not be in the type environment. The
type of the body is computed under the type environment with the type parameter.
The resulting type is a universal type that consists of the type parameter and
the type of the body.

\begin{verbatim}
case TApp(f, t) =>
  validType(t, env)
  val ForallT(a, t1) = typeCheck(f, env)
  subst(t1, a, t)
\end{verbatim}

\[
\inferrule
{ \Gamma\vdash\tau \\ \Gamma\vdash e:\forall\alpha.\tau' }
{ \Gamma\vdash e\ \lbrack\tau\rbrack:\tau'\lbrack\alpha\leftarrow\tau\rbrack }
\]

A type argument must be well-formed. The type of an expression at the type
function position must be a universal type. The resulting type is obtained by
substituting the type parameter of the universal type with the type argument in
the body of the universal type.

The following is the entire code of the \code{typeCheck} function:

\begin{verbatim}
def typeCheck(e: Expr, env: TEnv): Type = e match {
  case Num(n) => NumT
  case Add(l, r) =>
    mustSame(mustSame(typeCheck(l, env), NumT), typeCheck(r, env))
  case Sub(l, r) =>
    mustSame(mustSame(typeCheck(l, env), NumT), typeCheck(r, env))
  case Id(x) => env.vars(x)
  case Fun(x, t, b) =>
    validType(t, env)
    ArrowT(t, typeCheck(b, env + (x -> t)))
  case App(f, a) =>
    val ArrowT(t1, t2) = typeCheck(f, env)
    val t3 = typeCheck(a, env)
    mustSame(t1, t3)
    t2
  case TFun(a, b) =>
    if (env.contains(a)) throw new Exception
    ForallT(a, typeCheck(b, env + a))
  case TApp(f, t) =>
    validType(t, env)
    val ForallT(a, t1) = typeCheck(f, env)
    subst(t1, a, t)
}
\end{verbatim}

The following computes the type of \((\Lambda\alpha.\lambda x:\alpha.x)\
[\textsf{
num}]\ 1\) with the type checker.

\begin{verbatim}
// (Lambda alpha.lambda x:alpha.x) [num] 1
typeCheck(
  App(
    TApp(
      TFun("alpha",
        Fun("x", IdT("alpha"),
          Id("x")
        )
      ),
      NumT
    ),
    Num(1)
  ),
  TEnv()
)
// num
\end{verbatim}

\section{Implementing Interpreter}

Now, consider an interpreter for TpolyFAE.

\begin{verbatim}
sealed trait Value
case class NumV(n: Int) extends Value
case class CloV(p: String, b: Expr, e: Env) extends Value
case class TFunV(a: String, b: Expr, e: Env) extends Value
\end{verbatim}

A \code{TFunV} instance represents a type function value.

\begin{verbatim}
case TFun(a, b) => TFunV(a, b, env)
\end{verbatim}

\[
\sigma\vdash \Lambda\alpha.e\Rightarrow \langle \Lambda\alpha.e,\sigma\rangle
\]

A type function results in a type function value that captures the current
environment.

\begin{verbatim}
case TApp(f, t) =>
  val TFunV(a, b, fEnv) = interp(f, env)
  interp(subst(b, a, t), fEnv)
\end{verbatim}

\[
\inferrule
{ \sigma\vdash e\Rightarrow \langle\Lambda\alpha.e',\sigma'\rangle \\
  \sigma'\vdash e'\lbrack\alpha\leftarrow\tau\rbrack \Rightarrow v }
{ \sigma\vdash e\ \lbrack\tau\rbrack\Rightarrow v }
\]

For evaluation of a type application, the type function expression is evaluated
first. The result must be a type function value. Obtain an expression by
substituting the type parameter of the type function value with the type
argument in the body of the type function value. Evaluate the expression under
the environment captured by the type function value to acquire the final result.

The following is the entire of the \code{interp} and \code{run} functions:

\begin{verbatim}
def subst(e: Expr, a: String, t: Type): Expr = e match {
  case Num(n) => Num(n)
  case Add(l, r) => Add(subst(l, a, t), subst(r, a, t))
  case Sub(l, r) => Sub(subst(l, a, t), subst(r, a, t))
  case Id(x) => Id(x)
  case Fun(x, t0, b) => Fun(x, subst(t0, a, t), subst(b, a, t))
  case App(f, arg) => App(subst(f, a, t), subst(arg, a, t))
  case TFun(a0, b) => if (a0 == a) TFun(a0, b) else TFun(a0, subst(b, a, t))
  case TApp(f, t0) => TApp(subst(f, a, t), subst(t0, a, t))
}

def interp(e: Expr, env: Env): Value = e match {
  case Num(n) => NumV(n)
  case Add(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n + m)
  case Sub(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n - m)
  case Id(x) => env(x)
  case Fun(x, t, b) => CloV(x, b, env)
  case App(f, a) =>
    val CloV(x, b, fEnv) = interp(f, env)
    interp(b, fEnv + (x -> interp(a, env)))
  case TFun(a, b) => TFunV(a, b, env)
  case TApp(f, t) =>
    val TFunV(a, b, fEnv) = interp(f, env)
    interp(subst(b, a, t), fEnv)
}

def run(e: Expr): Value = {
  typeCheck(e, TEnv())
  interp(e, Map.empty)
}
\end{verbatim}

The following computes the result of \((\Lambda\alpha.\lambda x:\alpha.x)\
[\textsf{num}]\ 1\) with the interpreter.

\begin{verbatim}
// (Lambda alpha.lambda x:alpha.x) [num] 1
run(
  App(
    TApp(
      TFun("alpha",
        Fun("x", IdT("alpha"),
          Id("x")
        )
      ),
      NumT
    ),
    Num(1)
  )
)
// 1
\end{verbatim}

\section{Exercises}

\SaveVerb{op}=[tyfun [=
\SaveVerb{opp}=[@=
\SaveVerb{cl}=]=

\begin{enumerate}
\item Given the following grammar and the partial typing rules:
\[
\begin{array}{ll}
\begin{array}{rl}
e ::= & n\\
\mid& \verb!{+!\ e\ e\ \verb+}+\\
\mid& \verb!{-!\ e\ e\ \verb+}+\\
\mid& x\\
\mid& \verb+{fun {+x \verb+:+\tau \verb+} + e\verb+}+\\
\mid& \verb+{+e\ e \verb+}+\\
\mid& \verb+{if0 + e\ e\ e\verb+}+\\
\mid& \verb+[tyfun [+\alpha\verb+] + e\verb+]+\\
\mid& \verb+[@ +e\ \tau\verb+]+\\
\tau ::= & \verb+num+\\
\mid&\verb+(+\tau\verb+ -> +\tau\verb+)+\\
\mid&\verb+(+\forall \alpha\ \tau\verb+)+\\
\mid&\alpha
\end{array}
&
\begin{array}{c}

\newinfrule
{\Gamma[\alpha]\vdash e : \tau}
{\Gamma\vdash\UseVerb{op}\alpha\UseVerb{cl}\ e\UseVerb{cl} : (\forall \alpha\ \tau)}
\\[2em]
\newinfrule{
\Gamma\vdash \tau_0
\rulesep
\Gamma\vdash e : (\forall\alpha\ \tau_1)
}
{\Gamma\vdash\UseVerb{opp}\ e\ \tau_0\UseVerb{cl} : \tau_1[\alpha \leftarrow \tau_0]}
\\[2em]
\newinfrule{
\Gamma[\alpha]\vdash \tau
}
{\Gamma\vdash(\forall\alpha\ \tau)}
\\[2em]
[\ldots\alpha\ldots]\vdash\alpha
\end{array}
\end{array}
\]



Draw the type derivation of the following expression:

{
\begin{verbatim}
{{fun {f : (forall alpha (alpha -> alpha))}
      {[@ f num] 10}}
 [tyfun [alpha] {fun {x : alpha} x}]}
\end{verbatim}
}

\item Given the partial typing rules:
\[
\begin{array}{ll}
% \begin{array}{rl}
% e ::= & n\\
% \mid& \verb!{+!\ e\ e\ \verb+}+\\
% \mid& \verb!{-!\ e\ e\ \verb+}+\\
% \mid& x\\
% \mid& \verb+{fun {+x \verb+:+\tau \verb+} + e\verb+}+\\
% \mid& \verb+{+e\ e \verb+}+\\
% \mid& \verb+{if0 + e\ e\ e\verb+}+\\
% \mid& \verb+[tyfun [+\alpha\verb+] + e\verb+]+\\
% \mid& \verb+[@ +e\ \tau\verb+]+\\
% \tau ::= & \verb+num+\\
% \mid&\verb+(+\tau\verb+ -> +\tau\verb+)+\\
% \mid&\verb+(+\forall \alpha\ \tau\verb+)+\\
% \mid&\alpha
% \end{array}
% &
\begin{array}{c}

\newinfrule
{\Gamma[\alpha]\vdash e : \tau}
{\Gamma\vdash\UseVerb{op}\alpha\UseVerb{cl}\ e\UseVerb{cl} : (\forall \alpha\ \tau)}
\\[2em]
\newinfrule{
\Gamma\vdash \tau_0
\rulesep
\Gamma\vdash e : (\forall\alpha\ \tau_1)
}
{\Gamma\vdash\UseVerb{opp}\ e\ \tau_0\UseVerb{cl} : \tau_1[\alpha \leftarrow \tau_0]}
\\[2em]
\newinfrule{
\Gamma[\alpha]\vdash \tau
}
{\Gamma\vdash(\forall\alpha\ \tau)}
\\[2em]
[\ldots\alpha\ldots]\vdash\alpha
\end{array}
\end{array}
\]



Draw the type derivation of the following expression:\\

\verb+{with {apply +$(\forall \alpha\ (\forall \beta\ ((\alpha \rightarrow \beta)\ \alpha \rightarrow \beta)))$\\
\verb+             [tyfun [+$\alpha$\verb+] [tyfun [+$\beta$\verb+] {fun {f : +$(\alpha \rightarrow \beta)$
\verb+ x : +$\alpha$\verb+} {f x}}]]}+
\begin{verbatim}
  {[@ [@ apply (num -> num)] num] {fun {n : num} {- 17 n}} 9}}
\end{verbatim}

\item We'd like to allow the following expression:

\begin{verbatim}
{withtype {{alpha list} {empty num}
           {cons (alpha * {alpha list})}}
          {rec {len : (forall alpha ({alpha list} -> num))
                    [tyfun [alpha]
                           {fun {l : {alpha list}}
                                {cases {alpha list} l
                                  {empty {n} 0}
                                  {cons {fxr}
                                        {+ 1 {len {snd fxr}}}}}}]}
               {+ {[@ len num] {[@ cons num] {pair 1 {[@ empty num] 0}}}}
                  {[@ len (num -> num)] {[@ empty (num -> num)] 0}}}}}
\end{verbatim}
and of course the following as well:
\begin{verbatim}
{withtype {fruit {banana num} {apple bool}}
          {{fun {x : fruit} {cases fruit x {banana {n} {+ n 9}} {apple  {b} 76}}}
           {banana 2}}}
\end{verbatim}

\begin{itemize}
  \item[a)] Define the language syntax.

  \item[b)] Write the operational semantics of the form \fbox{$\sigma\vdash e \Rightarrow v$} for the expressions
\texttt{withtype} and \texttt{cases}.

  \item[c)] Write the typing rules of the form \fbox{$\Gamma\vdash e : \tau$} for the expressions
\texttt{withtype} and \texttt{cases} and the well-formedness of the added types.

  \item[d)] Draw the type derivation of the following expression:

\begin{verbatim}
{withtype {{alpha list} {empty num}
                        {cons (alpha * {alpha list})}}
          {[@ [tyfun [alpha]
                     {fun {l : {alpha list}}
                          {cases {alpha list} l {empty {n} n} {cons {p} 1}}}] num]
           {[@ empty num] 0}}}
\end{verbatim}
\end{itemize}

\item Given the following grammar and the partial typing rules:
\[
\begin{array}{ll}
\begin{array}{rl}
e ::= & n\\
\mid& b\\
\mid& \verb!{seqn!\ e\ e\verb+}+\\
\mid& x\\
\mid& \verb+{fun {+x\verb+} + e\verb+}+\\
\mid& \verb+{+e\ e \verb+}+\\
\mid& \verb+{with {+x\ e\verb+} + e\verb+}+\\
\tau ::= & \verb+num+\\
\mid&\verb!bool!\\
\mid&\verb+(+\tau\verb+ -> +\tau\verb+)+\\
\mid&\alpha\\
\sigma ::= & \tau\\
\mid&\verb+(+\forall \alpha\ \sigma\verb+)+\\
\end{array}
&
\begin{array}{c}

\newinfrule
{x : \sigma \in \Gamma\rulesep
\sigma \succ \tau}
{\Gamma\vdash x : \tau}
\\[2em]
\newinfrule{
\Gamma[x : \tau]\vdash e : \tau'
}
{\Gamma\vdash \mbox{\texttt{\{fun \{}}x\}\ e\} : (\tau\rightarrow\tau')}
\\[2em]
\newinfrule{
\Gamma\vdash e_1 : (\tau\rightarrow\tau')
\rulesep
\Gamma\vdash e_2 : \tau
}
{\Gamma\vdash \mbox{\texttt{\{}}e_1\ e_2\} : \tau'}
\\[2em]
\newinfrule{
\Gamma\vdash e_1 : \tau
\rulesep
\Gamma[x : \mathit{Gen}_\Gamma(\tau)]\vdash e_2 : \tau'
}
{\Gamma\vdash \mbox{\texttt{\{with \{}}x\ e_1\}\ e_2\} : \tau'}
\end{array}
\end{array}
\]
\[
\begin{array}{l@{~}l@{~}l}
\sigma \succ \tau &\mbox{iff}& \sigma = (\forall \alpha_1 ( \cdots (\forall \alpha_n\ \tau_0)) \cdots)\ \ \wedge\ \
\tau = \tau_0[\alpha_i \leftarrow \tau_i]\ \mbox{where }1 \le i \le n
\\[1em]
\mathit{Gen}_\Gamma(\tau) &=& (\forall \alpha_1 ( \cdots (\forall \alpha_n\ \tau)) \cdots)\
\mbox{where } \{\alpha_1, \cdots, \alpha_n\} = \mathit{FTV}(\tau) \setminus \mathit{FTV}(\Gamma)
\\[1em]
\mathit{FTV}(\mbox{\texttt{num}}) &=& \emptyset
\\
\mathit{FTV}(\mbox{\texttt{(}}\tau_1\rightarrow\tau_2\mbox{\texttt{)}}) &=& \mathit{FTV}(\tau_1) \cup \mathit{FTV}(\tau_2)
\\
\mathit{FTV}(\alpha) &=& \{\alpha\}
\\
\mathit{FTV}(\Gamma) &=& \bigcup_{x:\sigma \in \Gamma}\mathit{FTV}(\sigma)\\
\mathit{FTV}(\mbox{\texttt{(}}\forall\alpha\ \sigma\mbox{\texttt{)}}) &=& \mathit{FTV}(\sigma) \setminus \{\alpha\}
\\
\end{array}
\]

\begin{itemize}
  \item[a)] Draw the type derivation of the following expression:

\verb!{with {x {fun {z} z}} {seqn {x 42} {x true}}}!

  \item[b)] Draw the type derivation of the following expression:

\verb!{{fun {x} {seqn {x 42} {x true}}} {fun {z} z}}!
\end{itemize}

\item Consider the following language:
\begin{itemize}
  \item[]\textbf{ Abstract syntax}
\[
\begin{array}{r@{\hskip6pt}r@{\hskip6pt}l
  r@{\hskip6pt}l@{\hskip10pt}
  r@{\hskip6pt}r@{\hskip6pt}l@{\hskip10pt}
  r@{\hskip6pt}r@{\hskip6pt}l@{\hskip10pt}
  r@{\hskip4pt}c@{\hskip4pt}l@{\hskip10pt}
  r@{\hskip4pt}c@{\hskip4pt}l}
  e &::= & n &|& \lambda x.e & \tau &::= & \textsf{num} & \sigma &::=& \tau &
  n &\in& \mathbb{Z} & \alpha &\in& \textit{ TV} \\
  &|& b &|& e\ e &&|& \textsf{bool} &&|& \forall\alpha.\sigma &
  b &\in &\{\textsf{true},\textsf{false}\} & \tau &\in& \textit{ Type} \\
  &|& x &|& \textsf{val}\ x=e\ \textsf{in}\ e &&|& \tau\rightarrow\tau &&&&
  x &\in & \textit{ Id} & \sigma &\in& \textit{ TScheme} \\
  &|& e;e &&&&|& \alpha &&&& e &\in& \textit{ Expr} & \Gamma &\in& \textit{ Id}\rightarrow\textit{ TScheme} \\
\end{array}
\]
  \item[]\textbf{ Typing rules}
\[
\begin{array}{ccc}
  \Gamma\vdash n:\textsf{num}
  \qquad
  \Gamma\vdash b:\textsf{bool}
  &
  \multicolumn{2}{c}{
  \inferrule
  {
    x\in\Dom{\Gamma} \rulesep
    \Gamma(x) \succ \tau
  }
  { \Gamma\vdash x:\tau}
  \qquad
  \inferrule
  {
    \Gamma\vdash e_1:\tau_1 \rulesep
    \Gamma\vdash e_2:\tau_2
  }
  { \Gamma\vdash e_1;e_2:\tau_2 }
  }
  \\[20pt]
  \inferrule
  { \Gamma[x : \tau]\vdash e : \tau' }
  {\Gamma\vdash \lambda x.e : \tau\rightarrow\tau'}
  &
  \inferrule
  {
    \Gamma\vdash e_1 : \tau\rightarrow\tau' \rulesep
    \Gamma\vdash e_2 : \tau
  }
  { \Gamma\vdash e_1\ e_2 : \tau' }
  &
  \inferrule
  {
    \Gamma\vdash e_1 : \tau \rulesep
    \tau\prec_\Gamma\sigma \rulesep
    \Gamma[x:\sigma]\vdash e_2 : \tau'
  }
  {\Gamma\vdash \textsf{val}\ x=e_1\ \textsf{in}\ e_2 : \tau'}
\end{array}
\]
  \item[] \textbf{ Miscellaneous definitions}
\[
\begin{array}{r@{\hskip4pt}c@{\hskip4pt}l}
  \fbox{$\sigma\succ\tau$}
  &&
  \forall\alpha_1.\cdots\forall\alpha_n.\tau\succ\tau[\alpha_1\leftarrow\tau_1,\ldots,\alpha_n\leftarrow\tau_n]
  \\[1em]
  \fbox{$\tau\prec_\Gamma\sigma$}
  &&
  \inferrule
  { \textit{ FTV}(\tau)\setminus\textit{ FTV}(\Gamma)=\{\alpha_1,\ldots,\alpha_n\} }
  { \tau\prec_\Gamma\forall\alpha_1.\cdots\forall\alpha_n.\tau }
  \\[2em]
\mathit{FTV}(\textsf{num}) &=& \emptyset
\\
\mathit{FTV}(\textsf{bool}) &=& \emptyset
\\
\mathit{FTV}(\tau_1\rightarrow\tau_2) &=& \mathit{FTV}(\tau_1) \cup \mathit{FTV}(\tau_2)
\\
\mathit{FTV}(\alpha) &=& \{\alpha\}
\\
\mathit{FTV}(\forall\alpha.\sigma) &=& \mathit{FTV}(\sigma) \setminus \{\alpha\}
\\
\mathit{FTV}(\Gamma) &=& \bigcup_{x\in\Dom{\Gamma}}\mathit{FTV}(\Gamma(x))
\\
\end{array}
\]
\end{itemize}

\begin{itemize}
\item[a)] Is the following expression well-typed? If so, prove it by
  drawing a type derivation tree for the expression. Otherwise, just say that
    the expression is not well-typed. \textbf{ If you write ``the expression is not
    well-typed'' but the expression is well-typed in fact, you will get
    -3~points, not~0 points, for this subquestion.}

    \Space{1}
    $(\lambda \texttt{x}.(\texttt{x}\ 42))\ \lambda \texttt{z}.\texttt{z}$
    \Space{1}
\item[b)] Is the following expression well-typed? If so, prove it by
  drawing a type derivation tree for the expression. Otherwise, just say that
    the expression is not well-typed. \textbf{ If you write ``the expression is not
    well-typed'' but the expression is well-typed in fact, you will get
    -6~points, not~0 points, for this subquestion.}

    \Space{1}
    $(\lambda \texttt{x}.((\texttt{x}\ 42); (\texttt{x}\ \textsf{true})))\ \lambda \texttt{z}.\texttt{z}$
    \Space{1}
\item[c)] Is the following expression well-typed? If so, prove it by
  drawing a type derivation tree for the expression. Otherwise, just say that
    the expression is not well-typed. \textbf{If you write ``the expression is not
    well-typed'' but the expression is well-typed in fact, you will get
    -6~points, not~0 points, for this subquestion.}

    \Space{1}
    $\textsf{val}\ \texttt{x}=\lambda \texttt{z}.\texttt{z}\ \textsf{in}\ ((\texttt{x}\ 42); (\texttt{x}\ \textsf{true}))$
    \Space{1}
\end{itemize}

\item Rewrite the following code using explicit annotation of polymorphic types
with \verb!tyfun! and \verb!@!
to replace all the occurrences of \verb!?! with types
and to make function calls to take explicit type arguments.

\[
\begin{array}{ll}
% \begin{array}{rl}
% e ::= & n\\
% \mid& \verb!{+!\ e\ e\ \verb+}+\\
% \mid& \verb!{-!\ e\ e\ \verb+}+\\
% \mid& x\\
% \mid& \verb+{fun {+x \verb+:+\tau \verb+} + e\verb+}+\\
% \mid& \verb+{+e\ e \verb+}+\\
% \mid& \verb+{if0 + e\ e\ e\verb+}+\\
% \mid& \verb+[tyfun [+\alpha\verb+] + e\verb+]+\\
% \mid& \verb+[@ +e\ \tau\verb+]+\\
% \tau ::= & \verb+num+\\
% \mid&\verb+(+\tau\verb+ -> +\tau\verb+)+\\
% \mid&\verb+(+\forall \alpha\ \tau\verb+)+\\
% \mid&\alpha
% \end{array}
% &
\begin{array}{ccc}
\newinfrule
{\Gamma[\alpha]\vdash e : \tau}
{\Gamma\vdash\UseVerb{op}\alpha\UseVerb{cl}\ e\UseVerb{cl} : (\forall \alpha\ \tau)}
&\qquad&
\newinfrule{
\Gamma\vdash \tau_0
\rulesep
\Gamma\vdash e : (\forall\alpha\ \tau_1)
}
{\Gamma\vdash\UseVerb{opp}\ e\ \tau_0\UseVerb{cl} : \tau_1[\alpha \leftarrow \tau_0]}
\\[2em]
\newinfrule{
\Gamma[\alpha]\vdash \tau
}
{\Gamma\vdash(\forall\alpha\ \tau)}
&&
[\ldots\alpha\ldots]\vdash\alpha
\end{array}
\end{array}
\]

{
\begin{verbatim}
{with {f : ? {fun {g : ?} {fun {v : ?} {g v}}}}
      {with {g : ? {fun {x : ?} x}}
            {{f g} 10}}}
\end{verbatim}
}

\item We'd like to allow the following expression:

\begin{verbatim}
{withtype {{alpha list} {empty num}
                        {cons (alpha * {alpha list})}}
          {rec {len : (forall alpha ({alpha list} -> num))
                    [tyfun [alpha]
                           {fun {l : {alpha list}}
                                {cases {alpha list} l
                                  {empty {n} 0}
                                  {cons {fxr}
                                        {+ 1 {len {snd fxr}}}}}}]}
               {+ {[@ len num] {[@ cons num] {pair 1 {[@ empty num] 0}}}}
                  {[@ len (num -> num)] {[@ empty (num -> num)] 0}}}}}
\end{verbatim}
and of course the following as well:
\begin{verbatim}
{withtype {fruit {banana num} {apple bool}}
          {{fun {x : fruit} {cases fruit x {banana {n} {+ n 9}} {apple  {b} 76}}}
           {banana 2}}}
\end{verbatim}

Thus, we define the following language:

{
~~~~~~~ $e$ ::= $n$\\
\hspace*{0em}
~~~~~~~~~~~| \verb!{+! $e$ $e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| $x$\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{fun {+$x$\verb+:+$\tau$\verb+}+ $e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{+$e$ $e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{rec {+$x$\verb+:+$\tau$\ $e$\verb+}+ $e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{pair +$e$\ $e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{fst +$e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{snd +$e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{withtype {+$\gamma$\ \verb+{+$x$\ $\tau$\verb+}+
\verb+{+$x$\ $\tau$\verb+}}+ $e$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| \verb+{cases +$\gamma$\ $e$\ 
\verb+{+$x$\ \verb+{+$x$\verb+}+\ $e$\verb+}+
\verb+{+$x$\ \verb+{+$x$\verb+}+\ $e$\verb+}}+\\
\hspace*{0em}
~~~~~~~~~~~| [tyfun [$\alpha$] $e$]\\
\hspace*{0em}
~~~~~~~~~~~| [@ $e$ $\tau$]\\

~~~~~~~ $\tau$ ::= \mbox{\texttt{num}}\\
\hspace*{0em}
~~~~~~~~~~~| ($\tau\rightarrow\tau$)\\
\hspace*{0em}
~~~~~~~~~~~| ($\tau \times \tau$)\\
\hspace*{0em}
~~~~~~~~~~~| $\gamma$\\
\hspace*{0em}
~~~~~~~~~~~| $\alpha$\\
\hspace*{0em}
~~~~~~~~~~~| ($\forall \alpha$ $\tau$)\\

~~~~~~~ $\gamma$ ::= \verb+{+$\alpha\ t$\verb+}+\\
\hspace*{0em}
~~~~~~~~~~~| $t$\\
}

\begin{itemize}
  \item[a)] Write the operational semantics of the form \fbox{$\sigma\vdash e \Rightarrow v$} for the expressions
\texttt{withtype}, \texttt{cases}, and \verb+{+$e$ $e$\verb+}+.

  \item[b)] Write the typing rules of the form \fbox{$\Gamma\vdash e : \tau$} for the expressions
\texttt{withtype} and \texttt{cases} and the well-formedness of user-defined types.

  \item[c)] Consider the following expression:

{
\begin{verbatim}
{withtype {fruit {apple num} {banana num}}
          {{withtype {color {apple num} {banana num}}
                     {fun {x : fruit}
                          {cases fruit x
                            {apple  {a} {apple  {+ a 1}}}
                            {banana {b} {banana {+ b 1}}}}}}
           {apple 42}}}
\end{verbatim}
}

If the result of type checking the expression is \mtt{fruit}, explain why in detail.
Otherwise, revise the typing rules to make it \mtt{fruit}.
\end{itemize}

\item Consider the following language, \texttt{TPFAE}:
\[
\begin{array}{rllrllr@{\hskip3pt}l}
e::= & n &\qquad& \tau::= & \code{num} &\qquad& n\in & \mathbb{Z}\\
\mid& e\verb!+!e &&\mid&\tau\rightarrow\tau && x\in & \mathit{Id}\\
\mid& e\verb!-!e &&\mid&\alpha && \alpha\in & \mathit{TId}\\
\mid& x &&\mid&\forall\alpha.\tau \\
\mid& \lambda x\verb+:+\tau\verb+.+e \\
\mid& e\ e \\
\mid& \lambda\alpha\verb+.+e \\
\mid& e\verb+[+\tau\verb+]+ \\
\end{array}
\]

Type annotations do not take any roles during evaluation.
Therefore, we define type-erasure semantics, which removes
type annotations from an expression.

Consider the following Scala code, which implements type erasure:
\begin{verbatim}
sealed trait TPFAE
case class Num(n: Int) extends TPFAE
case class Add(l: TPFAE, r: TPFAE) extends TPFAE
case class Sub(l: TPFAE, r: TPFAE) extends TPFAE
case class Id(x: String) extends TPFAE
case class Fun(p: String, t: Type, b: TPFAE) extends TPFAE
case class App(f: TPFAE, a: TPFAE) extends TPFAE
case class TyFun(a: String, e: TPFAE) extends TPFAE
case class TyApp(e: TPFAE, t: Type) extends TPFAE

sealed trait Type
case object NumT extends Type
case class ArrowT(t0: Type, t1: Type) extends Type
case class VarT(a: String) extends Type
case class Forall(a: String, t: Type) extends Type

sealed trait FAE
case class FAENum(n: Int) extends FAE
case class FAEAdd(l: FAE, r: FAE) extends FAE
case class FAESub(l: FAE, r: FAE) extends FAE
case class FAEId(x: String) extends FAE
case class FAEFun(p: String, b: FAE) extends FAE
case class FAEApp(f: FAE, a: FAE) extends FAE

def erase(e: TPFAE): FAE = e match {
  case Num(n) => FAENum(n)
  case Add(l, r) => FAEAdd(erase(l), erase(r))
  case Sub(l, r) => FAESub(erase(l), erase(r))
  case Id(x) => FAEId(x)
  case Fun(p, t, b) => FAEFun(p, erase(b))
  case App(f, a) => FAEApp(erase(f), erase(a))
  case TyFun(a: String, e: TPFAE) => erase(e)
  case TyApp(e: TPFAE, t: Type) => erase(e)
}
\end{verbatim}
Erasing a \texttt{TPFAE} expression results in an \texttt{FAE} expression.

The following is the abstract syntax of \texttt{FAE}:
\[
\begin{array}{rl}
E::= & n \\
\mid& E\verb!+!E \\
\mid& E\verb!-!E \\
\mid& x  \\
\mid& \lambda x.E \\
\mid& E\ E  \\
\end{array}
\]

\begin{itemize}
\item[a)] Complete the definition of type erasure \framebox{$[e]=E$} according to the Scala code
by filling the blanks:
\end{itemize}

{
\[
\begin{array}{rcl}
\lbrack n\rbrack &=& n \\
\lbrack x\rbrack &=& x \\
\lbrack e_1\code{+}e_2\rbrack &=& \lbrack e_1\rbrack\code{+}\lbrack e_2\rbrack \\
\lbrack e_1\code{-}e_2\rbrack &=& \sblank \\
\lbrack \lambda x\code{:}\tau\code{.}e\rbrack &=& \sblank \\
\lbrack e_1\ e_2\rbrack &=& \sblank \\
\lbrack \lambda\alpha\code{.}e\rbrack &=& \sblank \\
\lbrack e\code{[}\tau\code{]}\rbrack &=& \sblank \\
\end{array}
\]
}

\begin{itemize}
\item[b)] Fill the following blanks with the results of erasing:
\end{itemize}

{
\[
\begin{array}{rcl}
\lbrack
\code{($\lambda\alpha$.$\lambda$x:$\alpha$.x) [num] 1}
\rbrack
&=&\sblank \\
\lbrack
\code{($\lambda\alpha$.$\lambda\beta$.$\lambda$x:$\alpha$.$\lambda$y:$\beta$.y) [num] [num] 1 2}
\rbrack
&=&\sblank \\
\end{array}
\]
}

\begin{itemize}
\item[c)] Fill the following blank with the expression before erasing:
\end{itemize}

{
\[
\begin{array}{rl@{\hskip-10pt}l}
&\lbrack\code{$\lambda$x:$\forall\alpha$.$\alpha\rightarrow\alpha$.} \\
&\lblank&\rbrack \\[10pt]
=&\code{$\lambda$x.((x $\lambda$x.x) (x 1))}
\end{array}
\]
}

\item Consider the following language, \texttt{TpolyFAE}:
\begin{itemize}
  \item[]\textbf{Abstract syntax}
\[
\begin{array}{r@{\hskip6pt}r@{\hskip6pt}l
  r@{\hskip6pt}l@{\hskip20pt}
  r@{\hskip6pt}l@{\hskip20pt}
  r@{\hskip4pt}c@{\hskip4pt}l@{\hskip20pt}
  r@{\hskip4pt}c@{\hskip4pt}l}
  e &::= & n &|& e\ e & \tau::= & \textsf{num} & n &\in& \mathbb{Z}& e &\in& \textit{Expr} \\
  &|& x &|& \Lambda\alpha.e &|&\tau\rightarrow\tau & x &\in& \textit{Id}& \tau &\in& \textit{Type} \\
  &|& \lambda x{:}\tau.e &|& e[\tau] &|&\alpha & \alpha &\in& \textit{TV}&
  \Gamma &\in& (\textit{Id}\cup\textit{TV})\rightarrow(\textit{Type}\cup\{\cdot\}) \\
  &&&&&|&\forall\alpha.\tau \\
\end{array}
\]
  \item[]\textbf{Typing rules}
\[
\begin{array}{c@{\hskip20pt}c@{\hskip20pt}c}
\Gamma\vdash n:\textsf{num}
  &
  \inferrule
  { x\in\Dom{\Gamma} }
  { \Gamma\vdash x:\Gamma(x) }
  &
  \inferrule
  { \Gamma[x:\tau]\vdash e:\tau' \rulesep \Gamma\vdash\tau }
  { \Gamma\vdash \lambda x{:}\tau.e:\tau\rightarrow\tau' }
  \\[20pt]
  \inferrule
  { \Gamma\vdash e_1:\tau\rightarrow\tau' \rulesep
    \Gamma\vdash e_2:\tau }
  { \Gamma\vdash e_1\ e_2:\tau' }
  &
  \inferrule
  {
    \alpha\not\in\Dom{\Gamma} \rulesep
    \Gamma[\alpha]\vdash e:\tau
  }
  { \Gamma\vdash \Lambda\alpha.e:\forall\alpha.\tau }
  &
  \inferrule
  {
    \Gamma\vdash e:\forall\alpha.\tau_1 \rulesep
    \Gamma\vdash\tau_0
  }
  { \Gamma\vdash e[\tau_0]:\tau_1[\alpha\leftarrow\tau_0] }
\end{array}
\]
  \item[]\textbf{Well-formedness rules}
\[
\begin{array}{c@{\hskip40pt}c@{\hskip40pt}c@{\hskip40pt}c}
  \Gamma\vdash\textsf{num}
  &
  \inferrule
  { \Gamma\vdash\tau \rulesep \Gamma\vdash\tau' }
  { \Gamma\vdash\tau\rightarrow\tau' }
  &
  \inferrule
  { \alpha\in\Dom{\Gamma} }
  { \Gamma\vdash\alpha }
  &
  \inferrule
  { \Gamma[\alpha]\vdash\tau }
  { \Gamma\vdash\forall\alpha.\tau }
\end{array}
\]
\end{itemize}

\Space{2}

Type annotations do not take any roles during evaluation.
Therefore, we define type-erasure semantics, which removes
type annotations from an expression.
Erasing types from a \texttt{TpolyFAE} expression results
in an \texttt{FAE} expression. The following is the abstract syntax of \texttt{FAE}:
\[
  E::= n \ |\ x\ |\ \lambda x.E\ |\ E\ E \\
\]

\begin{itemize}
\item[a)] 
  Define type erasure of the form \framebox{$\textit{erase}(e)=E$} for \texttt{ TpolyFAE}.
\end{itemize}

\begin{itemize}
\item[b)] 
  Write \texttt{ FAE} expressions that are obtained by erasing types from the
    following expressions.
    \begin{itemize}
      \item[$\circ$] $(\Lambda\alpha.\lambda \texttt{x}{:}\alpha.\texttt{x})\ [\textsf{num}]\ 1$
      \item[$\circ$]
        $(\Lambda\alpha.\Lambda\beta.\lambda\texttt{x}{:}\alpha.\lambda\texttt{y}{:}\beta.\texttt{y})
        \ [\textsf{num}]\ [\textsf{num}]\ 1\ 2$
    \end{itemize}
\end{itemize}

\begin{itemize}
\item[c)] 
  Write well-typed \texttt{ TpolyFAE} expressions that produce
    the following \texttt{ FAE} expressions after the type erasure.
    \begin{itemize}
      \item[$\circ$] $(\lambda \texttt{x}.\lambda \texttt{y}.((\texttt{x}\ \texttt{x})\ \texttt{y}))\
        (\lambda \texttt{x}.\texttt{x})\ 1$
      \item[$\circ$] $\lambda \texttt{x}.((\texttt{x}\ \lambda \texttt{x}.\texttt{x})\ (\texttt{x}\ 1))$
    \end{itemize}
\end{itemize}

\item The following language adds
polymorphic non-recursive type definitions to \texttt{TpolyFAE}
(the omitted parts are the same as \texttt{TpolyFAE}):

\Space{1}
$
  \begin{array}{l}
    e ::=\ \cdots\ \ |\ \ \textsf{type}\ t[\alpha]=x@\tau+x@\tau;\ e\ \ |\ \ 
           e\ \textsf{match}\ x(x)\rightarrow e,\ x(x)\rightarrow e \\
    v ::=\ \cdots\ \ |\ \ \Lambda\alpha.\langle x\rangle\ \ |\ \ \langle x\rangle\ \ |\ \  x(v) \\
    \tau ::=\ \cdots\ \ |\ \  t[\tau] \\
    \Gamma\ \in\ \finmap{(\embox{Id}\cup\embox{TVar}\cup\embox{TId})}
    {(\embox{Type}\cup\{\cdot\}
    \cup(\embox{TVar}\times\embox{Id}\times\embox{Type}\times\embox{Id}\times\embox{Type}))}
  \end{array}
$

\[
  \begin{array}{c}
  \inferrule
  { \eval{\sigma[x_1\mapsto\Lambda\alpha.\langle x_1\rangle,x_2\mapsto\Lambda\alpha.\langle x_2\rangle]}{e}{v} }
  { \evald{\textsf{type}\ t[\alpha]=x_1@\tau_1+x_2@\tau_2;\ e}{v} }
  \qquad\quad
  \inferrule
  { \evald{e}{\Lambda \alpha.\langle x\rangle} }
  { \evald{\etapp{e}{\tau}}{\langle x\rangle} }
  \qquad\quad
  \inferrule
  { \evald{e_1}{\langle x\rangle} \\ \evald{e_2}{v} }
  { \evald{\eapp{e_1}{e_2}}{x(v)} }
    \\[2em]
  \inferrule
  { \evald{e}{x_1(v')} \\ \eval{\sigma[x_3\mapsto v']}{e_1}{v} }
  { \evald{e\ \textsf{match}\ x_1(x_3)\rightarrow e_1,x_2(x_4)\rightarrow e_2}{v} }
  \qquad\qquad
  \inferrule
  { \evald{e}{x_2(v')} \\ \eval{\sigma[x_4\mapsto v']}{e_2}{v} }
  { \evald{e\ \textsf{match}\ x_1(x_3)\rightarrow e_1,x_2(x_4)\rightarrow e_2}{v} }
  \end{array}
\]

For example, programmers can write the following code, which defines a polymorphic
option type, in this language:

\Space{1}
$
  \begin{array}{l}
    \textsf{type}\ \texttt{option}[\alpha]=\texttt{None}@\numt+\texttt{Some}@\alpha;\\
    \textsf{val}\ \texttt{getOrElse}=\etfun{\alpha}{\efun{\texttt{x}{:}\texttt{option}[\alpha]}{
      \efun{\texttt{y}{:}\alpha}{(}} \\
    \ \ \ \ \texttt{x}\ \textsf{match}} \\
    \ \ \ \ \ \ \ \ \texttt{None}(\texttt{z})\rightarrow\texttt{y}, \\
    \ \ \ \ \ \ \ \ \texttt{Some}(\texttt{z})\rightarrow\texttt{z} \\
    );\\
    \eapp{\eapp{\etapp{\texttt{getOrElse}}{\numt}}{(\eapp{\etapp{\texttt{Some}}{\numt}}{1})}}{2}
  \end{array}
$
\Space{1}

On the other hand, the following code is not well-typed
since types are not recursive in this language:

\Space{1}
$
  \begin{array}{l}
    \textsf{type}\ \texttt{foo}[\alpha]=\texttt{bar}@\numt+\texttt{baz}@\texttt{foo}[\alpha];\\
    \ldots
  \end{array}
$
\Space{1}

Note that \texttt{foo} appears in the definition of itself, which implies that
\texttt{foo} is a recursive type.

\begin{enumerate}
\item[a)]
  Write the typing rules of the form
    \fbox{$\typeofd{e}{\tau}$} of
    $\textsf{type}\ t[\alpha]=x_1@\tau_1+x_2@\tau_2;\ e$ and
    $e\ \textsf{match}\ x_1(x_3)\rightarrow e_1,\ x_2(x_4)\rightarrow e_2$.
\item[b)]
  Write the well-formedness rule of the form
    \fbox{$\Gamma\vdash\tau$} of $t[\tau]$.
\item[c)]
  Write the type of \texttt{getOrElse} of the above example. You do not need to
    draw the type derivation tree of \texttt{getOrElse}.
\end{enumerate}



\end{enumerate}
