\setchapterpreamble[u]{\margintoc}
\chapter{Recursion}
\labch{recursion}

The article defines RFAE featuring recursive functions.

\section{CFAE}

CFAE adds conditional expressions to FAE.

\subsection{Syntax}

The below is the abstract syntax of CFAE. It shows a conditional expression,
which is the only new feature.

\[
\begin{array}{lrcl}
\text{Expression} & e & ::= & \cdots \\
&& | & \textsf{if0}\ e\ e\ e
\end{array}
\]

\(\textsf{if0}\) is similar to \(\textsf{if}\) of BAE, defined by the last
article, but its condition can be any value since CFAE lacks Boolean values. If a
condition is zero, the true branch is evaluated; otherwise, the false branch is
evaluated.

\subsection{Semantics}

The following define the semantics of conditional expressions:

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow 0 \\ \sigma\vdash e_2\Rightarrow v }
{ \sigma\vdash \textsf{if0}\ e_1\ e_2\ e_3\Rightarrow v}
\]

\[
\inferrule
{ \sigma\vdash e_1\Rightarrow v' \\ v'\not=0 \\ \sigma\vdash e_3\Rightarrow v }
{ \sigma\vdash \textsf{if0}\ e_1\ e_2\ e_3\Rightarrow v}
\]

The semantics is similar to that of \(\textsf{if}\). Always one of the true and
false branches are evaluated, but not both.

\section{Recursion}

Is it possible to implement a factorial function with CFAE? Assume that CFAE
features multiplications. Firstly, consider a factorial function written
functionally. The following Scala function calculates factorials:

\begin{verbatim}
def factorial(n: Int): Int =
  if (n == 0) 1
  else n * factorial(n â€“ 1)
\end{verbatim}

It seems the following CFAE expression is equivalent to the above code:

\[\textsf{val}\ factorial=\lambda n.\textsf{if0}\ n\ 1\ (n\times(factorial\
(n-1)))\ \textsf{in}\ \cdots\]

However, it is wrong since the scope of the binding occurrence of \(factorial\)
includes \(\cdots\) but excludes the lambda abstraction. Identifier \(factorial\)
in the lambda expression is free. CFAE disallows defining recursive functions.

\section{RFAE}

RFAE adds recursive functions to CFAE.

\subsection{Syntax}

The below is the abstract syntax of RFAE. It omits features common to CFAE.

\[
\begin{array}{lrcl}
\text{Expression} & e & ::= & \cdots \\
&& | & \textsf{def}\ x(x)=e\ \textsf{in}\ e
\end{array}
\]

\(\textsf{def}\ x_1(x_2)=e_1\ \textsf{in}\ e_2\) defines a recursive function. \(x_1\)
is the name of a function, and both \(e_1\) and \(e_2\) can refer to \(x_1\). For
example, the following is a factorial function:

\[\textsf{def}\ factorial(n)=\textsf{if0}\ n\ 1\ (n\times(factorial\ (n-1)))
\ \textsf{in}\ factorial\ 10\]

\subsection{Semantics}

The following defines the semantics of recursive functions:

\[
\inferrule
{ \sigma'=\sigma\lbrack x_1\mapsto\langle\lambda x_2.e_1,\sigma'\rangle\rbrack \\
  \sigma'\vdash e_2\Rightarrow v
}
{ \sigma\vdash \textsf{def}\ x_1(x_2)=e_1\ \textsf{in}\ e_2\Rightarrow v}
\]

The closure of a recursive function is similar to that of a lambda abstraction
but does not store the environment of the moment. Instead, it stores an
environment obtained by adding that the name of the function denotes the closure
to the environment. Calling a closure evaluates the body of the closure under the
environment of the closure so that recursive calls are valid.

The below proof trees prove that the factorial of one is one. The proof splits
into three trees for readability.

\[
\begin{array}{rcl}
\sigma_1&=&\lbrack f\mapsto\langle\lambda n.\textsf{if0}\ n\ 1\ (n\times(f\
(n-1))),\sigma_1\rangle\rbrack \\
\sigma_2&=&\sigma_1\lbrack n\mapsto 1\rbrack \\
&=&\lbrack f\mapsto\langle\lambda n.\textsf{if0}\ n\ 1\ (n\times(f\
(n-1))),\sigma_1\rangle,n\mapsto 1\rbrack \\
\sigma_3&=&\sigma_1\lbrack n\mapsto 0\rbrack \\
&=&\lbrack f\mapsto\langle\lambda n.\textsf{if0}\ n\ 1\ (n\times(f\
(n-1))),\sigma_1\rangle,n\mapsto 0\rbrack \\
\end{array}
\]

Assume the above.

\[
\inferrule
{
  \inferrule
  { f\in\mathit{Domain}(\sigma_2) }
  { \sigma_2\vdash f\Rightarrow \langle\lambda n.\textsf{if0}\ n\ 1\ (n\times(f\
(n-1))),\sigma_1\rangle }
  \\
  \inferrule
  {
    \inferrule
    { n\in\mathit{Domain}(\sigma_2) }
   { \sigma_2\vdash n\Rightarrow 1 } \\
    \sigma_2\vdash 1\Rightarrow 1
  }
  { \sigma_2\vdash n-1\Rightarrow 0 } \\
  \inferrule
  {
    \inferrule
    { n\in\mathit{Domain}(\sigma_3) }
    { \sigma_3\vdash n\Rightarrow 0 } \\
    \sigma_3\vdash 1\Rightarrow 1
  }
  { \sigma_3\vdash \textsf{if0}\ n\ 1\ (n\times(f\ (n-1))) \Rightarrow 1 }
}
{ \sigma_2\vdash f\ (n-1)\Rightarrow 1 }
\]

\[
\inferrule
{
  \inferrule
  { f\in\mathit{Domain}(\sigma_1)}
  { \sigma_1\vdash f\Rightarrow\langle\lambda n.\textsf{if0}\ n\ 1\ (n\times(f\
(n-1))),\sigma_1\rangle }
  \\
  {\sigma_1\vdash 1\Rightarrow 1}
  \\
  \inferrule
  {
    \inferrule
    { n\in\mathit{Domain}(\sigma_2) }
    { \sigma_2\vdash n\Rightarrow 1 } \\
    \inferrule
    {
      \inferrule
      { n\in\mathit{Domain}(\sigma_2) }
      { \sigma_2\vdash n\Rightarrow 1 } \\
      \sigma_2\vdash f\ (n-1)\Rightarrow 1
    }
    { \sigma_2\vdash (n\times(f\ (n-1)))\Rightarrow 1 }
  }
  {\sigma_2\vdash\textsf{if0}\ n\ 1\ (n\times(f\ (n-1)))\Rightarrow 1 }
}
{ \sigma_1\vdash f\ 1\Rightarrow 1 }
\]

\[
\inferrule
{
  \sigma_1=\lbrack f\mapsto\langle\lambda n.\textsf{if0}\ n\ 1\ (n\times(f\
(n-1))),\sigma_1\rangle\rbrack
  \\
  \sigma_1\vdash f\ 1\Rightarrow 1
}
{\emptyset\vdash
\textsf{def}\ f(n)=\textsf{if0}\ n\ 1\ (n\times(f\ (n-1)))\ \textsf{in}\ f\ 1
\Rightarrow 1
}
\]

\subsection{Implementing an Interpreter}

The following Scala code implements the abstract syntax and environments of RFAE:

\begin{verbatim}
sealed trait Expr
case class Num(n: Int) extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Sub(l: Expr, r: Expr) extends Expr
case class Mul(l: Expr, r: Expr) extends Expr
case class Id(x: String) extends Expr
case class Fun(x: String, b: Expr) extends Expr
case class App(f: Expr, a: Expr) extends Expr
case class If0(c: Expr, t: Expr, f: Expr) extends Expr
case class Rec(f: String, x: String, b: Expr, e: Expr) extends Expr

sealed trait Value
case class NumV(n: Int) extends Value
case class CloV(p: String, b: Expr, var e: Env) extends Value

type Env = Map[String, Value]
def lookup(x: String, env: Env): Value =
  env.getOrElse(x, throw new Exception)
\end{verbatim}

\verb!If0! instnaces corresponds to conditional expressions; \verb!Rec! instances
corresponds to recursive functions. \verb!CloV! instances, which are closures,
have mutable environments because adding themselves to the environments requires
the environments mutable.

\begin{verbatim}
def interp(e: Expr, env: Env): Value = e match {
  case Num(n) => NumV(n)
  case Add(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n + m)
  case Sub(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n - m)
  case Mul(l, r) =>
    val NumV(n) = interp(l, env)
    val NumV(m) = interp(r, env)
    NumV(n * m)
  case Id(x) => lookup(x, env)
  case Fun(x, b) => CloV(x, b, env)
  case App(f, a) =>
    val CloV(x, b, fEnv) = interp(f, env)
    interp(b, fEnv + (x -> interp(a, env)))
  case If0(c, t, f) =>
    interp(
      if (interp(c, env) == NumV(0)) t else f,
      env
    )
  case Rec(f, x, b, e) =>
    val cloV = CloV(x, b, env)
    val nenv = env + (f -> cloV)
    cloV.e = nenv
    interp(e, nenv)
}
\end{verbatim}

The \verb!If0! case evaluates the true branch if the condition equals
\verb!NumV(0)! and the false branch otherwise. The \verb!Rec! case constructs a
closure and adds the closure to the environment of the closure.

The following calculates the factorial of three by calling the \verb!interp!
function:

\begin{verbatim}
// def f(n) = if0 n 1 (n * (f (n-1))) in f(3)
interp(
  Rec(
    "f", "n",
    If0(Id("n"),
        Num(1),
        Mul(
          Id("n"),
          App(Id("f"), Sub(Id("n"), Num(1)))
        )
    ),
    App(Id("f"), Num(3))
  ),
  Map.empty
)
// NumV(6)
\end{verbatim}

\section{Encoding Recursive Functions
}

As lambda calculus is Turing complete, recursive functions are encodable with
lambda calculus. Since both FAE and CFAE subsume the features of lambda calculus,
recursive functions are encodable with them as well.

\[
\begin{array}{rcl}
Z&\equiv&\lambda f.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\
x\ v)\\
\mathit{encode}(\textsf{def}\ x_1(x_2)=e_1\ \textsf{in}\ e_2)&=&
(\lambda x_1.e_2)\ (Z\ \lambda x_1.\lambda x_2.e_1)
\end{array}
\]

\(Z\) is a \term{fixed point combinator}; it calculates a fixed point of a given
function. A fixed point of a function is a value that makes the function yield
itself: a fixed point of function \(f\) is any \(x\) satisfying \(f(x)=x\). If an
argument given to \(Z\) is a function whose fixed point is a particular recursive
function, the result of applying \(Z\) to the function is the recursive function.
Consider \(\lambda f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1)))\). If
\(f\) is a factorial function, then \(\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\
(x-1)))\) also is. Thus, the factorial function is a fixed point of \(\lambda
f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1)))\), and \(Z\ \lambda f.\lambda
x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1)))\) also is a factorial function.

How does the fixed point combinator work? \(Z\ \lambda f.\lambda x.\textsf{if0}\
x\ 1\ (x\times(f\ (x-1)))\) equals \( (\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda
x.f\ \lambda v.x\ x\ v)\) if \(f\) denotes \(\lambda f.\lambda x.\textsf{if0}\ x\
1\ (x\times(f\ (x-1)))\). It equals \(f\ \lambda v.(\lambda x.f\ \lambda v.x\ x\
v)\ (\lambda x.f\ \lambda v.x\ x\ v)\ v\). Applying \(f\) to the argument results
in \(\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (\lambda v.(\lambda x.f\ \lambda
v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v)\ v)\ (x-1)))\). Applying the
function to \(0\) yields \(1\) since \(x\) is \(0\). On the other hand, applying
the function to a nonzero value leads to \(x\times((\lambda v.(\lambda x.f\
\lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v)\ v)\ (x-1))\). Then,
\(\lambda v.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v)\
v\) has reappeared, but its argument has decreased by one. It successfully
simulates a recursive call and calculates factorials.

The following shows how to get the factorial of one:

\[
\begin{array}{rll}
& Z\ (\lambda f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1))))\ 1 \\
=&
(\lambda f.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v))\
(\lambda f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1))))\ 1 \\
&& (f\leftarrow\lambda f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1)))) \\
\rightarrow &
(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v)\ 1 &
(f=\lambda f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1)))) \\
&& (x\leftarrow\lambda x.f\ \lambda v.x\ x\ v) \\
\rightarrow &
f\ (\lambda v.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v)\
v)\ 1 \\
= &
(\lambda f.\lambda x.\textsf{if0}\ x\ 1\ (x\times(f\ (x-1))))\ (\lambda
v.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\ x\ v)\ v)\ 1\\
&& (f\leftarrow\lambda v.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda
v.x\ x\ v)\ v) \\
\rightarrow &
(\lambda x.\textsf{if0}\ x\ 1\ (x\times((\lambda v.(\lambda x.f\ \lambda v.x\ x\
v)\ (\lambda x.f\ \lambda v.x\ x\ v)\ v)\ (x-1))))\ 1 \\
&& (x\leftarrow 1) \\
\rightarrow &
1\times((\lambda v.(\lambda x.f\ \lambda v.x\ x\ v)\ (\lambda x.f\ \lambda v.x\
x\ v)\ v)\ 0)
\end{array}
\]

Via the fixed point combinator, a factorial function is implementable without
using a recursive function of RFAE.

\begin{verbatim}
// lambda f.(lambda x.f lambda v.x x v) (lambda x.f lambda v.x x v)
val Z =
  Fun("f",
    App(
      Fun("x",
        App(
          Id("f"),
          Fun("v", App(App(Id("x"), Id("x")), Id("v")))
        )
      ),
      Fun("x",
        App(
          Id("f"),
          Fun("v", App(App(Id("x"), Id("x")), Id("v")))
        )
      )
    )
  )

// (Z lambda f.lambda n.if0 n 1 (n * (f (n-1)))) 3
interp(
  App(
    App(
      Z,
      Fun("f", Fun("n",
        If0(Id("n"),
            Num(1),
            Mul(
              Id("n"),
              App(Id("f"), Sub(Id("n"), Num(1)))
            )
        )
      ))
    ),
    Num(3)
  ),
  Map.empty
)
// NumV(6)
\end{verbatim}

\section{Exercises}

\begin{enumerate}
\item Explain why the following code is an infinite loop and describe how to break the infinite loop:

\begin{verbatim}
 1 val mkRec = { bodyProc => {
 2   val fX = {fY => {
 3     val f = fY(fY)
 4     bodyProc(f)
 5   }};
 6   fX(fX)
 7 }};
 8 val fac = mkRec({ fac => {
 9   n => if0 (n) { 1 } else { (n * fac((n - 1))) }
10 }});
11 fac(10)
\end{verbatim}

\item Consider the following definition of \texttt{mkRec} and its use to define the recursive
function \texttt{fib}:

\begin{verbatim}
val mkRec = { bodyProc => {
  val fX = {fY => {
    val f = x => (fY(fY))(x)
    bodyProc(f)
  }};
  fX(fX)
}};
val fib = mkRec({ fib => {
  n => if ((n = 0) or (n = 1)) { 1 } else { (fib(n-1) + fib((n-2))) }
}});
fac(10)
\end{verbatim}

Describe what conditions \texttt{bodyProc} should satisfy so that \texttt{mkRec} can make its recursive version.

\item Let's call the following code $A$:
\begin{verbatim}
val fac = val facX = {facX => {
                       n => {
                         val fac = facX(facX);
                         if0 n 1 (n * fac(n-1))
                     }}};
          (facX facX);
fac(5)
\end{verbatim}
and the following code $B$:
\begin{verbatim}
val fac = val facX = {facX => {
                       val fac = facX(facX);
                       n => {
                         if0 n 1 (n * fac(n-1))
                       }}};
          (facX facX);
fac(5)
\end{verbatim}

\begin{itemize}
  \item[a)] What is the result of $A$?
  \item[b)] What is the result of $B$?
\end{itemize}

\item Write the value of \texttt{fac} at line 11:

\begin{verbatim}
 1 {with {fac
 2         {with {facX
 3                 {fun {facY}
 4                    {with {fac {fun {x} {{facY facY} x}}}
 5                          ; Exactly like original fac
 6                          {fun {n}
 7                             {if0 n
 8                                  1
 9                                  {* n {fac {- n 1}}}}}}}}
10               {facX facX}}}
11       {fac 10}}
\end{verbatim}

using the following Scala types:
\begin{verbatim}
trait FWAEValue
case class NumV(n: Int) extends FWAEValue
case class CloV(param: String, body: String, env: Env) extends FWAEValue
type Env = Map[String, FWAEValue]
\end{verbatim}
Note that the type of the body  of \texttt{CloV} is \texttt{String}.

\item Consider the following language $e$:
\[
\begin{array}{rll}
e ::= & n\\
\mid& \verb!{- ! e\ e\verb+}+\\
\mid& b\\
\mid& \verb!{and ! e\ e\verb+}+\\
\mid& \verb!{not ! e\verb+}+\\
\mid& \verb!{if ! e\ e\ e\verb+}+\\
\mid& x\\
\mid& \verb!{fun {! x^*\verb+} +e\verb+}+\\
\mid& \verb!{! e\ e^*\verb+}+\\
\mid& \verb!{rec {! x\ e\verb+} +e\verb+}+\\
\end{array}
\]
where $n$ denotes a number, $b$ denotes a boolean, $x$ denotes an identifier,
and a value $v$ of the language is one of a number, a boolean, or a closure
$\langle \lambda x_1\ \cdots\ x_n .\ e,\ \sigma\rangle$.
It does not support the short-circuiting semantics.
\begin{itemize}
  \item[a)]
Write the operational semantics of the form \fbox{$\sigma\vdash e \Rightarrow v$} for the expressions.
  \item[b)] Write the evaluation derivation of the following expressions:

\hspace*{-5em}
\derive {\hspace*{\textwidth}}
{\emptyset\vdash \{\{\texttt{fun}\ \{f\ m\}\ \{f\ m\}\}\
\{\texttt{fun}\ \{x\}\ x\}\ 8\} \Rightarrow~~~~~~~~}

% To Add
%%
\hspace*{-5em}
\derive
{\hspace*{\textwidth}}
{[\texttt{zero} \mapsto \langle 
\lambda x_1\ x_2\ x_3 .\ 
\texttt{\{if}\ x_1\ x_2\ x_3\texttt{\}},\
\emptyset\rangle] \vdash \term{pgm}
\Rightarrow~~~~~~~~
}

\bigskip
where \term{pgm} is as follows:
\[
\begin{array}{l}
\texttt{\{rec \{visit \{fun \{b\ n\} \{if b n \{visit \{not b\} \{zero n\}\}\}\}\}}\\
\texttt{\phantom{\{rec }\{rec \{zero \{fun \{x\} \{- 42 x\}\}\}}\\
\texttt{\phantom{\{rec \{rec }\{visit false 7\}\}\}}
\end{array}
\]

\end{itemize}


\end{enumerate}
